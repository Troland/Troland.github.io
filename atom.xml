<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poeticlife</title>
  
  <subtitle>大知闲闲，小知间间；大言炎炎，小言詹詹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-11-04T15:45:11.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Troland</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DOM相关</title>
    <link href="http://yoursite.com/2017/10/28/DOM%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/10/28/DOM相关/</id>
    <published>2017-10-28T04:12:36.000Z</published>
    <updated>2017-11-04T15:45:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在整理一些JavaScript基础知识，因为这些知识对于框架的构建等是很有好处的，本文大部分是翻译加上自己的理解。</p><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>假设有两个元素，元素A和元素B，元素A内嵌元素B。当两个元素同时绑定的相同的事件监听器的时候哪个会先触发？</p><p>事件模型有两种</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>以下图例为事件捕获的示意图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">            |  |</div><div class="line">------------|  |-------------</div><div class="line">| element1                  |</div><div class="line">|  ---------|  |----------   |</div><div class="line">| |element2 \ /         |  |</div><div class="line">|  -----------------------  |  </div><div class="line">|   事件捕获                  |</div><div class="line">|----------------------------</div></pre></td></tr></table></figure><p>元素1的事件句柄先执行，然后才是元素2。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">           / \   </div><div class="line">-----------| |--------------</div><div class="line">| element1 | |              |</div><div class="line">| ---------| |-----------   |</div><div class="line">| |element2             |   |</div><div class="line">|  ----------------------   |</div><div class="line">|   事件冒泡                 |</div><div class="line">|---------------------------</div></pre></td></tr></table></figure><p>元素2的事件句柄先执行，然后才是元素1。</p><h3 id="W3C事件模型"><a href="#W3C事件模型" class="headerlink" title="W3C事件模型"></a>W3C事件模型</h3><p>W3C事件模型是先捕获到目标元素然后再冒泡。</p><figure class="highlight plain"><figcaption><span>|  / \</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---------------| |--| |-------------</div><div class="line">| element1     | |  | |             |</div><div class="line">|   -----------| |--| |---------    |</div><div class="line">|   | element2 \ /  | |         |   |</div><div class="line">|    ---------------------------    |</div><div class="line">|    W3C 事件模型                     |</div><div class="line">|-----------------------------------</div></pre></td></tr></table></figure><p>那么开发者可以选择在捕获阶段或者冒泡阶段注册事件句柄。<br><code>addEventListener</code>的最后一个参数为<code>true</code>表示是捕获阶段，否则是冒泡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.addEventListener(&apos;click&apos;,doSomething2,true)</div><div class="line">element2.addEventListener(&apos;click&apos;,doSomething,false)</div></pre></td></tr></table></figure><p>如果用户点击了元素2的事件过程：</p><ul><li>在捕获阶段，查找元素2的祖先元素是否注册了事件句柄。</li><li>发现element1.doSomething2然后执行</li><li>事件来到目标元素2，没有为捕获阶段注册的事件句柄，事件开始冒泡并且执行元素2为冒泡注册的事件句柄<code>doSomething</code></li><li>事件来往上冒泡检查元素2的祖先元素有没有为冒泡阶段注册的事件句柄。</li></ul><p>与之相反：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.addEventListener(&apos;click&apos;,doSomething2,false)</div><div class="line">element2.addEventListener(&apos;click&apos;,doSomething,false)</div></pre></td></tr></table></figure><p>当点击元素2的时候事件过程如下：</p><ul><li><code>click</code>事件开始捕获阶段，检查元素2的祖先元素是否有为捕获阶段注册的事件句柄检查没有。</li><li>来到目标元素2，来到事件的冒泡阶段并且执行<em>doSomething</em>。</li><li>事件冒泡检查元素2的祖先元素有为冒泡阶段注册的事件句柄。</li><li>发现元素1有则执行<em>doSomething2</em>。</li></ul><p>可以看一下示例, <strong>打开控制台观察点击元素事件的输出</strong></p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Wudiemperor/rnr5sa2h/1/embedded/js,html,css,result/light" frameborder="0" allowfullscreen></iframe><h3 id="与传统模型兼容"><a href="#与传统模型兼容" class="headerlink" title="与传统模型兼容"></a>与传统模型兼容</h3><p>在支持W3C DOM浏览器中一个传统的事件注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element1.onclick = doSomething2;</div></pre></td></tr></table></figure><p>会被注册在冒泡阶段。</p><h3 id="事件捕获和冒泡一直都会发生"><a href="#事件捕获和冒泡一直都会发生" class="headerlink" title="事件捕获和冒泡一直都会发生"></a>事件捕获和冒泡一直都会发生</h3><p>事件冒泡和捕获一直都会发生。当你定义<code>document</code>的全局点击事件句柄的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document.onclick = doSomething;</div><div class="line">if (document.captureEvents) document.captureEvents(Event.CLICK);</div></pre></td></tr></table></figure><p>对于文档内的任意元素上的点击事件最终都会冒泡到<code>document</code>上，只有当之前的事件句柄明确不让事件冒泡，就不会传播到<code>document</code>上。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>因为所有的事件都会冒泡到<code>document</code>上，默认的事件句柄是可能的。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">--------------------------------</div><div class="line">| document                      |</div><div class="line">|    ------------   ---------   |</div><div class="line">|    | element1  | | element2|  |</div><div class="line">|    ------------- -----------  |</div><div class="line">|--------------------------------</div><div class="line"></div><div class="line">element1.onclick = doSomething;</div><div class="line">element2.onclick = doSomething;</div><div class="line">element3.onclick = defaultFunction;</div></pre></td></tr></table></figure><p>当用户点击元素1或者2的时候<code>doSomething</code>会执行。你可以在点击元素1或者2的时候阻止冒泡到<code>defaultFunction</code>.如果用户点击这两个元素以外的其它地方则会执行<code>defaultFunction</code>.</p><p>设置这个<em>文档</em>的事件句柄在写拖拽脚本的时候是必须的。<br>一般是<code>mousedown</code>事件在所选择的层上然后响应<code>mousemvoe</code>事件。虽然<code>mousedown</code>为了避免浏览器bugs而注册在拖拽目标上，其它的事件句柄必须是注册在<code>document</code>上。</p><p>有可能会发生用户非常粗野地移动鼠标然后脚本出现问题导致鼠标没有在目标层上。</p><ul><li>如果<code>onmousemove</code>事件句柄是注册在目标层上，目标层元素没有响应鼠标移动，让人困惑。</li><li>如果<code>onmouseup</code>事件句柄注册在目标层上，这个事件不会被捕捉到导致当用户认为他已经松开目标层的时候仍然在响应鼠标的移动事件。这会让人更加困惑。</li></ul><p>**所以在这种情况下<code>mousemove和mouseup</code>得注册在<code>document</code>上以确保这两个事件会一直被触发。</p><h3 id="关掉事件冒泡"><a href="#关掉事件冒泡" class="headerlink" title="关掉事件冒泡"></a>关掉事件冒泡</h3><p>可以关闭所有的事件冒泡。在IE下可以执行<code>window.event.cancelBubble = true</code>.</p><p>在W3C模型下可以执行<code>e.stopPropagation()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function doSomething(e)</div><div class="line">&#123;</div><div class="line">if (!e) var e = window.event;</div><div class="line">e.cancelBubble = true;</div><div class="line">if (e.stopPropagation) e.stopPropagation();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h3><p>event有一个<code>target</code>或者<code>srcElement</code>(旧版本的IE包含这个属性)是指向注册该事件的元素。不管是在捕获还是冒泡阶段这个都会指向的注册了事件的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.onclick = doSomething;</div><div class="line">element2.onclick = doSomething;</div></pre></td></tr></table></figure><p>当用户点击了元素2<code>doSomething</code>会执行两次。那么如何知道被点击的是哪个元素呢？<code>currentTarget</code>会指向注册该事件的元素。但是微软并没有类似的属性。</p><p>你可以在函数中用<code>this</code>关键字得到触发事件的元素。</p><h3 id="微软模型的问题"><a href="#微软模型的问题" class="headerlink" title="微软模型的问题"></a>微软模型的问题</h3><p>但是当你使用微软的事件注册模型<code>this</code>关键字并不指注册该事件的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.onclick = doSomething;</div><div class="line">element2.onclick = doSomething;</div></pre></td></tr></table></figure><p>在IE中无法知道<code>domeSomething</code>事件中的this指向的是哪个元素。微软并没有对应的类似<code>currentTarget</code>的属性。</p><p>在<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget" target="_blank" rel="external">MDN上的currentTarget</a>可以看到在<strong>IE6-8</strong>中是没有这个属性的。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Vue中有一个事件的修饰符<code>.self</code>是为了表示事件只能由当前的元素触发，而不能是其后代元素。</p><p>实现原理大概是要对<code>target</code>和<code>currentTarget</code>进行比对,相等则表示是注册了该事件的元素否则是其后代元素。相关代码就不贴出了。</p><p>那么Vue当中的事件的修饰符<code>.self</code>大概也是这个思路吧？过段时间再看下源码吧-^.^-。</p><p>以上文章是翻译的文章再加上自己的一些理解,原文见<a href="https://www.quirksmode.org/js/events_order.html" target="_blank" rel="external">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在整理一些JavaScript基础知识，因为这些知识对于框架的构建等是很有好处的，本文大部分是翻译加上自己的理解。&lt;/p&gt;
&lt;h2 id=&quot;事件模型&quot;&gt;&lt;a href=&quot;#事件模型&quot; class=&quot;headerlink&quot; title=&quot;事件模型&quot;&gt;&lt;/a&gt;事件模型&lt;
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="Dom" scheme="http://yoursite.com/tags/Dom/"/>
    
      <category term="CurrentTarget" scheme="http://yoursite.com/tags/CurrentTarget/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs ES6</title>
    <link href="http://yoursite.com/2017/10/21/Nodejs-ES6/"/>
    <id>http://yoursite.com/2017/10/21/Nodejs-ES6/</id>
    <published>2017-10-21T09:08:48.000Z</published>
    <updated>2017-10-21T09:35:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在写前端大多数情况下会应用蛮多<code>ES6</code>的语法，当你在写<code>Node</code>的时候，当然也会希望使用<code>ES6</code>的特性了，不然会搞得你有些沮丧，淘宝有一篇专门写了<a href="http://taobaofed.org/blog/2016/01/07/find-back-the-lost-es6-features-in-nodejs/" target="_blank" rel="external">这个</a>。不过有些时间了，不是很赞同那样做。</p><p>根据自己的理解，查了下<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="external">Babel官网的介绍</a>, 可以作如下的配置:</p><p>不同的<code>Node</code>版本兼容的<code>ES6</code>可以查看<a href="http://node.green" target="_blank" rel="external">这里</a>。</p><h2 id="安装babel-preset及babel工具"><a href="#安装babel-preset及babel工具" class="headerlink" title="安装babel-preset及babel工具"></a>安装babel-preset及babel工具</h2><blockquote><p>根据官网的介绍，利用这个你可以指定不同的环境而不用去手动配置<code>plugins</code>, 旧的只支持当年批准的那个议案。</p></blockquote><p>安装自己所需要的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 安装 core 和命令行工具</div><div class="line">npm install --save-dev babel-core babel-cli</div><div class="line"># 安装 babel环境支持</div><div class="line">npm install babel-preset-env --save-dev</div><div class="line"># 安装 nodemon可以在你修改的时候自动重新加载node推荐安装哦</div><div class="line">npm i -g nodemon</div></pre></td></tr></table></figure><h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置.babelrc</h2><p>创建<em>.babelrc</em>,当只写<code>[&quot;env&quot;]</code>的时候表示是兼容最新亦即包括(babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017三个一起)。</p><p>因为这边是针对的<code>Node</code>，这里有一个配置蛮好:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [&quot;env&quot;, &#123;</div><div class="line">      &quot;targets&quot;: &#123;</div><div class="line">        &quot;node&quot;: &quot;current&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样配置以后，babel会根据你的<code>Node</code>的不同版本，自动添加不同的兼容插件，而不用你手动去加载。</p><h2 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;main&quot;: &quot;dist/server.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</div><div class="line">    &quot;dev&quot;: &quot;nodemon --exec babel-node src/server.js&quot;,</div><div class="line">    &quot;build&quot;: &quot;babel src --out-dir dist&quot;,</div><div class="line">    &quot;release&quot;: &quot;npm run build &amp;&amp; NODE_ENV=production nodemon dist/server.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>然后最后如果plugins和presets一起也是可以的，就是需要注意这两个配置起来必须最后可以在任意一处可以输出对应的兼容的代码，否则打包出来的代码是不兼容的代码。比如没配置好那个<code>import</code>的支持就尴尬了</strong></p><p>最后，大功告成，就可以愉快地在<code>Node</code>下写<code>ES6</code>了。以上如有不对的地方还望指教，谢谢-^.^-。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在写前端大多数情况下会应用蛮多&lt;code&gt;ES6&lt;/code&gt;的语法，当你在写&lt;code&gt;Node&lt;/code&gt;的时候，当然也会希望使用&lt;code&gt;ES6&lt;/code&gt;的特性了，不然会搞得你有些沮丧，淘宝有一篇专门写了&lt;a href=&quot;http://taobaofed.o
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ES6碎碎念经</title>
    <link href="http://yoursite.com/2017/10/13/ES6%E7%A2%8E%E7%A2%8E%E5%BF%B5%E7%BB%8F/"/>
    <id>http://yoursite.com/2017/10/13/ES6碎碎念经/</id>
    <published>2017-10-13T14:31:46.000Z</published>
    <updated>2017-10-14T07:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<em>ES6</em>好些时间了, 下面是自己的一些使用心得:</p><h2 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h2><p>隐蔽死区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function bar(x = y, y = 2) &#123;</div><div class="line">  return [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line">bar() // 报错</div></pre></td></tr></table></figure><p><code>x</code>默认值等于另一个参数<code>y</code>， <code>y</code>还没声明，属于死区.</p><p>ES6支付宝临时性死区和<code>let</code>, <code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量。</p><p>不能在函数内部重新声明参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func(arg) &#123;</div><div class="line">let args; // 报错</div><div class="line">&#125;</div><div class="line"></div><div class="line">function func(arg) &#123;</div><div class="line">&#123;</div><div class="line">let arg; // 不报错</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function f1() &#123;</div><div class="line">let n = 5;</div><div class="line">if (true) &#123;</div><div class="line">let n = 10;</div><div class="line">&#125;</div><div class="line">console.log(n); // 5</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上代码表示外层代码块不受内层代码块的影响。<br>ES6 允许块级作用域任意嵌套。<br>块级作用域的出现，使得广泛使用的立即执行函数表达式（IIFE）不再必要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">var tmp = ...;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 块级作用域</div><div class="line">&#123;</div><div class="line">  let tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>为了兼容老代码函数声明。浏览器实现可以不遵守块级作用域内声明的函数类似于<code>let</code>的规定。</p><ul><li>允许在块级作用域内声明函数</li><li>函数声明类似于<code>var</code>,即会提升到全局作用域或函数作用域的头部</li><li>同时，函数声明还会提升到所在块级作用域的头部</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 浏览器的 ES6 环境</div><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line">  if (false) &#123;</div><div class="line">    // 重复声明一次函数f</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div><div class="line">// Uncaught TypeError: f is not a function</div></pre></td></tr></table></figure><p>实际运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 浏览器的 ES6 环境</div><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  var f = undefined;</div><div class="line">  if (false) &#123;</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div><div class="line">// Uncaught TypeError: f is not a function</div></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应避免在块级作用域内声明函数。如果确实需要，也应写成函数表达式，而不是函数声明语句。</p><p><code>const</code>只声明不赋值也会报错。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存不得改动。对于简单类型的数据(数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据(对象和数组),变量指向的内存地址，保存的只是一个指针。<code>const</code>仅保证这个指针固定，上面的值却不能够保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line"></div><div class="line">// 赋值</div><div class="line">foo.a = 123;</div><div class="line">foo.a // 123</div><div class="line"></div><div class="line">// 将foo指向另一个对象，报错</div><div class="line">foo = &#123;&#125;; // Uncaught TypeError: Assignment to constant variable</div></pre></td></tr></table></figure><p>想将对象冻结使用<code>Object.freeze</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;&#125;);</div><div class="line"></div><div class="line">// 常规模式时，下面一行不起作用；</div><div class="line">// 严格模式时，该行会报错</div><div class="line">foo.prop = 123;</div></pre></td></tr></table></figure><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p><code>var</code>命令和<code>function</code>命令声明的全局变量,依旧是顶层对象的属性,另一方面,<code>let</code>,<code>const</code>,<code>class</code>命令声明的全局变量不属于顶层对象的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">// 如果在Node的REPL环境，可以写成global.a</div><div class="line">// 或者采用通用方法，写成this.a</div><div class="line">window.a // 1</div><div class="line"></div><div class="line">let b = 1;</div><div class="line">window.b // undefined</div></pre></td></tr></table></figure><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>ES5的顶层对象，在不同环境里面不一样.</p><ul><li>浏览器是<code>window</code>, 但Node和Web Worker没有<code>window</code></li><li>浏览器和Web Worker里面，<code>self</code>也指向顶层对象,但是Node没有<code>self</code></li><li>Node里面，顶层对象是<code>global</code>,但其它环境都不支持</li></ul><p>同一段代码为了能在各种环境中都取到顶层对象，一般使用<code>this</code>变量。</p><ul><li>全局环境中，<code>this</code>会返回顶层对象, 但Node模块和ES6模块，<code>this</code>返回当前模块</li><li>函数里面的<code>this</code>, 如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这是<code>this</code>会返回<code>undefined</code>。</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li></ul><p>两种方法可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">(typeof window !== &apos;undefined&apos;</div><div class="line">   ? window</div><div class="line">   : (typeof process === &apos;object&apos; &amp;&amp;</div><div class="line">      typeof require === &apos;function&apos; &amp;&amp;</div><div class="line">      typeof global === &apos;object&apos;)</div><div class="line">     ? global</div><div class="line">     : this);</div><div class="line"></div><div class="line">// 方法二</div><div class="line">var getGlobal = function () &#123;</div><div class="line">  if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125;</div><div class="line">  if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125;</div><div class="line">  if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125;</div><div class="line">  throw new Error(&apos;unable to locate global object&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>有一个提案引入<code>global</code>作为顶层对象，这样所有环境下<code>global</code>都存在。<br><a href="https://github.com/ljharb/System.global" target="_blank" rel="external">system.global</a>模拟了这个提案可以在所有环境中拿到<code>global</code>.</p><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>Object.assign(target, source1, source2)只会将源对象的枚举的属性拷贝到目标对象上。只拷贝源对象自身属性，不拷贝不可枚举属性。</p><p>Symbol属性也会被Object.assign拷贝。</p><p>尽量使用<code>Object.keys()</code>来循环对象自身的属性。</p><p><code>Object.getPrototypeOf()</code>获取对象的原型对象。<br><code>Object.setPrototypeOf()</code>设置对象的原型对象。</p><p>…用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let z = &#123; a: 3, b: 4 &#125;;</div><div class="line">let n = &#123; ...z &#125;;</div><div class="line">n // &#123; a: 3, b: 4 &#125;</div></pre></td></tr></table></figure><h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function add() &#123;&#125;</div></pre></td></tr></table></figure><p>以上函数的长度是多少，一般情况下<code>add.length</code>为函数的参数个数但是如果函数的参数是<code>rest</code>呢？<br><code>rest</code>参数是不计入函数的<code>length</code>属性里面的。并且<strong>rest</strong>参数之后不能再有其它参数，但之前可以有其它参数。<br>你可以在<a href="https://babeljs.io/repl/" target="_blank" rel="external">Babel转换器官网</a>上进行编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(a) &#123;&#125;).length  // 1</div><div class="line">(function(...a) &#123;&#125;).length  // 0</div><div class="line">(function(a, ...b) &#123;&#125;).length  // 1</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;em&gt;ES6&lt;/em&gt;好些时间了, 下面是自己的一些使用心得:&lt;/p&gt;
&lt;h2 id=&quot;let与const&quot;&gt;&lt;a href=&quot;#let与const&quot; class=&quot;headerlink&quot; title=&quot;let与const&quot;&gt;&lt;/a&gt;let与const&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>生活的意义</title>
    <link href="http://yoursite.com/2017/10/12/%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://yoursite.com/2017/10/12/生活的意义/</id>
    <published>2017-10-12T15:33:13.000Z</published>
    <updated>2017-10-13T04:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来思绪繁多，有时夜不能寐，想起许多事情，自己的家族，爷爷，爷爷的工厂。</p><p>今天，大了我好多岁的大堂哥微信来和我聊天，平日里，作为生意人的他，蛮忙碌的，也是不易。然后，聊了我最近家里的事，我想他和我一样，关于爷爷冤死，还有家族的厂子。大抵家族遭遇了不幸，我很庆幸，我和他想的一样，我们都不愿意就这样苟且过活，至少我们心底里都非常想要<strong>光宗耀祖</strong>。而他基本上是已经实现了，当了小学的董事会的主席，还有什么一大堆的名头。犹记得他说过的话</p><blockquote><p>历尽沧桑欲何求，只为一生不低头</p></blockquote><p>作为家中长子的他始终记得耻辱，虽然当初生活压力很大，但仍旧是凭借自己的三寸不烂之舌，去争取，去做生意。哪怕遇到再大的困难都挺了过去。所以，每次我看见他的时候，我很难看到他的焦虑，从来都是从容不迫的西样子。</p><p>年轻的时候，我仅仅模糊地记得，父亲要替他出头，他可能和人发生了纠纷。</p><p>时间，会证明一切，也只有努力的人才应该得到回报。然后一直到现在，他都是我的榜样。</p><p>微信里面他说他理解我的问题，作为家中长子的责任感，我表示赞同，也非常感激他的建议。</p><p>有时候，会从半夜惊醒，因为家，因为责任。生活的意义是什么？家中尚有父母，当赡养之，若有妻儿当供养之，尽自己的责任。</p><p>大概你会问：<em>你的生活意义是什么？就是一直为别人活着吗？</em>, 告诉我:当你尽自己的责任之后是什么感觉？就像当你做了一件好事之后，你心里的感受是什么？作为社会个体的自我，就像蝙蝠侠里面的台词说的：力量越大，责任越大。难道不是这样的吗？</p><p>生活不止玩乐，现世下，太多的信息，太多的思想洪流，成天看微博，微信信息，但愿，自己不要为这些所淹没，求得内心一片清净地。<strong>努力实现自己的价值，尽到自己的职责，游山玩水，大概这就是我所认为的生活的意义吧。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近来思绪繁多，有时夜不能寐，想起许多事情，自己的家族，爷爷，爷爷的工厂。&lt;/p&gt;
&lt;p&gt;今天，大了我好多岁的大堂哥微信来和我聊天，平日里，作为生意人的他，蛮忙碌的，也是不易。然后，聊了我最近家里的事，我想他和我一样，关于爷爷冤死，还有家族的厂子。大抵家族遭遇了不幸，我很庆幸
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Essays" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/Essays/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="人生感悟" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>window.pageYOffset, window.pageXOffset, clientWidth, clientHeight, etc,一些JavaScript的基础属性及实战应用</title>
    <link href="http://yoursite.com/2017/10/08/window-pageYOffset-window-pageXOffset-clientWidth-clientHeight-etc-%E4%B8%80%E4%BA%9BJavaScript%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/10/08/window-pageYOffset-window-pageXOffset-clientWidth-clientHeight-etc-一些JavaScript的基础属性/</id>
    <published>2017-10-08T13:47:09.000Z</published>
    <updated>2017-11-04T15:39:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你在编写某些插件的时候，你对于JavaScript的基础知识的掌握情况将会极大地影响到你写的东西。下面介绍这些基础属性及实战如下：</p><h2 id="window-pageYOffset-window-pageXOffset"><a href="#window-pageYOffset-window-pageXOffset" class="headerlink" title="window.pageYOffset, window.pageXOffset"></a>window.pageYOffset, window.pageXOffset</h2><p>  获得文档在垂直方向或者水平方向的滚动距离。现如今<em>Vue</em>,<em>React</em>大行其道的今天好多兼容性都没在考虑的范围，不过这里还是要提下。这两个属性在IE&lt;9的浏览器是不支持的。所以完整的兼容代码是：</p><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let supportPageOffset = window.pageXOffset !== undefined</div><div class="line">let isCSS1Compat = ((document.compatMode || &quot;&quot;) === &quot;CSS1Compat&quot;)</div><div class="line"></div><div class="line">let x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;</div><div class="line">let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;</div></pre></td></tr></table></figure>然后在高版本的浏览器中可以用window.scrollX和window.scrollY来分别代替window.pageXOffset和window.pageYOffset。但是**IE浏览器不支持**。</code></pre><p>  <code>document.compatMode</code>表示用户是否在怪异模式吧或者标准模式下。怪异模式下则显示<code>BackCompat</code>,非怪异模式则返回<code>CSS1Compat</code>。<br>  之前在IE的时候调试兼容性的时候面板里面就会有怪异模式,当用户没有设定那个<code>&lt;!DOCTYPE html&gt;</code>头的时候就会<br>  在怪异模式下,返回值是<code>BackCompat</code>。</p><p>  摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/scrollY" target="_blank" rel="external">Mozilla中关于window.pageYOffset的表述</a></p><h2 id="clientWidth-clientHeight"><a href="#clientWidth-clientHeight" class="headerlink" title="clientWidth, clientHeight"></a>clientWidth, clientHeight</h2><p> <img src="/images/dimensions-client.png" alt=""><br> 获取元素的内宽度包括内边距(padding)离但不包括垂直滚动条,边框或者外边距(margin)。<strong>这里的元素必须是非内联的元素</strong>，除非设置内联元素默认显示属性即可设置其样式<code>display: inline-block</code>或者其它。<code>clientHeight</code>和<code>clientWidth</code>类似。</p><h2 id="window-innerWidth-window-innerHeight，window-outerWidth-window-outerHeight"><a href="#window-innerWidth-window-innerHeight，window-outerWidth-window-outerHeight" class="headerlink" title="window.innerWidth,window.innerHeight，window.outerWidth, window.outerHeight"></a>window.innerWidth,window.innerHeight，window.outerWidth, window.outerHeight</h2><p><img src="/images/innerheightvsouterheight.png" alt=""></p><p><code>window.innerWidth</code>指的是窗口视窗的宽度包括垂直滚动条的宽度。<code>window.innerHeight</code>窗口视窗的高度包括水平滚动条的高度。<code>window.outerHeight</code>指的是包括整个浏览器的容器的高度。<code>window.outerHeight</code>类似。</p><p><strong>以上这几个属性在IE9以下都不支持</strong>。</p><h2 id="offsetWidth-offsetHeight-offsetLeft-offsetTop-offsetParent"><a href="#offsetWidth-offsetHeight-offsetLeft-offsetTop-offsetParent" class="headerlink" title="offsetWidth, offsetHeight, offsetLeft, offsetTop, offsetParent"></a>offsetWidth, offsetHeight, offsetLeft, offsetTop, offsetParent</h2><p><img src="/images/dimensions-offset.png" alt=""></p><p><code>offsetWidth</code>元素的宽度包括元素的边框，元素水平内边距和垂直滚动条的宽度。<code>offsetHeight</code>与之类似，<br>这里获得的数值是四舍五入到整数，如果想要获取精益的数值可以用<code>element.getBoundingClientRect()</code>来获取。</p><p><code>offsetLeft</code>是获取元素相对于最近的定位的元素的左边距离,<code>offsetTop</code>类似。</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Wudiemperor/zpmb5c8b/1/embedded/js,html,css,result/light" frameborder="0" allowfullscreen></iframe><p>但是这里有个问题当是内联元素的时候这个显示会有些奇怪，因为那个内联元素是用的<code>Element.getClientRects</code>来获得宽度和高度从而导致这些内联元素不是个规则的有边框的盒模型。上面的示例就可以看到。</p><p><code>offsetParent</code>是获取元素最近定位的父元素。</p><p><strong>这里需要注意的是<code>getBoundingClientRect</code>获取top与<code>offsetTop</code>的区别</strong></p><p>看下示例就明白了:</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Wudiemperor/bzewb0za/embedded/js,html,css,result/light" frameborder="0" allowfullscreen></iframe><p>这里的<code>getBoundingClientRect</code>是以视图上的位置为基准的即相对于<strong>viewport</strong>的上，右，下，左的距离，而<code>offsetTop</code>是以最近的<strong>定位的元素</strong>，这里的定位元素,如果目标元素是<code>fixed</code>或者目标元素的最近的父元素是<code>static</code>定位的话的话两者是相等的,否则一般是不相等(排队了元素未在视图顶部的情况)。一个是相对于视图，一个是相对于最近的有定位的父元素。</p><h2 id="clientLeft-clientTop-window-screenX-window-screenY"><a href="#clientLeft-clientTop-window-screenX-window-screenY" class="headerlink" title="clientLeft, clientTop, window.screenX, window.screenY"></a>clientLeft, clientTop, window.screenX, window.screenY</h2><p><code>clientLeft</code>一个元素左边边框的宽度包含垂直滚动条的宽度但并不包含左外边距和左内边距。<code>clientTop</code>类似。</p><p><code>window.screenX</code> 用户的浏览器左边框和用户的屏幕左边之间的距离</p><p><code>window.screenY</code> 用户的浏览器上边框和用户的屏幕顶端之间的距离</p><h2 id="scrollTop-scrollLeft-scrollWidth-scrollHeight"><a href="#scrollTop-scrollLeft-scrollWidth-scrollHeight" class="headerlink" title="scrollTop, scrollLeft, scrollWidth, scrollHeight"></a>scrollTop, scrollLeft, scrollWidth, scrollHeight</h2><p><img src="/images/scrollTop.png" alt=""></p><p><code>scrollTop</code>获取或者设置一个元素垂直方向滚动的距离，表示的意思是元素方框的顶部和元素的最顶部的可见内容之间的距离。当一个元素内容没有产生垂直滚动条，那么这个值为0。</p><p>需要注意的有以下三点：</p><ul><li>当一个元素不可以滚动值为0</li><li>不接受负值相反会会设置回0</li><li>如果设置的最大滚动距离大于元素最大可滚动距离则只会应用元素最大可滚动距离</li></ul><p><code>scrollLeft</code>类似。</p><h2 id="event-clientX-event-clientY"><a href="#event-clientX-event-clientY" class="headerlink" title="event.clientX, event.clientY"></a>event.clientX, event.clientY</h2><p><code>event.clientX</code>触摸事件中的触摸点相对于视图的左位移不包括滚动的位移。<code>event.clientY</code>类似。<br>这两个可以应用在下拉刷新的插件(当是touch事件的时候), 拖拽的插件(当是鼠标事件的时候）。</p><p>大部分的属性都可以在<a href="https://www.quirksmode.org/mobile/tableViewport_desktop.html" target="_blank" rel="external">这里</a>找到。</p><p>接下来假设要写一个那种类似<a href="https://getbootstrap.com/docs/3.3/javascript/#scrollspy" target="_blank" rel="external">scrollspy</a>的插件需要用到的属性有：</p><p>那么这里需要应用到元素的一个属性<code>getBoundingClientRect</code>可以查看<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">这里</a>的详细介绍,大意是这个是返回元素在视图，相对于视图左上角的位移。事实上不管滚动的容器是否是<code>body</code>最终都可以归纳到这个属性上面。<br>大概意思即：当前一个元素完全离开<code>viewport</code>视口的时候，会给激活下一个导航。滚动的距离要大于元素在当前滚动容器的位移。不知道有没有表述清楚呃!-.-。</p><p>这里有一个小snippet用来获取元素的滚动的距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getScrollDis () &#123;</div><div class="line">  let supportPageOffset = window.pageXOffset !== undefined</div><div class="line">  let isCSS1Compat = ((document.compatMode || &quot;&quot;) === &quot;CSS1Compat&quot;)</div><div class="line"></div><div class="line">  let x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;</div><div class="line">  let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    top: y,</div><div class="line">    left: x</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="当滚动的容器是body的时候"><a href="#当滚动的容器是body的时候" class="headerlink" title="当滚动的容器是body的时候"></a>当滚动的容器是<strong>body</strong>的时候</h3><p>当滚动的容器是<code>body</code>的时候直接获取滚动的距离，和元素本页面的位移和滚动的距离作对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let rect = elem.getBoundingClientRect()</div><div class="line">let scrollTop = getScrollDis().top</div><div class="line">let offset = &#123;&#125;</div><div class="line">offset.top = rect.top + win.pageYOffset - docElem.clientTop</div></pre></td></tr></table></figure><h3 id="当滚动的容器不是body的时候"><a href="#当滚动的容器不是body的时候" class="headerlink" title="当滚动的容器不是body的时候"></a>当滚动的容器<strong>不是body</strong>的时候</h3><p>与上面的是类似的只是这里需要计算的是元素相对的滚动容器不一样，可以参考下jQuery的<code>elem.postion()</code>来取得元素的位置。</p><h2 id="总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和Bootstrap类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。"><a href="#总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和Bootstrap类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。" class="headerlink" title="总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和Bootstrap类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。"></a>总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和<strong>Bootstrap</strong>类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。</h2><p><strong>以上的图片均来自于<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/</a></strong></p><p>TodoList:</p><ul><li style="list-style: none"><input type="checkbox"> <code>getBoundingClientRect</code>与<code>getClientRects</code>的区别</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你在编写某些插件的时候，你对于JavaScript的基础知识的掌握情况将会极大地影响到你写的东西。下面介绍这些基础属性及实战如下：&lt;/p&gt;
&lt;h2 id=&quot;window-pageYOffset-window-pageXOffset&quot;&gt;&lt;a href=&quot;#window-pa
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="scrollSpy" scheme="http://yoursite.com/tags/scrollSpy/"/>
    
      <category term="pageYOffset" scheme="http://yoursite.com/tags/pageYOffset/"/>
    
  </entry>
  
  <entry>
    <title>去远方</title>
    <link href="http://yoursite.com/2017/10/02/%E5%8E%BB%E8%BF%9C%E6%96%B9/"/>
    <id>http://yoursite.com/2017/10/02/去远方/</id>
    <published>2017-10-01T16:41:37.000Z</published>
    <updated>2017-10-01T16:41:37.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nodejs插件express-session详解</title>
    <link href="http://yoursite.com/2017/09/13/Nodejs%E6%8F%92%E4%BB%B6express-session%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/09/13/Nodejs插件express-session详解/</id>
    <published>2017-09-13T14:54:40.000Z</published>
    <updated>2017-09-17T08:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用<code>express-session</code>是在nodejs服务器中常用的会话插件。下面简单介绍其基本用法，及一些参数的说明.</p><p>简单介绍一下会话服务，如何识别来访用户是一件重要的事情。那么具体的实现方法有以下三种:</p><ul><li>cookie,把sessionid存储在一个叫set-cookie的响应头中，由服务端传给客户端。</li><li>url重写技术,url上面有类似sessid之类的名称比如网易邮箱就可以在url上面看到类似的字样</li><li>表单隐藏域技术 服务器在表单中写入那个sessionid</li></ul><p>这是只介绍第一种即会话cookie,会话跟踪的实现依赖于<code>cookie</code>。</p><ul><li><p><em>saveUninitialized</em> 默认值为<code>true</code>。</p><blockquote><p>官方文档上说所谓的未初始化会话即会话对象不曾被修改过即为<code>uninitialized session</code>.</p></blockquote><p>怎么理解呢？我查了相关的资料查到<a href="https://stackoverflow.com/questions/40381401/when-use-saveuninitialized-and-resave-in-express-session" target="_blank" rel="external">stackoverflow上关于这个参数</a>的解释，再看官方文档进行了相关的试验。</p><h3 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下:"></a>总结如下:</h3><p>如果设置saveUninitialized为false那么在请求期间这个session对象没有修改过，即没有进行诸如<code>req.session.变量 = 3</code>这样的赋值则不会保存到session所在的存储的媒介中如：内存，数据库。这样就可以节约大量的资源。</p><p>但是如果你想要识别用户就得启用它。如果为false的话，会话cookie即<code>set-cookie</code>不会被发送到浏览器中除非session对象有修改。<strong>所以一般为true</strong>.</p><p>假设是不以cookie为凭据则可以为false。那么这里如果不以<code>cookie</code>来验证用户的话比如采取<code>token based</code>来进行验证就可以考虑设置<code>saveUninitialized: false</code>。</p><p>这里还需要注意的是<strong>只要<code>session</code>这个对象没有被修改过且<code>saveUninitialized</code>为false则不会返回<code>set-cookie</code>的响应头于是浏览器中</strong>。</p></li></ul><ul><li><p><em>resave</em> 默认值是为<code>true</code>。</p><blockquote><p>官方文档说明强迫会话存储回会话存储容器中，即使在请求过程中会话对象没有被修改过。主要是要查看自己的存储容器是否实现了<code>touch</code>方法。如果有则可以设置<code>resave: false</code>。但是，如果存储容器没有实现并且设置了会话过期时间就必须设置<code>resave: true</code>。</p></blockquote></li><li><p><em>rolling</em> 默认值是<code>false</code>。强制会话过期时间在每个请求进行重置，过期时间会重置到最初的过期时间<strong>maxAge</strong>。当这个选项为<code>true</code>而<code>saveUninitialized: false</code>则会话cookie不会返回到浏览器中。其实这和前面介绍的说的是一个意思<code>saveUninitialized</code>是一个意思。<br><strong>不过这里令人费解的是我测试了不管怎么设置这个过期时间都会重置,大写的尴尬。!-.-.</strong>我一直以为这个如果设置<code>rolling:false</code>的话会这个打印出来的<code>req.session.cookie.maxAge</code>在刷新页面的时候不会重置那个时间即重置回初始化设定的过期时间比如<em>60s</em>,结果是这个值当你刷新页面的时候是会重置的,后面看了源码感觉是自己理解有误了。我设置了一个诸如<code>req.session.isLogged</code>的值然后再去测试当<code>rolling</code>的值为<code>true</code>或<code>false</code>的时候的值，符合预期，结果证实自己的理解有误!!-.-。</p></li><li><p><em>cookie.httpOnly</em> 是否允许客户端访问<code>cookie</code>,默认值为<code>true</code>。</p></li><li><p><em>store持久化session存储的容器</em> 这里默认是<code>MemoryStore</code>实例，如果是想要持久化存储<code>session</code>即在服务器宕机后再识别出该用户的话你需要引入一个存储容器比如<a href="https://www.npmjs.com/package/connect-redis" target="_blank" rel="external">connect-redis</a>或者<a href="https://github.com/mongodb-js/connect-mongodb-session" target="_blank" rel="external">connect-mongodb-session</a>。</p></li><li><p>cookie.secure 如果设置为<code>true</code>全站必须是<strong>https</strong>,如果<code>nodejs</code>是用<code>nginx</code>代理的，则在<code>express</code>中必须设置<code>trust proxy</code>如<code>app.set(&#39;trust proxy&#39;, 1)</code>。</p></li></ul><p>一般情况如下就够用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app.use(session(&#123;</div><div class="line">  name: &apos;sessid&apos;, // session标识符的名字</div><div class="line">  secret: &apos;abcde&apos;, // sessionID的签名密钥</div><div class="line">  resave: true,</div><div class="line">  saveUninitialized: true,</div><div class="line">  rolling: true,</div><div class="line">  cookie: &#123;</div><div class="line">    maxAge: 60000</div><div class="line">  &#125;,</div><div class="line">  store: new RedisStore(&#123;</div><div class="line">    host: &apos;127.0.0.1&apos;,</div><div class="line">    port: redis端口,</div><div class="line">    pass: &apos;redis密码&apos;</div><div class="line">  &#125;)</div><div class="line">&#125;))</div></pre></td></tr></table></figure><p>可根据具体情况再做灵活调整。</p><p>TodoList:</p><ul><li style="list-style: none"><input type="checkbox"> <code>resave</code>参数中如何知道自己的存储容器是否实现了<code>touch</code>方法呢？</li><li style="list-style: none"><input type="checkbox"> <code>rolling</code>为什么默认值要设置为<code>false</code>, <code>true</code>不会好点吗？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用&lt;code&gt;express-session&lt;/code&gt;是在nodejs服务器中常用的会话插件。下面简单介绍其基本用法，及一些参数的说明.&lt;/p&gt;
&lt;p&gt;简单介绍一下会话服务，如何识别来访用户是一件重要的事情。那么具体的实现方法有以下三种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="backend" scheme="http://yoursite.com/categories/backend/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap affix 源码解读</title>
    <link href="http://yoursite.com/2017/08/20/Bootstrap-affix-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/20/Bootstrap-affix-源码解读/</id>
    <published>2017-08-20T09:48:07.000Z</published>
    <updated>2017-08-27T04:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多情况下我们都需要去处理那种导航在页面滑动了一定的距离然后固定导航的需求，然后有可能会要求在滚动到距询问多少距离的时候又不固定导航。Bootstrap affix就是为此设计的。</p><p>功能需求：</p><ul><li>当页面滚动到一定距离即固定住元素</li><li>当页面滚动到距离底部一定距离的时候不再固定元素而是绝对定位元素</li></ul><p>思路分三个阶段：</p><ul><li>当用户没有滚动到阀值的时候是一个类affix-top</li><li>当用户滚动到阀值的时候类改为affix，然后样式化这个类比如写position:fixed</li><li>当用户到达底部阀值的时候元素类改为affix-bottom,然后样式化这个类比如position:absolute</li></ul><p><strong> 当发现固定部分在滚动有抖动现象需要给<code>body</code>设置</strong>position:relative**。</p><blockquote><p>名词解释:</p><p>视窗高度：所看到的高度不包括可滚动的距离<br>内容高度：所看到的高度加上可滚动的距离</p></blockquote><p>首先知道CSS定位<code>position</code>属性:</p><blockquote><h2 id="引用自MDN-css-position"><a href="#引用自MDN-css-position" class="headerlink" title="引用自MDN css position"></a>引用自<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="external">MDN css position</a></h2><p>所谓的<code>positioned element</code>即定位为<strong>relative</strong>,<strong>absolute</strong>,<strong>fixed</strong>或者<strong>sticky</strong>。</p><ul><li>fixed: 元素相对于<strong>视窗</strong>的定位。不随滚动条滚动。</li><li>absolue: 元素相对于<strong>最近有定位父级元素</strong>的定位，如果元素有外边距则会增加进<code>offset</code>位移属性里面,会随滚动条滚动。</li><li>relative: 相对于元素本身本来的位置的定位。</li></ul></blockquote><p>然后需要知道的是关于<code>jQuery</code>的<code>offset</code>函数，<code>$(elem).offset()</code>获得元素在文档中的位移值默认输出<code>{top: top值, left: left值}</code>。<br>元素的position属性所导致的值的不同:</p><ul><li>当元素为<code>relative</code>或者不设置的时候, 当页面滚动的时候, <code>$(elem).offset()</code>值保持不变。</li><li>当元素为<code>absolute</code>的时候, 当页面滚动的时候, <code>$(elem).offset()</code>值保持不变,因为他是随着最近的有定位的父级元素滚动的。</li><li>当元素为<code>fixed</code>的时候，当页面滚动的时候, <code>$(elem).offset()</code>值为元素的<code>top</code>值加上滚动容器滚动的距离。</li></ul><p>Bootstrap affix源码解读如下:</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var Affix = function (element, options) &#123;</div><div class="line">  this.options = $.extend(&#123;&#125;, Affix.DEFAULTS, options)</div><div class="line"></div><div class="line">  this.$target = $(this.options.target)</div><div class="line">    .on(&apos;scroll.bs.affix.data-api&apos;, $.proxy(this.checkPosition, this))</div><div class="line">    .on(&apos;click.bs.affix.data-api&apos;$.proxy(this.checkPositionWithEventLoop,this))</div><div class="line"></div><div class="line">  this.$element     = $(element)</div><div class="line">  this.affixed      = null</div><div class="line">  this.unpin        = null</div><div class="line">  this.pinnedOffset = null</div><div class="line"></div><div class="line">  this.checkPosition()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先是获得滚动容器<code>this.$target</code>,还有作用的元素<code>this.$element</code>,<code>this.affixed</code>为目标元素的定位的状态值为<strong>top, bottom, false, null</strong>,<code>this.unpin</code>指的是当滚动到底部阀值的时候的位移值为<strong>null或者元素的位移值减去滚动容器（默认为window）滚动的距离</strong>。<code>this.pinnedOffset</code>同<code>this.unpin</code>。<br>事件代理目标滚动容器（<em>默认为window</em>）的滚动事件和点击事件。</p><h3 id="检查元素状态"><a href="#检查元素状态" class="headerlink" title="检查元素状态"></a>检查元素状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) &#123;</div><div class="line">  var scrollTop    = this.$target.scrollTop()</div><div class="line">  var position     = this.$element.offset()</div><div class="line">  var targetHeight = this.$target.height()</div><div class="line"></div><div class="line">  if (offsetTop != null &amp;&amp; this.affixed == &apos;top&apos;) return scrollTop &lt; offsetTop ? &apos;top&apos; : false</div><div class="line"></div><div class="line">  if (this.affixed == &apos;bottom&apos;) &#123;</div><div class="line">    if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : &apos;bottom&apos;</div><div class="line">    return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : &apos;bottom&apos;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var initializing   = this.affixed == null</div><div class="line">  var colliderTop    = initializing ? scrollTop : position.top</div><div class="line">  var colliderHeight = initializing ? targetHeight : height</div><div class="line"></div><div class="line">  if (offsetTop != null &amp;&amp; scrollTop &lt;= offsetTop) return &apos;top&apos;</div><div class="line">  if (offsetBottom != null &amp;&amp; (colliderTop + colliderHeight &gt;= scrollHeight - offsetBottom)) return &apos;bottom&apos;</div><div class="line"></div><div class="line">  return false</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当<code>offsetTop&#39;有值并且固定的状态为</code>top<code>则判断</code>scrollTop &lt; offsetTop<code>滚动距离是否小于顶部阀值，是则返回</code>top<code>否则返回</code>false`。</p><p>如果固定状态为<code>bottom</code>并且<code>offsetTop</code>有值则判断<code>scrollTop</code>滚动的距离加上相对位移值<code>this.unpin</code>和元素的绝对位移值<code>position.top</code>,若小于或等于则返回<code>false</code>否则返回<code>bottom</code>。</p><p>若<code>offsetTop</code>为空则计算滚动距离加上滚动窗口的视窗高度和容器的总高度<code>scrollHeight</code>(即包括可滚动距离和视窗的高度)的值减去<code>offsetBottom</code>底部阀值作对比若小则返回<code>false</code>否则返回<code>bottom</code>。</p><p>接下来判断是否是初始化，设置<code>colliderTop</code>和<code>colliderHeight</code>,当是第一次渲染的时候，分别为滚动的距离和目标滚动容器的视窗高度,否则分别为目标元素的绝对位移和目标元素的高度值。</p><p>如果传进来的顶部绝对位移值不为空并且滚动距离小于传进来的顶部阀值则返回<code>top</code>。</p><p>如果传进来的底部阀值不为空并且<code>colliderTop</code>和<code>colliderHeight</code>的和大于或等于目标容器的总高度减去传进来的底部阀值则返回<code>bottom</code>。<br>即当元素一直滚动到大于滚动的阀值的时候返回<code>bottom</code>, 默认返回<code>false</code>即处于<code>affix</code>状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (this.affixed == &apos;bottom&apos;) &#123;</div><div class="line">  if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : &apos;bottom&apos;</div><div class="line">  return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : &apos;bottom&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>当为<code>affix-bottom</code>状态</em>这个是难点</p><p>当为bottom的时候posiiton.top为scrollHeight - height - offsetBottom,this.unpin是<code>position.top - scrollTop</code>，当<code>offsetTop</code>不为空则判断是向下滚动还是向上滚动若向上滚动则有可能会进入<code>affix</code>状态，若向下滚动则是<code>affix-bottom</code>状态。</p><p>当<code>offsetTop</code>设置为空的时候，比较目标窗口滚动的距离+目标窗口的视窗高度和目标容器的内容高度(包括滚动距离)减去底部阀值若小于则是在<code>affix</code>状态否则进入底部状态并设置类<code>affix-bottom</code>。</p><h3 id="获得锁定状态的位移值"><a href="#获得锁定状态的位移值" class="headerlink" title="获得锁定状态的位移值"></a>获得锁定状态的位移值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.getPinnedOffset = function () &#123;</div><div class="line">  if (this.pinnedOffset) return this.pinnedOffset</div><div class="line">  this.$element.removeClass(Affix.RESET).addClass(&apos;affix&apos;)</div><div class="line">  var scrollTop = this.$target.scrollTop()</div><div class="line">  var position  = this.$element.offset()</div><div class="line">  return (this.pinnedOffset = position.top - scrollTop)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>获取锁定状态的值，当即将进入<code>offsetBottom</code>阀值的时候触发。这个会获取在<code>affix</code>状态进入<code>affix-bottom</code>的时候的定值，即元素仍然为<code>affix</code>状态的时候的阀值。若目标元素在<code>affix</code>状态定位为<code>fixed</code>则此值为CSS类<code>affix-fixed</code>设定的<code>fixed</code>状态的<code>top</code>值。</p><h3 id="检测位置"><a href="#检测位置" class="headerlink" title="检测位置"></a>检测位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.checkPosition = function() &#123;</div><div class="line">  if (!this.$element.is(&apos;:visible&apos;)) return</div><div class="line"></div><div class="line">  var height = this.$element.height()</div><div class="line">  var offset = this.options.offset</div><div class="line">  var offsetTop = offset.top</div><div class="line">  var offsetBottom = offset.bottom</div><div class="line">  var scrollHeight = Math.max($(document).height(), $(document.body).height())</div><div class="line"></div><div class="line">  if (typeof offset != &apos;object&apos;) offsetBottom = offsetTop = offset</div><div class="line">  if (typeof offsetTop == &apos;function&apos;) offsetTop = offset.top(this.$element)</div><div class="line">  if (typeof offsetBottom == &apos;function&apos;) offsetBottom = offset.bottom(this.$element)</div><div class="line"></div><div class="line">  var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)</div><div class="line"></div><div class="line">  if (this.affixed != affix) &#123;</div><div class="line">    if (this.unpin != null) this.$element.css(&apos;top&apos;, &apos;&apos;)</div><div class="line"></div><div class="line">    var affixType = &apos;affix&apos; + (affix ? &apos;-&apos; + affix : &apos;&apos;)</div><div class="line">    var e = $.Event(affixType + &apos;.bs.affix&apos;)</div><div class="line"></div><div class="line">    this.$element.trigger(e)</div><div class="line"></div><div class="line">    if (e.isDefaultPrevented()) return</div><div class="line">    this.affixed = affix</div><div class="line">    this.unpin = affix == &apos;bottom&apos; ? this.getPinnedOffset() : null</div><div class="line"></div><div class="line">    this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace(&apos;affix&apos;, &apos;affixed&apos;) + &apos;.bs.affix&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (affix == &apos;bottom&apos;) &#123;</div><div class="line">    this.$element.offset(&#123;</div><div class="line">      top: scrollHeight - height - offsetBottom</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>若元素不可见则返回,这里的目标容器的高度是取的<code>document</code>和<code>document.body</code>之间的最大值。<br>获取选项中的<code>offset</code>变量，若为非对象则<code>offsetBottom</code>,<code>offsetTop</code>和<code>offset</code>相同。<br>若<code>offset</code>中的<code>offsetTop</code>和<code>offsetBottom</code>为函数则执行函数，这里是相当的有用的地方。<br><strong>这里若设置的<code>offset</code>为对象如<code>offset: { bottom: 30 }</code>则一开始就处在<code>affix</code>的状态。</strong><br>获得<code>affix</code>值,<code>this.getState(scrollHeight, height, offsetTop, offsetBottom)</code>。</p><p>当<code>this.affixed</code>不等于<code>affix</code>值的时候，如果<code>this.unpin</code>不为空则去除<code>top</code>值。重置的意思。<br><code>affixType</code>即为元素所处状态的类型若是在顶部阀值内则是<code>affix-top</code>类，若触发则是<code>affix</code>,若<br>这是自己合成了事件比如<code>affix-top.bs.affix</code>这样的事件，也就是说你可以自定义这个事件，在里面进行一些操作当滚动的时候，如果在自定义的函数里面<code>return false</code>即<code>e.isDefaultPrevented</code>为true, <code>if (e.isDefaultPrevented()) return</code>将不会继续执行下去。<br>例如可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(&apos;#J_nav&apos;).on(&apos;affix.bs.affix&apos;, function (e) &#123;</div><div class="line">  alert(&apos;haha&apos;);</div><div class="line">&#125;).affix(&#123;</div><div class="line">  offset: &#123;</div><div class="line">    bottom: 30</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>this.affixed</code>赋值为重新获取的状态值, 若是到达底部阀值则赋值<code>this.unpin</code>即为获取即将进入<code>affix-bottom</code>状态的位移值。<br>然后为目标元素增加对应的目标元素粘滞状态的类并触发诸如<code>affix.bs.affix</code>的事件。</p><p>如果是到达底部的阀值即<code>affix</code>为<code>bottom</code>则设置目标元素的css<code>top</code>值为目标容器的内容高度(包含滚动距离)减去目标元素的高度减去底部阀值并设置元素为相对定位<code>relative</code>。</p><p><code>if (this.unpin != null) this.$element.css(&#39;top&#39;, &#39;&#39;)</code>若元素是从<code>affix-bottom</code>状态进入<code>affix</code>则去除元素的<code>top</code>值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.checkPositionWithEventLoop = function () &#123;</div><div class="line">  setTimeout($.proxy(this.checkPosition, this), 1)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当点击滚动条的时候触发。</p><p>这里从代码可以发现一个问题，当滚动到底部阀值的时候:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (affix == &apos;bottom&apos;) &#123;</div><div class="line">  this.$element.offset(&#123;</div><div class="line">    top: scrollHeight - height - offsetBottom</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>会给目标元素增加<code>position: relative</code>这样的定位属性，但是当回到<code>affix</code>状态的时候，还会带着<code>position: relative</code>这个属性，显然是不对的搜索了下<a href="https://github.com/twbs/bootstrap/pull/19934/commits/855109da359ac31fad80eb5168a5ebfed5c74853" target="_blank" rel="external">bootstrap issues</a>。但是这个有问题，如果代码改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (this.unpin != null) &#123;</div><div class="line">  this.$element.css(&apos;position&apos;, &apos;&apos;)</div><div class="line">  this.$element.css(&apos;top&apos;, &apos;&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在状态切换的时候会出现页面抖动的现象！！</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> 当滚动到底部阀值的时候，元素会被设置成<code>position: relative</code>,当回到<code>affix</code>状态的时候，这个<code>affix</code>状态的样式类比如写成<code>position: fixed</code>就便无法起作用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;许多情况下我们都需要去处理那种导航在页面滑动了一定的距离然后固定导航的需求，然后有可能会要求在滚动到距询问多少距离的时候又不固定导航。Bootstrap affix就是为此设计的。&lt;/p&gt;
&lt;p&gt;功能需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当页面滚动到一定距离即固定住元素&lt;/li
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="affix" scheme="http://yoursite.com/tags/affix/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-hoisting</title>
    <link href="http://yoursite.com/2017/08/13/JavaScript-hoisting/"/>
    <id>http://yoursite.com/2017/08/13/JavaScript-hoisting/</id>
    <published>2017-08-13T09:24:51.000Z</published>
    <updated>2017-08-13T09:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>变量声明是任何一门语言最基础的一个方面.然而，JavaScript也一点诡异，也就是被称为<em>声明提升</em>,这会导致一个看起来无害的变量声明变成一个微妙的bug.本文将阐述什么是提升声明并且教你如何避免被其困扰。</p><p>JavaScript是一门极其灵活的语言，所以可以让你随心所欲地在任何一个地方声明变量。比如，以下的自执行函数声明了三个变量并且之后用警告框来显示它们。需要注意的是，你不应该使用<code>alert</code>警告框,但是我们在这里是试着来验证<code>hoisted</code>而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  var bar = 2;</div><div class="line">  var baz = 3;</div><div class="line"></div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>这看起来是平常的JavaScript代码。正如期望的那样，它显示字符串<code>&quot;1 2 3&quot;</code>.现在，假设我们移动<code>alert</code>代码的位置，就像下面这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  var bar = 2;</div><div class="line">  var baz = 3;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>如果有人确实写过这样的代码，有可能是不小心写错的。明显地，弹框会在变量<code>bar</code>和<code>baz</code>声明之前就执行。然而这是完全可用而且不会产生异常的JavaScript代码。然而<code>alert</code>会显示<code>1 undefined undefined</code>。</p><p>基于我们之前的试验，JavaScript可以引用未声明的变量。现在，让我们执行相同的自执行函数(IIFE),但是完全移除了<code>baz</code>变量的声明，如下所示。突然间，因为<code>baz</code>变量未定义我们收到一个<code>ReferenceError</code>错误.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  var bar = 2;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><p>这是一个有趣的行为。为了理解这里发生了什么，你得理解提升声明。<code>Hoisting</code>是JavaScript解析器把所有的变量和函数声明移到目前脚本作用范围的顶部的操作(这里的脚本作用范围如果是在函数内部则是函数作用范围,否则是全局范围)然而，只有实际声明的变量才会<code>hoisted</code>.任何赋值都会留在原来的位置。因而，我们的第二段自执行的函数可以转化为以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo;</div><div class="line">  var bar;</div><div class="line">  var baz;</div><div class="line"></div><div class="line">  foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  bar = 2;</div><div class="line">  baz = 3;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>现在你明白了为什么第二个例子不会产生异常。在经过提升声明后，变量<code>bar</code>和<code>baz</code>实际上会在alert语句之前声明，即使是undefined值。在第三个例子中，变量<code>baz</code>被完全移除。这样就没有变量可以用来提升声明,因此alert语句会抛出异常。</p><p>另外，需要注意的是如下的代码也是会同样抛出<code>ReferenceError</code>错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar);</div><div class="line">  bar = 2;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><h1 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h1><p>如前所述，函数声明也可以hoisted.然而,<strong>函数表达式不会提升声明</strong>。例如,得益于函数声明提升以下代码会如期正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">  alert(&quot;Hello!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然而，如下示例将肯定会失败。<code>foo</code>变量声明会提升在调用函数之前。然而，因为<code>foo</code>的赋值并没有提升,将会抛出一个由于试图调用一个非函数变量的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">var foo = function() &#123;</div><div class="line">  alert(&quot;Hello!&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><em>提升声明</em>会影响变量生命周期，它包含了三个步骤:</p><ul><li>变量声明 - 创建变量。比如<code>var myvar</code></li><li>变量初始化 - 给变量赋值。比如<code>myvar = 150</code></li><li>访问变量 - 访问并且使用变量的值。比如<code>alert(myvar)</code></li></ul><p><em>提升声明</em>影响的范围:</p><ul><li>变量声明: 使用<code>var</code>, <code>let</code>或者<code>const</code>关键字</li><li>函数声明: 使用<code>function &lt;name&gt;(){...}</code>语法</li><li>类声明: 使用<code>class</code>关键字</li></ul><h1 id="函数作用域变量"><a href="#函数作用域变量" class="headerlink" title="函数作用域变量"></a>函数作用域变量</h1><p>声明的变量默认值是<code>undefined</code>.代码如下:<br><a href="http://jsbin.com/xizusi/edit?js,console" target="_blank" rel="external">打开Jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Declare num variable</div><div class="line">var num;  </div><div class="line">console.log(num); // =&gt; undefined  </div><div class="line">// Declare and initialize str variable</div><div class="line">var str = &apos;Hello World!&apos;;  </div><div class="line">console.log(str); // =&gt; &apos;Hello World!&apos;</div></pre></td></tr></table></figure><h1 id="块作用范围-let"><a href="#块作用范围-let" class="headerlink" title="块作用范围:let"></a>块作用范围:let</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">let声明</a>在块作用范围内声明并且初始化变量:<code>let myvar,myvar2 = &#39;Init&#39;</code>。默认情况下一个声明没初始化的变量拥有<code>undefined</code>值.</p><p><em>let</em>是由es6的一个极大的补充，它允许让代码模块化并且封装在块语句范围内.<br><a href="http://jsbin.com/jeyono/edit?js,console" target="_blank" rel="external">打开Jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;  </div><div class="line">  // Declare name block variable</div><div class="line">  let month;  </div><div class="line">  console.log(month); // =&gt; undefined  </div><div class="line">  // Declare and initialize year block variable</div><div class="line">  let year = 1994;  </div><div class="line">  console.log(year); // =&gt; 1994</div><div class="line">&#125;</div><div class="line">// name and year or not accessible here, outside the block</div><div class="line">console.log(year); // ReferenceError: year is not defined</div></pre></td></tr></table></figure><h1 id="Hoisting和let"><a href="#Hoisting和let" class="headerlink" title="Hoisting和let"></a>Hoisting和let</h1><p>摘自这篇<a href="https://github.com/getify/You-Dont-Know-JS/issues/767#issuecomment-227946671" target="_blank" rel="external">文章</a>:</p><blockquote><p>From the code author’s perspective, “declaring” is the var x part and “initializing” is the x = 2 part. But from the perspective of the spec/engine, these shift. “Declaring” is like registering a variable to a scope, “initializing” is reserving space/memory/binding for that variable so it can be used (and giving it its initial undefined value), and “assigning” is giving it a value explicitly in code.</p><p>Declaring always happens at time of compilation, and its effect can be seen whenever a scope is first entered. Initializing for var happens at the beginning of the scope, whereas it happens at the site of the declarator for let and const. Initialization is what gives a value its initial undefined value. Assignment then is when you actually use = to assign something to it.</p></blockquote><p>大概意思是说:在代码的作者看来,<code>声明</code>就是var x部分而<code>初始化</code>是指的x=2.但是从es6文档来看,<br><code>声明</code>是指在作用范围内注册这个变量，<code>初始化</code>是指为变量保留空间/内存/绑定以便它可以被引用(并且赋值它初始值<code>undefined</code>),而<code>赋值</code>是指显式地在代码中赋值。</p><p>声明永远发生在编译时，当进入作用域就只可以引用它。var变量的初始化发生在作用范围顶部，而let和const是在声明它们的地方。初始化就是赋值一个未定义的初始值。然后赋值是当你确实用<code>=</code>来赋值。</p><p>换句话也就是说，当声明<code>let</code>和<code>const</code>的时候，在它们之前只是进行了变量的注册，而未初始化，所以在<code>let</code>和<code>const</code>之前引用变量会出现<strong>变量引用错误</strong>.</p><p><code>let</code>会在块作用范围的顶部注册，但是当变量在声明前被访问会抛出错误：<code>ReferenceError: &lt;variable&gt; is not defined</code>.从变量声明语句到块作用范围的顶部，变量是在一个临时的死区(Temporal Dead Zone, 简称TDZ)并且不能够被访问.请看以下代码:<br><a href="http://jsbin.com/jodegoy/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function isTruthy(value) &#123;  </div><div class="line">  var myVariable = &apos;Value 1&apos;;</div><div class="line">  if (value) &#123;</div><div class="line">    /**</div><div class="line">     * temporal dead zone for myVariable</div><div class="line">     */</div><div class="line"></div><div class="line">    console.log(myVariable);// Throws ReferenceError: myVariable is not defined</div><div class="line">    let myVariable = &apos;Value 2&apos;;</div><div class="line">    // end of temporary dead zone for myVariable</div><div class="line">    console.log(myVariable); // =&gt; &apos;Value 2&apos;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  return false;</div><div class="line">&#125;</div><div class="line">var m = isTruthy(1); // =&gt; true</div><div class="line">console.log(m)</div></pre></td></tr></table></figure><p>在<code>myVariable</code>在从<code>let myVariable</code>到块语句<code>if (value) {...}</code>都是临时死区。如果在这个区间访问变量就会抛出一个引用的错误<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-referenceerror" target="_blank" rel="external">ReferenceError</a></p><p>但是这里有一个疑问就是说:是否<code>myVariable</code>真的提升变量声明至在块声明语句中的顶,或者只是在临时死区未定义而已？</p><p>一个准确的解释是：当引擎遇到一个包含了<code>let</code>语句的块语句之中的时候，这个变量首先会在块语句顶部声明，在声明状态它仍然不能够被访问，但是它覆盖了作用范围外的同名的变量。之后当<code>let myvAR</code>被传值后，变量在初始化状态就可以被使用了。可以查看这个<a href="https://github.com/getify/You-Dont-Know-JS/issues/767#issuecomment-227946671" target="_blank" rel="external">解释</a></p><h1 id="常量-const"><a href="#常量-const" class="headerlink" title="常量:const"></a>常量:const</h1><p>常量<code>const</code>会在块语句顶部被注册。由于<em>临时死区</em>常量不能够在声明之前被访问.<br><code>const</code>提升声明和<code>let</code>语句一致的行为<br>比如以下代码:<br><a href="http://jsbin.com/desugig/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function double(number) &#123;  </div><div class="line">   // temporal dead zone for TWO constant</div><div class="line">   console.log(TWO); // ReferenceError: TWO is not defined</div><div class="line">   const TWO = 2;</div><div class="line">   // end of temporal dead zone</div><div class="line">   return number * TWO;</div><div class="line">&#125;</div><div class="line">double(5); // =&gt; 10</div></pre></td></tr></table></figure><h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_declarations" target="_blank" rel="external">类声明</a>定义了一个包含了名字的构造函数和方法。类声明是ES6的一个很好的补充。类是建立在JavaScript原型继承之上的并且拥有一些其它的优点比如<code>super</code>(用来访问父类），<code>static</code>（用来定义静态方法）,<code>extends</code>(定义子类)还有其它。<br>一个类声明如下:<br><a href="http://jsbin.com/doqelut/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Point &#123;  </div><div class="line">   constructor(x, y) &#123;</div><div class="line">     this.x = x;</div><div class="line">     this.y = y;     </div><div class="line">   &#125;</div><div class="line">   move(dX, dY) &#123;</div><div class="line">     this.x += dX;</div><div class="line">     this.y += dY;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">// Create an instance</div><div class="line">var origin = new Point(0, 0);  </div><div class="line">// Call a method</div><div class="line">origin.move(50, 100);</div></pre></td></tr></table></figure><p>如果在类声明之前访问类就会引发错误，JavaScript会抛出<code>ReferenceError: &lt;name&gt; is not defined</code>的错误。<br>如下代码:<br><a href="http://jsbin.com/budopew/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Use the Company class</div><div class="line">// Throws ReferenceError: Company is not defined</div><div class="line">var apple = new Company(&apos;Apple&apos;);  </div><div class="line">// Class declaration</div><div class="line">class Company &#123;  </div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;    </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// Use correctly the Company class after declaration</div><div class="line">var microsoft = new Company(&apos;Microsoft&apos;);</div></pre></td></tr></table></figure><p>也可以用类表达式的方式来创建类。<br>代码如下:<br><a href="http://jsbin.com/vumomeq/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Use the Sqaure class</div><div class="line">console.log(typeof Square);   // =&gt; &apos;undefined&apos;  </div><div class="line">//Throws TypeError: Square is not a constructor</div><div class="line">var mySquare = new Square(10);  </div><div class="line">// Class declaration using variable statement</div><div class="line">var Square = class &#123;  </div><div class="line">  constructor(sideLength) &#123;</div><div class="line">    this.sideLength = sideLength;    </div><div class="line">  &#125;</div><div class="line">  getArea() &#123;</div><div class="line">    return Math.pow(this.sideLength, 2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">// Use correctly the Square class after declaration</div><div class="line">var otherSquare = new Square(5);</div></pre></td></tr></table></figure><p>因为<code>Square</code>类声明提升到作用域的顶端，在类声明行之前都是<code>undefined</code>的值，所以当在类声明之前用<code>var mySquare = new Square(10)</code>会导致JavaScript抛出错误<code>TypeError: Square is not a constructor</code>.</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>Hoisting</code>很容易理解，但是是经常忽视了JavaScript语言的细微差别。没有清晰地理解提升声明，你的程序将会容易受微妙bug的影响.为了帮助解决这个问题，很多开发者（和linting语法校验工具）主张在每个脚本作用范围的顶端单独写变量声明的语句。因为本质上这是JavaScript解析器如何解析你的代码，这条规则是有效的-即使我会因为打破这条规则而内疚。<br>有一个地方就是关于函数的提升声明，如果当程序员想要在源文件的顶部知道函数是如何调用的而不用滚动到函数声明的地方去查看函数的详细实现细节，例如<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#bindable-members-up-top" target="_blank" rel="external">看这里</a>来查看这种技术是如何增加了<em>Angular</em>控制器的可读成性的.</p><p>以上文字译自<a href="https://www.sitepoint.com/back-to-basics-javascript-hoisting/" target="_blank" rel="external">Back to Basics: JavaScript Hoisting</a>和<a href="https://rainsoft.io/javascript-hoisting-in-details/" target="_blank" rel="external">javascript-hoisting-in-details</a>,文字方面有进行过相关的缩略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;变量声明是任何一门语言最基础的一个方面.然而，JavaScript也一点诡异，也就是被称为&lt;em&gt;声明提升&lt;/em&gt;,这会导致一个看起来无害的变量声明变成一个微妙的bug.本文将阐述什么是提升声明并且教你如何避免被其困扰。&lt;/p&gt;
&lt;p&gt;JavaScript是一门极其灵活的
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="Hoisting" scheme="http://yoursite.com/tags/Hoisting/"/>
    
  </entry>
  
  <entry>
    <title>NodeClub源码解析</title>
    <link href="http://yoursite.com/2017/08/10/NodeClub%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/10/NodeClub源码解析/</id>
    <published>2017-08-10T13:42:20.000Z</published>
    <updated>2017-08-10T13:42:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS组件库</title>
    <link href="http://yoursite.com/2017/08/10/CSS%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/10/CSS组件库/</id>
    <published>2017-08-10T13:38:17.000Z</published>
    <updated>2017-08-10T13:38:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Token-based-auth</title>
    <link href="http://yoursite.com/2017/08/10/Token-based-auth/"/>
    <id>http://yoursite.com/2017/08/10/Token-based-auth/</id>
    <published>2017-08-10T13:37:13.000Z</published>
    <updated>2017-08-13T09:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在前后端分离如火如荼，传统的基于<strong>cookie的认证</strong>也有诸多不便。就目前自己所知有如下限制：</p><ul><li><p>首先，按照传统的基于cookie的认证，基于cookie的认证即服务器通过保存于客户端中的<strong>sessionid</strong>标识符来识别用户, 服务器必须得维持一份认证的状态。那么为了持久化session即在当服务器宕机或者转移的情况下，可以保证当服务器恢复之后，客户端访问不需要再次登录。这样会增加服务器开销而如今的<em>API DESIGN</em>是围绕着api来进行设计的,<strong>restful设计</strong>,请允许我咬文嚼字一下，restful即无状态服务吧^-^.</p></li><li><p>第二，有的应用场景下并未支持cookie,这个时候的解决方案有:采用url重写，表单隐藏域。我没弄过url重写，表单隐藏域也没弄过，真抱歉。对了，在微信端的时候关于用户的识别，由于微信是没支持cookie的所以需要自己实现一下session,可以利用openid来作为唯一标识，因为openid是唯一的具体可以参见<a href="https://github.com/node-webot/wechat/blob/master/lib/session.js" target="_blank" rel="external">node-webot</a>的session实现。</p></li><li><p>第三, api服务器往往会部署在另一台服务器上面，这样会造成浏览器的跨域，所以这个时候的解决办法是服务器端需要进行跨域的设置。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With, accept, content-type, xxxx&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:8010&quot;);//这里必须指定地址而不能写成星号否则浏览器会提示不能为星号</div></pre></td></tr></table></figure><p>然后前端的ajax请求库中必须设置<code>withCredentials</code>为<code>true</code>。<s>然而基于token的认证并无跨域问题</s>。</p><p>那么基于token的认证用到的主要有以下插件:</p><ul><li><a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="external">bcrypt</a> 加盐哈希密码用，有效抵御彩虹攻击。</li><li><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="external">jsonwebtoken</a> 用来生成符合<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">JSON WEB Tokens</a>标准的令牌</li><li><a href="https://www.npmjs.com/package/express-jwt" target="_blank" rel="external">express-jwt</a> 用来验证JsonWebTokens的中间件</li><li><a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">crypto-js</a> 前后端密码加密</li></ul><p>关于JsonWebToken可以参考这个<a href="https://jwt.io/" target="_blank" rel="external">网站</a>。</p><p>项目是采用express-generator构建的。<code>npm i -g express-generator</code>即可。</p><p><em>express-jwt默认是检查请求头中的<code>authorization</code>字段来进行token的验证的但是也可以进行自定义获取token的方法</em>。然后会把相关的用户信息存储在<code>req.user</code>中。<br>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.use(jwt(&#123;</div><div class="line">  secret: &apos;hello world !&apos;,</div><div class="line">  credentialsRequired: false, // 未注册的用户也可访问</div><div class="line">  getToken: function fromHeaderOrQuerystring (req) &#123;</div><div class="line">    // 从头部信息获取或者在url上类似?token=adadfs这样获取</div><div class="line">    if (req.headers.authorization &amp;&amp; req.headers.authorization.split(&apos; &apos;)[0] === &apos;Bearer&apos;) &#123;</div><div class="line">        return req.headers.authorization.split(&apos; &apos;)[1]</div><div class="line">    &#125; else if (req.query &amp;&amp; req.query.token) &#123;</div><div class="line">      return req.query.token</div><div class="line">    &#125;</div><div class="line">    return null</div><div class="line">  &#125;</div><div class="line">&#125;))</div></pre></td></tr></table></figure><p>下面贴出主要的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/login&apos;, function(req, res) &#123;</div><div class="line">  let userName = req.body.username</div><div class="line">  let password = entities.encode(req.body.password)</div><div class="line">  // find user</div><div class="line">  conn.query(&apos;SELECT * FROM user WHERE user_name = ?&apos;, [</div><div class="line">    userName</div><div class="line">  ], function (err, results, fields) &#123;</div><div class="line">    if (!err) &#123;</div><div class="line">      let user = results[0]</div><div class="line">      // validate password</div><div class="line">      bcrypt.compare(password, user.password, function (err, result) &#123;</div><div class="line">        console.log(user)</div><div class="line">        if (result) &#123;</div><div class="line">        // Dispatch token expired after 2mins for client</div><div class="line">          let token = jwt.sign(&#123; user_name: user.user_name &#125;, secret, &#123; expiresIn: 60 * 2 &#125;)</div><div class="line">          res.json(&#123;</div><div class="line">            code: &apos;0&apos;,</div><div class="line">            token: token</div><div class="line">          &#125;)</div><div class="line">        &#125; else &#123;</div><div class="line">          res.json(&#123;</div><div class="line">            code: &apos;1&apos;,</div><div class="line">            error: &apos;用户不存在&apos;</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">      res.json(&#123;</div><div class="line">        code: &apos;2&apos;,</div><div class="line">        error: &apos;用户不存在&apos;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>当用户登录的时候检测用户输入的用户名密码是否正确。如果正确则派发出token并在2分钟之后让其过期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// protected api</div><div class="line">app.all(&apos;/api/*&apos;, jwtVerify(&#123;secret: secret&#125;), function(err, req, res, next) &#123;</div><div class="line">  // 当令牌过期则返回401否则通过</div><div class="line">  if (err.name === &apos;UnauthorizedError&apos;) &#123;</div><div class="line">    res.status(401).send(&apos;Invalid token...&apos;)</div><div class="line">  &#125;</div><div class="line">  next()</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>然后再在所需要验证的api下使用中间件进行验证，当令牌过期则返回401。</p><p>以上就是主要的代码了，那么这里的话可以看到，完全是无状态的即真正的restful(休息ful哈哈，就是无状态嘛），服务端无需专门维护登录的用户状态信息，也省去维护的开销。</p><p>代码可见<a href="https://github.com/Troland/token-based-auth" target="_blank" rel="external">这里</a>。</p><p>可是这样做，会不会有什么问题呢？</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> 登录次数限制</li><li style="list-style: none"><input type="checkbox"> 安全检测</li><li style="list-style: none"><input type="checkbox" checked> 权限控制</li><li style="list-style: none"><input type="checkbox"> 用户注册进行严格的密码字符的控制</li></ul><hr><p>2017.8.13</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>现在由于有好些都是前后端分离的项目所以会出现跨域的问题，关于跨域的问题网上已有很多，这里不再赘述。这里只提供些方法:</p><ul><li>现在前后端分离，往往是后端作为API Server,然后关于前端的静态资源会走其它服务器。比如nginx配置成当请求数据服务器的时候导向后端的tomcats。</li></ul><p>举例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">http</div><div class="line">&#123;</div><div class="line">  upstream tomcats</div><div class="line">  &#123;</div><div class="line">    server 127.0.0.1:9001;</div><div class="line">    server 127.0.0.1:9002;</div><div class="line">  &#125;</div><div class="line">  server &#123;</div><div class="line">      listen       8000;</div><div class="line">      server_name  localhost;</div><div class="line"></div><div class="line">      # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回</div><div class="line">      try_files $uri $uri/index.html;</div><div class="line">      location ^/(js|css|image|font)/ &#123;</div><div class="line">        # 静态资源都在 static 文件夹下</div><div class="line">        root /abc/static/;</div><div class="line">      &#125;</div><div class="line">      #charset koi8-r;</div><div class="line"></div><div class="line">      #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">      location / &#123;</div><div class="line">          root   /pathtoroot;</div><div class="line">          index  index.html index.htm;</div><div class="line">      &#125;</div><div class="line">      error_page  404              /404.html;</div><div class="line"></div><div class="line">      location /api &#123;</div><div class="line">          proxy_set_header X-Real-IP $remote_addr;</div><div class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">          proxy_set_header Host $http_host;</div><div class="line">          proxy_set_header X-NginX-Proxy true;</div><div class="line">          proxy_pass http://tomcats;</div><div class="line">          proxy_redirect off;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当请求的是静态资源的时候就会指向nginx指定的目录，当是请求的api的时候会指向tomcat集群</p><ul><li>服务器配置允许跨域</li></ul><p>如果是<code>node</code>的话可以去加载<a href="https://www.npmjs.com/package/cors" target="_blank" rel="external">cors</a>包。示例代码码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 当跨域配置用cors插件</div><div class="line">const cors = require(&apos;cors&apos;)</div><div class="line">// 设置白免单可以指定允许多个ip源访问</div><div class="line">const whitelist = [</div><div class="line">  &apos;http://192.168.1.139:3003&apos;,</div><div class="line">  &apos;http://192.168.1.139:3100&apos;</div><div class="line">]</div><div class="line">const corsOptions = &#123;</div><div class="line">  origin: (origin, callback) =&gt; &#123;</div><div class="line">    if (whitelist.indexOf(origin) !== -1) &#123;</div><div class="line">      callback(null, true)</div><div class="line">    &#125; else &#123;</div><div class="line">      callback(new Error(&apos;Not allowed by CORS&apos;))</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  credentials: true, //这里必须写这样才能够接收到header里面的cookie,若不需要获得cookie可不设置</div><div class="line">  optionsSuccessStatus: 200, // some legacy browsers (IE11, various SmartTVs) choke on 204</div><div class="line">  methods: &apos;GET,HEAD,PUT,PATCH,POST,DELETE&apos;</div><div class="line">&#125;</div><div class="line">const app = express()</div><div class="line"></div><div class="line">app.use(cors(corsOptions))</div><div class="line"></div><div class="line">app.post(&apos;/api/num&apos;, function (req, res) &#123;</div><div class="line">  // 假设头是request.setRequestHeader(&apos;Authorization&apos;, &apos;Bearer &apos; + token);</div><div class="line">  req.get(&apos;authorization&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>引用<a href="https://www.npmjs.com/package/express-jwt-permissions" target="_blank" rel="external">express-jwt-permissions</a>。<br>你可以全局使用这个权限的检查也可以只为某些受保护的资源进行权限控制，例如：</p><p>全局使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const guard = require(&apos;express-jwt-permissions&apos;)()</div><div class="line">guard.check(&apos;admin&apos;)</div></pre></td></tr></table></figure><p>为受保护资源进行权限控制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/api/user&apos;, guard.check(&apos;status1&apos;), function (req, res) &#123;</div><div class="line">  console.log(&apos;Permissions:&apos;, req.user)</div><div class="line">  res.json(&#123;</div><div class="line">    code: 200,</div><div class="line">    username: &apos;tristan&apos;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>那么这里的<code>permission</code>是从哪来的呢？<br>首先用户注册，会获得默认的权限值, 或者由超级管理员进行注册生成用户。然后，超级管理员为用户设置权限。生成用户对应的<code>permission</code>值。</p><p>代码可见<a href="https://github.com/Troland/permission" target="_blank" rel="external">这里</a>。</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> <strong>那么当项目是否是前后端分离的时候，这个权限应该如何控制会是最优解呢？</strong></li></ul><p>且听下回分解^.^。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在前后端分离如火如荼，传统的基于&lt;strong&gt;cookie的认证&lt;/strong&gt;也有诸多不便。就目前自己所知有如下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，按照传统的基于cookie的认证，基于cookie的认证即服务器通过保存于客户端中的&lt;strong&gt;sess
      
    
    </summary>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
      <category term="jsonwebtoken" scheme="http://yoursite.com/tags/jsonwebtoken/"/>
    
  </entry>
  
  <entry>
    <title>CSS常用库</title>
    <link href="http://yoursite.com/2017/08/10/CSS%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/10/CSS常用库/</id>
    <published>2017-08-10T13:35:14.000Z</published>
    <updated>2017-09-10T09:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>input的line-height样式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.input &#123;</div><div class="line">  width: 100px;</div><div class="line">  line-height: 1.8;</div><div class="line">  font-size: 18px;</div><div class="line">  box-sizing: border-box;</div><div class="line">  padding: 5px;</div><div class="line">  border: 1px solid #f00;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.input &#123;</div><div class="line">  height: 30px;</div><div class="line">  line-height: 30px;</div><div class="line">  padding: 0 10px;</div><div class="line">  border: 1px solid #f00;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">  -webkit-appearance: none;</div><div class="line">  -moz-appearance: none;</div><div class="line">  appearance: none;</div><div class="line">  background-color: #fff;</div><div class="line">  background-image: none;</div><div class="line">  border-radius: 4px;</div><div class="line">  border: 1px solid #bfcbd9;</div><div class="line">  box-sizing: border-box;</div><div class="line">  color: #1f2d3d;</div><div class="line">  display: inline-block;</div><div class="line">  font-size: inherit;</div><div class="line">  height: 36px;</div><div class="line">  line-height: 1;</div><div class="line">  outline: none;</div><div class="line">  padding: 3px 10px;</div><div class="line">  transition: border-color .2s cubic-bezier(.645,.045,.355,1);</div><div class="line">  width: 100%;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong><code>vertical-align: middle;</code>是当元素和其它内联元素比如button等在一个div的时候可以垂直居中对齐</strong><br>这样输入文字居中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;input的line-height样式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap scrollspy 源码解读</title>
    <link href="http://yoursite.com/2017/08/06/Bootstrap-scrollspy-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/06/Bootstrap-scrollspy-源码解读/</id>
    <published>2017-08-06T07:35:13.000Z</published>
    <updated>2017-10-08T13:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：</p><p>功能需求:</p><ul><li>当点击导航栏的时候会显示对应的内容块到顶部。</li><li>当页面滚动的时候，当到达对应导航的内容块，则会激活导航。</li></ul><p><strong>需要注意的是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动，从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets，这个时候就需要调用refresh方法进行重新计算offsets和targets。</strong></p><p>Bootstrap scrollspy源码解读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">this.$scrollElement: 滚动的容器</div><div class="line">this.selector: 导航选择器</div><div class="line">this.targets: 导航的元素</div><div class="line">this.activeTarget: 激活状态的导航元素</div><div class="line">this.offsets: 内容块元素的在页面中的位移</div><div class="line">*/</div><div class="line">function ScrollSpy(element, options) &#123;</div><div class="line">    this.$body          = $(document.body)</div><div class="line">    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)</div><div class="line">    this.options        = $.extend(&#123;&#125;, ScrollSpy.DEFAULTS, options)</div><div class="line">    this.selector       = (this.options.target || &apos;&apos;) + &apos; .nav li &gt; a&apos;</div><div class="line">    this.offsets        = []</div><div class="line">    this.targets        = []</div><div class="line">    this.activeTarget   = null</div><div class="line">    this.scrollHeight   = 0</div><div class="line"></div><div class="line">    this.$scrollElement.on(&apos;scroll.bs.scrollspy&apos;, $.proxy(this.process, this))</div><div class="line">    this.refresh()</div><div class="line">    this.process()</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>首先在<code>ScrollSpy</code>构造函数中,先获得滚动容器，导航选择器等，然后调用<code>refresh</code>和<code>process</code>函数来初始化实例。<br>获得容器的内容高度<code>scrollHeight</code>,<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">scrollHeight</a>。<br>并绑定滚动容器的滚动事件为<code>this.process</code>。</p><p>再来看<code>refresh</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.refresh = function () &#123;</div><div class="line">    var that          = this</div><div class="line">    var offsetMethod  = &apos;offset&apos;</div><div class="line">    var offsetBase    = 0</div><div class="line"></div><div class="line">    this.offsets      = []</div><div class="line">    this.targets      = []</div><div class="line">    this.scrollHeight = this.getScrollHeight()</div><div class="line"></div><div class="line">    /*判断滚动窗口是否为body*/</div><div class="line">    if (!$.isWindow(this.$scrollElement[0])) &#123;</div><div class="line">      offsetMethod = &apos;position&apos;</div><div class="line">      offsetBase   = this.$scrollElement.scrollTop()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.$body</div><div class="line">      .find(this.selector)</div><div class="line">      .map(function () &#123;</div><div class="line">        var $el   = $(this)</div><div class="line">        var href  = $el.data(&apos;target&apos;) || $el.attr(&apos;href&apos;)</div><div class="line">        var $href = /^#./.test(href) &amp;&amp; $(href)</div><div class="line"></div><div class="line">        return ($href</div><div class="line">          &amp;&amp; $href.length</div><div class="line">          &amp;&amp; $href.is(&apos;:visible&apos;)</div><div class="line">          &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null</div><div class="line">      &#125;)</div><div class="line">      .sort(function (a, b) &#123; return a[0] - b[0] &#125;)</div><div class="line">      .each(function () &#123;</div><div class="line">        that.offsets.push(this[0])</div><div class="line">        that.targets.push(this[1])</div><div class="line">      &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里的意思是设置实例的内容块的offsets和导航栏的targets,并按升序排列。这里有一个问题就是为什么当滚动的容器不是window的话<code>offsetBase</code>为滚动容器的滚动距离？因为当一个元素在一个滚动容器里面的时候元素在滚动容器中的绝对位移值是元素的<code>position().top</code>的值加上滚动容器的滚动距离，所以这里需要写上滚动容器的滚动距离。</p><p>接下来是<code>process</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scrollTop: 元素已经滚动的距离加上距离顶部的距离</div><div class="line">maxScroll: 滚动容器可滚动距离</div><div class="line">activeTarget: 当前激活的导航元素</div><div class="line"></div><div class="line">*/</div><div class="line">ScrollSpy.prototype.process = function () &#123;</div><div class="line">    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset</div><div class="line">    var scrollHeight = this.getScrollHeight()</div><div class="line">    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()</div><div class="line">    var offsets      = this.offsets</div><div class="line">    var targets      = this.targets</div><div class="line">    var activeTarget = this.activeTarget</div><div class="line">    var i</div><div class="line"></div><div class="line">    /*</div><div class="line">    这里的意思是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动</div><div class="line">    从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets</div><div class="line">    */</div><div class="line">    if (this.scrollHeight != scrollHeight) &#123;</div><div class="line">      this.refresh()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">    当滚动距离超过最大可滚动距离，并且activeTarget和最后一个激活元素地址不一致则激活最后一级导航</div><div class="line">    */</div><div class="line">    if (scrollTop &gt;= maxScroll) &#123;</div><div class="line">      return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     当滚动距离小于offsets中的第一个并且有激活的导航的时候就不激活导航</div><div class="line">    */</div><div class="line">    if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) &#123;</div><div class="line">      this.activeTarget = null</div><div class="line">      return this.clear()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i = offsets.length; i--;) &#123;</div><div class="line">      activeTarget != targets[i]</div><div class="line">        &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">        &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">        &amp;&amp; this.activate(targets[i])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (i = offsets.length; i--;) &#123;</div><div class="line">  activeTarget != targets[i]</div><div class="line">    &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">    &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">    &amp;&amp; this.activate(targets[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当前激活的导航和targets数组一一比对如果不是当前激活导航则再比对，注意到这里的比对是<em>从位移数组的最后一个开始倒序进行比对的</em>, 然后当滚动距离大于位移数组的当前并且小于下一个，或者位移数组的最后一个不存在，即为最后一个导航的时候。则激活目标导航, <strong>那么这里你所看到的现象即: 当上一个目标内容元素完全消失于viewport(视窗)之中的时候,下一个内容块到达视窗顶部的时候即激活当前的导航所在的元素</strong>。当当然这里也有性能优化的意思，然后倒序来比较有一个好处就是，如果是升序比较就得计算那个<em>内容元素的高度来进行比较</em>，但是倒序则不用。</p><p>疑问:</p><ul><li>为什么当滚动容器是body的时候<code>offsetMethod</code>为<em>offset</em>非<code>body</code>的时候为<em>position</em>?</li></ul><p>因为当滚动容器为body的时候就得计算元素在body上面的位移，而如果非body的话就在滚动容器里面比如<br><code>&lt;div class=&quot;scroll-container&quot;&gt;&lt;/div&gt;</code>当滚动的内容在里面的时候得设置滚动容器的样式<code>position: relative</code>。<br>当设置为<code>position</code>的时候里面的内容元素即为相对于此容器的位移而不是相对于<code>body</code>。</p><p>翻看<code>jQuery源码</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">position: function() &#123;</div><div class="line">  if ( !this[ 0 ] ) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var offsetParent, offset,</div><div class="line">    elem = this[ 0 ],</div><div class="line">    parentOffset = &#123; top: 0, left: 0 &#125;;</div><div class="line"></div><div class="line">  // Fixed elements are offset from window (parentOffset = &#123;top:0, left: 0&#125;,</div><div class="line">  // because it is its only offset parent</div><div class="line">  if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) &#123;</div><div class="line"></div><div class="line">    // Assume getBoundingClientRect is there when computed position is fixed</div><div class="line">    offset = elem.getBoundingClientRect();</div><div class="line"></div><div class="line">  &#125; else &#123;</div><div class="line"></div><div class="line">    // Get *real* offsetParent</div><div class="line">    offsetParent = this.offsetParent();</div><div class="line"></div><div class="line">    // Get correct offsets</div><div class="line">    offset = this.offset();</div><div class="line">    if ( !jQuery.nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) &#123;</div><div class="line">      parentOffset = offsetParent.offset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Add offsetParent borders</div><div class="line">    parentOffset = &#123;</div><div class="line">      top: parentOffset.top + jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true ),</div><div class="line">      left: parentOffset.left + jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true )</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Subtract parent offsets and element margins</div><div class="line">  return &#123;</div><div class="line">    top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),</div><div class="line">    left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )</div><div class="line">  &#125;;</div><div class="line">&#125;,</div><div class="line">offsetParent: function() &#123;</div><div class="line">  return this.map( function() &#123;</div><div class="line">    var offsetParent = this.offsetParent;</div><div class="line"></div><div class="line">    while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) &#123;</div><div class="line">      offsetParent = offsetParent.offsetParent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return offsetParent || documentElement;</div><div class="line">  &#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的源码大概意思如果元素不是<code>fixed</code>定位则通过<code>offsetParent</code>函数找出最近的定位的元素。</p><p>接下来是激活导航的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.activate = function (target) &#123;</div><div class="line">  this.activeTarget = target</div><div class="line"></div><div class="line">  this.clear()</div><div class="line"></div><div class="line">  var selector = this.selector +</div><div class="line">    &apos;[data-target=&quot;&apos; + target + &apos;&quot;],&apos; +</div><div class="line">    this.selector + &apos;[href=&quot;&apos; + target + &apos;&quot;]&apos;</div><div class="line"></div><div class="line">  var active = $(selector)</div><div class="line">    .parents(&apos;li&apos;)</div><div class="line">    .addClass(&apos;active&apos;)</div><div class="line"></div><div class="line">  // 若激活的导航的父元素有dropdown-men类则为其</div><div class="line">  if (active.parent(&apos;.dropdown-menu&apos;).length) &#123;</div><div class="line">    active = active</div><div class="line">      .closest(&apos;li.dropdown&apos;)</div><div class="line">      .addClass(&apos;active&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  active.trigger(&apos;activate.bs.scrollspy&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后是那个<code>noConflict</code>方法, 因为有可能会有重名方法的插件所以需要使用这个关于这个的处理可以参见<a href="http://www.cnblogs.com/ip128/p/4609828.html" target="_blank" rel="external">这里</a>。我在这个基础上增加了自己的一个处理方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var old = $.fn.scrollspy</div><div class="line"></div><div class="line">$.fn.scrollspy             = Plugin</div><div class="line">$.fn.scrollspy.Constructor = ScrollSpy</div><div class="line"></div><div class="line"></div><div class="line">// SCROLLSPY NO CONFLICT</div><div class="line">// =====================</div><div class="line"></div><div class="line">$.fn.scrollspy.noConflict = function () &#123;</div><div class="line">  $.fn.scrollspy = old</div><div class="line">  return this</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在实际使用的过程中,根据所使用的Bootstrap插件在页面中出现的位置会有不同的处理方法,下面分情况来讲解:</p><ul><li>当Bootstrap插件在自定义的插件之后的时候, 若想调用自定义的插件则<code>$.fn.scrollspy.noConflict</code>即可。</li><li><p>若Bootstrap插件在自定义的插件之前: 则有两种解决办法:</p><ul><li><p>可以在两个插件之间写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Af = $.fn.scrollspy.noConflict()</div><div class="line">$.fn.Af = Af</div><div class="line">这样后面想要调用该方法就调用`$(el).Af()`</div></pre></td></tr></table></figure></li><li><p>或者是把后面自定义的插件写成类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function($)&#123;</div><div class="line">      var old = $.fn.scrollspy; //必须写在第一行</div><div class="line">      $.fn.scrollspy=function()&#123;</div><div class="line">          alert(&quot;自定义scrollspy插件&quot;);</div><div class="line">      &#125;</div><div class="line">      $.fn.scrollspy.noConflict = function () &#123;</div><div class="line">        $.fn.scrollspy = old</div><div class="line">        return this</div><div class="line">      &#125;</div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure></li></ul></li></ul><p>疑问：</p><ul><li>这里为什么要用<code>parents</code>?</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var active = $(selector)</div><div class="line">          .parents(&apos;li&apos;)</div><div class="line">          .addClass(&apos;active&apos;)</div></pre></td></tr></table></figure><p>清除激活状态导航的激活状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.clear = function () &#123;</div><div class="line">    $(this.selector)</div><div class="line">      .parentsUntil(this.options.target, &apos;.active&apos;)</div><div class="line">      .removeClass(&apos;active&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当那些导航是异步请求加载出来的，这个时候应该如何做？</li></ul><hr><p>2017.10.8 如果导航是异步请求出来的可以在数据请求完成后再去进行实例化。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>其实，这个说到底不管滚动的容器是window还是不是，基本上都是要以元素的<code>getBoundingClientRect</code>属性为准，看过<strong>jQuery</strong>的源码即可知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：&lt;/p&gt;
&lt;p&gt;功能需求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当点击导航栏的时候会显示对应的内容块到顶部。&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="scrollSpy" scheme="http://yoursite.com/tags/scrollSpy/"/>
    
      <category term="offset" scheme="http://yoursite.com/tags/offset/"/>
    
      <category term="position" scheme="http://yoursite.com/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>二维码登录</title>
    <link href="http://yoursite.com/2017/07/21/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2017/07/21/二维码登录/</id>
    <published>2017-07-21T01:21:16.000Z</published>
    <updated>2017-07-21T01:21:16.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用CSS3详解</title>
    <link href="http://yoursite.com/2017/06/18/%E5%B8%B8%E7%94%A8CSS3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/06/18/常用CSS3详解/</id>
    <published>2017-06-18T15:24:15.000Z</published>
    <updated>2017-07-22T13:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理CSS3的属性的原理，特意分享一下个人的一些理解。</p><h2 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h2><p><code>transform-origin</code>是改变一个元素的变形的原点通常是和<code>transform</code>一起使用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin" target="_blank" rel="external">transform-origin</a> MDN上说明:</p><blockquote><p>transform-origin CSS属性让你更改一个元素变形的原点。例如，rotate()的transform-origin 是旋转的中心点 (这个属性的应用原理是先用这个属性的负值translate该元素，进行变形，然后再用这个属性的值把元素translate回去)。</p></blockquote><p>假设有以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.grid &#123;</div><div class="line"> transform: rotate(30deg);</div><div class="line"> transform-origin: 70% 50%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>transform-origin</code>属性的默认值是<code>50% 50%</code>。等于是<strong>放置的中心点水平移动到70%移动了20%</strong>,为了保持旋转的角度仍旧为30deg,这个时候元素必须往上移动，否则那个旋转的角度将会变大。</p><p>如下图所示：<br><img src="/images/css-transform-origin.png" alt=""></p><p>可以玩一下<a href="http://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html" target="_blank" rel="external">w3Ctransform-origin演示地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理CSS3的属性的原理，特意分享一下个人的一些理解。&lt;/p&gt;
&lt;h2 id=&quot;transform-origin&quot;&gt;&lt;a href=&quot;#transform-origin&quot; class=&quot;headerlink&quot; title=&quot;transform-origin&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs碎碎念</title>
    <link href="http://yoursite.com/2017/06/08/Nodejs%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/06/08/Nodejs碎碎念/</id>
    <published>2017-06-08T14:21:01.000Z</published>
    <updated>2017-10-16T15:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录Nodejs使用中的问题与解决方案。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>exports只是module.exports的引用</p><h2 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h2><p><strong>大小固定不变</strong>。</p><p>当需要保存非<em>utf-8</em>字符串,2进制等其他格式的时候，就必须得使用。比如最近有使用过微信SDK上传图片并通过微信返回的<code>serverID即媒体id</code>来把微信上的图片下载下来。返回数据即为<code>Buffer</code>对象。</p><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">  process.nextTick(() =&gt; test());</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">  setTimeout(() =&gt; test(), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>关于高并发</strong> nodejs是通过事件循环来挨个抽取事件队列中的一个个<strong>Task</strong>来执行，来获得高并发。</p><h2 id="进程，子进程"><a href="#进程，子进程" class="headerlink" title="进程，子进程"></a>进程，子进程</h2><p><strong>IPC</strong>进程间通讯技术</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>Node.js利用多核的办法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录Nodejs使用中的问题与解决方案。&lt;/p&gt;
&lt;h2 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h2&gt;&lt;p&gt;exports只是module.exports的引用&lt;/p&gt;
&lt;h2 id=&quot;Buf
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
      <category term="Buffer" scheme="http://yoursite.com/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>Session与Cookie小结</title>
    <link href="http://yoursite.com/2017/05/20/Session%E4%B8%8ECookie%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/20/Session与Cookie小结/</id>
    <published>2017-05-20T03:57:05.000Z</published>
    <updated>2017-08-10T13:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学session与cookie相关的内容，有以下几点疑点：</p><ul><li>Session存储在哪？</li><li>记住密码功能及相关的bug</li><li>Session持久化</li><li>如果在cookie中保存那个登录信息应该保存些信息？</li></ul><p>当为检查是否已经登录是通过检查<code>req.session</code>还是通过<code>req.cookies[&#39;isLogged&#39;]</code>,这两者有区别吗？过期时间都是一致的吗？</p><p>登录流程:</p><ul><li>登录系统，填写用户名和密码，后端检测用户名和密码，成功则设置一个登录的cookie</li><li>这个sessid标识符和token应该是随机的值，且都在表中，就应该那个数据库表tokens应该是一个sessid标识符对应一个token吧，然后这个token应该是个哈希值</li><li><p>最后当未从登录页登录的用户并且有一个登录的cookie的时候:</p><ul><li>首先判断那个sessionid存在并且从表中查找到这个sessid对应的hash了的token，则判断为认证通过的用户，然后再重新分配一个sessid和token覆盖掉这条记录，并且生成一个新的登录cookie写到客户端上</li><li>如果sessid存在但token不匹配，则认为被攻击了，然后删除这个session对应的cookie全部删除</li><li>如果sessid和用户名都不存在则忽略login cookie返回到登录页面</li></ul><p>但是这是有并发的问题即:<br>当用户的两个tab同时打开的时候，这个前一个tab会更新token,然后后一个tab由于去比较token导致token不匹配，因为前面的tab已经更新过了，从而导致被认为是被伪造的攻击而退出到登录界面。</p><p>创建用户和登录的时候要加密那个密码，当登录的时候，</p></li></ul><h2 id="基于Cookie认证"><a href="#基于Cookie认证" class="headerlink" title="基于Cookie认证"></a>基于Cookie认证</h2><p>步骤如下:<br>-</p><h2 id="基于Token认证"><a href="#基于Token认证" class="headerlink" title="基于Token认证"></a>基于Token认证</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学session与cookie相关的内容，有以下几点疑点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session存储在哪？&lt;/li&gt;
&lt;li&gt;记住密码功能及相关的bug&lt;/li&gt;
&lt;li&gt;Session持久化&lt;/li&gt;
&lt;li&gt;如果在cookie中保存那个登录信息应该保存些信息？
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端开发相关</title>
    <link href="http://yoursite.com/2017/03/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/03/14/移动端开发相关/</id>
    <published>2017-03-14T14:51:15.000Z</published>
    <updated>2017-10-13T03:24:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做移动开发的过程中难免会遇到一些奇奇怪怪的问题，在此罗列如下:</p><ul><li>1像素问题</li></ul><p>##1像素问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做移动开发的过程中难免会遇到一些奇奇怪怪的问题，在此罗列如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1像素问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##1像素问题&lt;/p&gt;

      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
      <category term="1像素" scheme="http://yoursite.com/tags/1%E5%83%8F%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>React源码解读</title>
    <link href="http://yoursite.com/2017/03/06/React%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/03/06/React源码解读/</id>
    <published>2017-03-05T16:45:02.000Z</published>
    <updated>2017-10-12T01:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>React源码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React源码&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lib-flexible源码解读及实战</title>
    <link href="http://yoursite.com/2016/12/30/lib-flexible%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2016/12/30/lib-flexible源码解读/</id>
    <published>2016-12-30T00:52:07.000Z</published>
    <updated>2017-10-19T15:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">Flexible</a>方案是淘宝的移动端适配方案,相关的文章在<a href="https://github.com/amfe/article/issues/17" target="_blank" rel="external">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">;(function(win, lib) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;)(window, window[&apos;lib&apos;] || (window[&apos;lib&apos;] = &#123;&#125;));</div></pre></td></tr></table></figure><p>这是一个插件的写法之一。你还可以在这里找到其它方法(IIFE)[<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/]。" target="_blank" rel="external">http://benalman.com/news/2010/11/immediately-invoked-function-expression/]。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (metaEl) &#123;</div><div class="line">    console.warn(&apos;将根据已有的meta标签来设置缩放比例&apos;);</div><div class="line">    var match = metaEl.getAttribute(&apos;content&apos;).match(/initial\-scale=([\d\.]+)/);</div><div class="line">    if (match) &#123;</div><div class="line">        scale = parseFloat(match[1]);</div><div class="line">        dpr = parseInt(1 / scale);</div><div class="line">    &#125;</div><div class="line">&#125; else if (flexibleEl) &#123;</div><div class="line">    var content = flexibleEl.getAttribute(&apos;content&apos;);</div><div class="line">    if (content) &#123;</div><div class="line">        var initialDpr = content.match(/initial\-dpr=([\d\.]+)/);</div><div class="line">        var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/);</div><div class="line">        if (initialDpr) &#123;</div><div class="line">            dpr = parseFloat(initialDpr[1]);</div><div class="line">            scale = parseFloat((1 / dpr).toFixed(2));    </div><div class="line">        &#125;</div><div class="line">        if (maximumDpr) &#123;</div><div class="line">            dpr = parseFloat(maximumDpr[1]);</div><div class="line">            scale = parseFloat((1 / dpr).toFixed(2));    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先这里会判断是否写了<code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;</code>元素。如果有则从页面中取出对应的缩放系数<strong>(scale)</strong>。然后通过<strong>(scale)</strong>算出对应的设备像素比<strong>(dpr)</strong>.</p><p>如果页面上写了<code>&lt;meta name=&quot;flexible&quot; content=&quot;initial-dpr=2,maximum-dpr=3&quot; /&gt;</code>则会取<code>initial-dpr</code>和<code>maximum-dpr</code>之中最大者。</p><p>如果以上两都都没设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (!dpr &amp;&amp; !scale) &#123;</div><div class="line">    var isAndroid = win.navigator.appVersion.match(/android/gi);</div><div class="line">    var isIPhone = win.navigator.appVersion.match(/iphone/gi);</div><div class="line">    var devicePixelRatio = win.devicePixelRatio;</div><div class="line">    if (isIPhone) &#123;</div><div class="line">        // iOS下,2倍屏使用2倍方案,3的屏3倍的方案，其余的用1倍方案</div><div class="line">        if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123;                </div><div class="line">            dpr = 3;</div><div class="line">        &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123;</div><div class="line">            dpr = 2;</div><div class="line">        &#125; else &#123;</div><div class="line">            dpr = 1;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 其他设备下，仍旧使用1倍的方案</div><div class="line">        dpr = 1;</div><div class="line">    &#125;</div><div class="line">    scale = 1 / dpr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>这里有检测当在安卓下的时候并没有使用高清方案，具体的原因可见<a href="https://github.com/amfe/lib-flexible/issues/11" target="_blank" rel="external">issue</a><br>大概的意思就是说有些安卓设置的<code>initial-scale</code>不为1的时候会无效。</strong>。由于这个原因会产生一些问题比如1px边框线的问题,具体可见网友的文章<a href="http://www.cnblogs.com/lyzg/p/5117324.html" target="_blank" rel="external">基于淘宝弹性布局方案lib-flexible的问题研究</a></p><p>这里在实际的工作过程假设有用<code>vue</code>的话，在移动端的适配过程中假设引用了一个<code>vue-star-rating</code>组件由于组件的<code>star-size</code>是设置的是数值，然后当你在安卓下的时候会发现这个星星会变得很大解决办法是利用<code>lib.flexible.dpr</code>或者<code>lib.flexible.rem</code>来动态设置这个组件的星星的大小，这里暂且只发现这种解决方案，如果有其它的方法或者其它的评价组件，或者自己写一个？欢迎指正-^.^-。</p><p>接下来设置页面根元素的<code>data-dpr</code>属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">docEl.setAttribute(&apos;data-dpr&apos;, dpr);</div><div class="line">if (!metaEl) &#123;</div><div class="line">    metaEl = doc.createElement(&apos;meta&apos;);</div><div class="line">    metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</div><div class="line">    metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</div><div class="line">    //判断页面上是否有head标签没有则写一个</div><div class="line">    if (docEl.firstElementChild) &#123;</div><div class="line">        docEl.firstElementChild.appendChild(metaEl);</div><div class="line">    &#125; else &#123;</div><div class="line">        var wrap = doc.createElement(&apos;div&apos;);</div><div class="line">        wrap.appendChild(metaEl);</div><div class="line">        doc.write(wrap.innerHTML);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来是刷新rem函数计算出rem的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function refreshRem()&#123;</div><div class="line">    var width = docEl.getBoundingClientRect().width;</div><div class="line">    if (width / dpr &gt; 540) &#123;</div><div class="line">        width = 540 * dpr;</div><div class="line">    &#125;</div><div class="line">    var rem = width / 10;</div><div class="line">    docEl.style.fontSize = rem + &apos;px&apos;;</div><div class="line">    flexible.rem = win.rem = rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>docEl.getBoundingClientRect().width</code>这里是计算出页面在视窗里面的宽度,具体可见<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">这里</a>。<br>当<code>宽度大于540*dpr</code>的时候，则最大为<code>540 * dpr</code>。rem值为width / 10，即假设是750的iphone6的时候rem值为75,设置根元素<code>html</code>的字体大小值。</p><p>接下来是监听页面事件<code>resize</code>和<code>pageshow</code>刷新页面rem大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">win.addEventListener(&apos;resize&apos;, function() &#123;</div><div class="line">    clearTimeout(tid);</div><div class="line">    tid = setTimeout(refreshRem, 300);</div><div class="line">&#125;, false);</div><div class="line">win.addEventListener(&apos;pageshow&apos;, function(e) &#123;</div><div class="line">    if (e.persisted) &#123;</div><div class="line">        clearTimeout(tid);</div><div class="line">        tid = setTimeout(refreshRem, 300);</div><div class="line">    &#125;</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure><p>监听window.document的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (doc.readyState === &apos;complete&apos;) &#123;</div><div class="line">    doc.body.style.fontSize = 12 * dpr + &apos;px&apos;;</div><div class="line">&#125; else &#123;</div><div class="line">    doc.addEventListener(&apos;DOMContentLoaded&apos;, function(e) &#123;</div><div class="line">        doc.body.style.fontSize = 12 * dpr + &apos;px&apos;;</div><div class="line">    &#125;, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当文档的<code>readyState</code>为<code>complete</code>或者为<code>DOMContentLoaded</code>即页面内容载入完成，设置body的字体大小。</p><p>最后获得主动获得rem值，页面的dpr赋值到<code>lib.flexible</code>下还有一些工具函数<code>rem2px</code>和<code>px2rem</code>。这里在实际的工作过程中,<code>lib.flexible.dpr</code>相当的有用，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">refreshRem();</div><div class="line"></div><div class="line">flexible.dpr = win.dpr = dpr;</div><div class="line">flexible.refreshRem = refreshRem;</div><div class="line">flexible.rem2px = function(d) &#123;</div><div class="line">    var val = parseFloat(d) * this.rem;</div><div class="line">    if (typeof d === &apos;string&apos; &amp;&amp; d.match(/rem$/)) &#123;</div><div class="line">        val += &apos;px&apos;;</div><div class="line">    &#125;</div><div class="line">    return val;</div><div class="line">&#125;</div><div class="line">flexible.px2rem = function(d) &#123;</div><div class="line">    var val = parseFloat(d) / this.rem;</div><div class="line">    if (typeof d === &apos;string&apos; &amp;&amp; d.match(/px$/)) &#123;</div><div class="line">        val += &apos;rem&apos;;</div><div class="line">    &#125;</div><div class="line">    return val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p><strong>2017.10.19后续</strong></p><p>翻看了<a href="https://github.com/ant-design/ant-design-mobile/blob/master/components/style/mixins/hairline.less" target="_blank" rel="external">ant-design</a>中关于1px线的处理再和<strong>libflexible.js</strong>结合整理出了以下的sass函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">@mixin hairline($color: #C7C7C7, $direction: left, $radius: 0) &#123;</div><div class="line"></div><div class="line">  @if $direction != &apos;all&apos; &#123;</div><div class="line">    border-#&#123;$direction&#125;: 1PX solid $color;</div><div class="line"></div><div class="line">    [data-dpr=&quot;1&quot;] &amp; &#123;</div><div class="line">      border-#&#123;$direction&#125;: none;</div><div class="line">      @media (min-resolution: 2dppx), (min-resolution: 192dpi) &#123;</div><div class="line">        position: relative;</div><div class="line"></div><div class="line">        &amp;:before &#123;</div><div class="line">          content: &quot; &quot;;</div><div class="line">          position: absolute;</div><div class="line">          border-#&#123;$direction&#125;: 1PX solid $color;</div><div class="line">          @if $direction == &apos;top&apos; &#123;</div><div class="line">            left: 0;</div><div class="line">            top: 0;</div><div class="line">            right: 0;</div><div class="line">            height: 1PX;</div><div class="line">            transform-origin: 0 0;</div><div class="line">            transform: scaleY(0.5);</div><div class="line">          &#125; @else if $direction == &apos;right&apos; &#123;</div><div class="line">            right: 0;</div><div class="line">            top: 0;</div><div class="line">            bottom: 0;</div><div class="line">            width: 1PX;</div><div class="line">            transform-origin: 100% 0;</div><div class="line">            transform: scaleX(0.5);</div><div class="line">          &#125; @else if $direction == &apos;bottom&apos; &#123;</div><div class="line">            left: 0;</div><div class="line">            bottom: 0;</div><div class="line">            right: 0;</div><div class="line">            height: 1PX;</div><div class="line">            transform-origin: 0 100%;</div><div class="line">            transform: scaleY(0.5);</div><div class="line">          &#125; @else &#123;</div><div class="line">            left: 0;</div><div class="line">            top: 0;</div><div class="line">            bottom: 0;</div><div class="line">            width: 1PX;</div><div class="line">            transform-origin: 0 0;</div><div class="line">            transform: scaleX(0.5);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @media (min-resolution: 3dppx), (min-resolution: 288dpi) &#123;</div><div class="line">          &amp;:before &#123;</div><div class="line">            @if $direction == &apos;top&apos; &#123;</div><div class="line">              transform: scaleY(0.33);</div><div class="line">            &#125; @else if $direction == &apos;right&apos; &#123;</div><div class="line">              transform: scaleX(0.33);</div><div class="line">            &#125; @else if $direction == &apos;bottom&apos; &#123;</div><div class="line">                transform: scaleY(0.33);</div><div class="line">            &#125; @else &#123;</div><div class="line">              transform: scaleX(0.33);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; @else &#123;</div><div class="line">    border: 1PX solid $color;</div><div class="line">    border-radius: $radius;</div><div class="line"></div><div class="line">    [data-dpr=&quot;1&quot;] &amp; &#123;</div><div class="line">      @media (min-resolution: 2dppx), (min-resolution: 192dpi) &#123;</div><div class="line">        position: relative;</div><div class="line">        border: none;</div><div class="line">        transform: translateZ(0);</div><div class="line"></div><div class="line">        &amp;:before &#123;</div><div class="line">          content: &apos;&apos;;</div><div class="line">          position: absolute;</div><div class="line">          left: 0;</div><div class="line">          top: 0;</div><div class="line">          width: 200%;</div><div class="line">          height: 200%;</div><div class="line">          border: 1PX solid $color;</div><div class="line">          border-radius: $radius * 2;</div><div class="line">          transform-origin: 0 0;</div><div class="line">          transform: scale(0.5);</div><div class="line">          box-sizing: border-box;</div><div class="line">          pointer-events: none;</div><div class="line">          z-index: -1;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@mixin hairline-remove($direction: left) &#123;</div><div class="line">  border-#&#123;$direction&#125;: 0;</div><div class="line">  &amp;:before &#123;</div><div class="line">    display: none !important;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大体的意思是当处理<strong>高清方案的时候</strong>边框线是用的那个<code>border-#{$direction}</code>或者<code>border</code>边框线，然后利用缩放功能来获得细腻的边框线，当在安卓下的时候由伪类来显示那个边框线。</p><p><em>后面的更新的2.0版本，接下来将会进行一些思考和研究。</em></p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> <strong>docEl.firstElementChild 什么情况下会没有写head?</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>地图的显示问题</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>二维码显示问题</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>window.document的<code>readyState</code>和<code>DOMContentLoaded</code>的理解</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>与其它移动端适配方案的比较</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flexible&lt;/a&gt;方案是淘宝的移动端适配方案,相关的文章在&lt;a href=&quot;https://github.com
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="Source" scheme="http://yoursite.com/categories/Tech/Source/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
  </entry>
  
  <entry>
    <title>Gulp work flow</title>
    <link href="http://yoursite.com/2016/12/05/Gulp-work-flow/"/>
    <id>http://yoursite.com/2016/12/05/Gulp-work-flow/</id>
    <published>2016-12-05T01:18:08.000Z</published>
    <updated>2016-12-08T07:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于前端自动化的文章已经有很多，最近，我一直在做这个前端的工程化，说简单一点就是把现有的插件进行整合，从而形成自己的工具集，偶也只是站在巨人的肩膀上^-^.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于前端自动化的文章已经有很多，最近，我一直在做这个前端的工程化，说简单一点就是把现有的插件进行整合，从而形成自己的工具集，偶也只是站在巨人的肩膀上^-^.&lt;/p&gt;

      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="automate" scheme="http://yoursite.com/tags/automate/"/>
    
  </entry>
  
  <entry>
    <title>一些Javascript的习题</title>
    <link href="http://yoursite.com/2016/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Javascript/"/>
    <id>http://yoursite.com/2016/10/16/深入理解Javascript/</id>
    <published>2016-10-16T12:48:29.000Z</published>
    <updated>2016-10-17T05:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>孔子日:学而实习之，不亦乐乎。</p></blockquote><p>在学习前端的道路上有很多的细节，也就是经验是值得去研究的，这不今天就研究了一把对象.且看以下题目：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var president = &#123;name: &apos;bush&apos;&#125;;</div><div class="line">function setName(obj) &#123;</div><div class="line">obj.name = &apos;obama&apos;;</div><div class="line">obj = &#123;name: &apos;clinton&apos;&#125;;</div><div class="line">&#125;</div><div class="line">setName(president);</div></pre></td></tr></table></figure></p><p>请问以上president将为何值?一开始我会想当然地觉得应该输出<code>{name: clinton&#39;}</code>,不过其实是错的，应该是为<code>{name: &#39;obama&#39;}</code>.那么为什么会这样呢？<br>因为对象的创建其实只是创建了一个内存地址来存放里面的内容，也就是说只是创建了一个函数指针。带着这个思考的方法，我又在函数<code>setName</code>里面打印出新创建的对象:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var president = &#123;name: &apos;bush&apos;&#125;;</div><div class="line">function setName(obj) &#123;</div><div class="line">obj.name = &apos;obama&apos;;</div><div class="line">obj = &#123;name: &apos;clinton&apos;&#125;;</div><div class="line">console.log(obj);</div><div class="line">return obj;</div><div class="line">&#125;</div><div class="line">var newPresident = setName(president);</div><div class="line">console.log(president, newPresident);</div></pre></td></tr></table></figure></p><p>返回值是<code>{name: &#39;clinton&#39;}, {name: &#39;obama&#39;}, {name: &#39;clinton&#39;}</code><br>结果，输出如预期，在函数setName里面<code>obj = {name: &#39;clinton&#39;}</code>实际上是创建了一个新的指针来存放新的内容，所以你得返回obj才会看到新建立的对象.<br><strong>以上是自己的思路，欢迎童鞋指正.</strong><br>今天先到这，未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;孔子日:学而实习之，不亦乐乎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习前端的道路上有很多的细节，也就是经验是值得去研究的，这不今天就研究了一把对象.且看以下题目：&lt;br&gt;    &lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>紧凑的生活</title>
    <link href="http://yoursite.com/2016/04/13/%E7%B4%A7%E5%87%91%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2016/04/13/紧凑的生活/</id>
    <published>2016-04-13T14:28:15.000Z</published>
    <updated>2016-04-14T08:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我从上海辞职回老家了，在上海工作期间，最近的这家公司，我基本上早上5点半起床，上个厕所，烧开水，上完厕所喝开水，然后开始做瑜珈，吃苹果和面包，大约6点半出门，7点半左右到公司后再到小卖部喝了点稀饭。</p><p>因为是8点半上班的所以，喝完稀饭后，我会看些自己感兴趣的事情，比如我会看些养生方面的文章，IT技术类的网站比如<a href="https://cnodejs.org" target="_blank" rel="external">cnodejs</a>, <a href="http://fex.baidu.com/" target="_blank" rel="external">百度前端</a>, etc.</p><p>接下来就是开始紧张的工作了。</p><p>晚上回家，大多数时间我都会看会电影。或者看些文章，去跑跑步。</p><p>看起来，我生活得很健康，很紧凑，可是我却感觉到了前所未有的空虚，为什么呢？我问自己，我迷失了自我。没有目标的生活让自己陷于一种光鲜的消沉之路。</p><p>我的家在一座小岛上面，靠捕渔为生，在家的几天，每天母亲都会把美味的饭菜准备好来，因为我身体进行了专门的调理，我比以前要能吃了，不像以前吃了会吐。望着父母满头的白发，这么大年纪了还在努力赚钱为了给我娶媳妇。我心里很内疚。我感觉到了家的温暖，最近这几天，脑海中总是有个声音在告诫我，必须过上紧凑的生活，有目标的生活。</p><blockquote><p>生活不止眼前的苟且还有诗和远方</p></blockquote><p>我应该去探索，应该让自己更加紧凑地生活，目标是让父母不用再为我操劳了。因为我有看过中医方面的理论，所以我觉得5点起床是可以的。</p><ul><li>5点起床,烧开水，上厕所，完后喝水。</li><li>5点半开始yoga，如果假期瑜珈后就跑步</li><li>6点开始吃早餐</li><li>6:15 看新闻</li><li>6点半开始写东西</li><li>如果在假期就在下午打篮球</li><li>晚上看书做项目，如非假期就跑步</li><li>10点半入睡</li></ul><p>先坚持一段时间再说吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，我从上海辞职回老家了，在上海工作期间，最近的这家公司，我基本上早上5点半起床，上个厕所，烧开水，上完厕所喝开水，然后开始做瑜珈，吃苹果和面包，大约6点半出门，7点半左右到公司后再到小卖部喝了点稀饭。&lt;/p&gt;
&lt;p&gt;因为是8点半上班的所以，喝完稀饭后，我会看些自己感兴趣
      
    
    </summary>
    
      <category term="Essays" scheme="http://yoursite.com/categories/Essays/"/>
    
    
      <category term="愉快生活" scheme="http://yoursite.com/tags/%E6%84%89%E5%BF%AB%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
