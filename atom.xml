<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poeticlife</title>
  <subtitle>大知闲闲，小知间间；大言炎炎，小言詹詹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-13T09:25:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Troland</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript-hoisting</title>
    <link href="http://yoursite.com/2017/08/13/JavaScript-hoisting/"/>
    <id>http://yoursite.com/2017/08/13/JavaScript-hoisting/</id>
    <published>2017-08-13T09:24:51.000Z</published>
    <updated>2017-08-13T09:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>变量声明是任何一门语言最基础的一个方面.然而，JavaScript也一点诡异，也就是被称为<em>声明提升</em>,这会导致一个看起来无害的变量声明变成一个微妙的bug.本文将阐述什么是提升声明并且教你如何避免被其困扰。</p>
<p>JavaScript是一门极其灵活的语言，所以可以让你随心所欲地在任何一个地方声明变量。比如，以下的自执行函数声明了三个变量并且之后用警告框来显示它们。需要注意的是，你不应该使用<code>alert</code>警告框,但是我们在这里是试着来验证<code>hoisted</code>而已。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  var bar = 2;</div><div class="line">  var baz = 3;</div><div class="line"></div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>这看起来是平常的JavaScript代码。正如期望的那样，它显示字符串<code>&quot;1 2 3&quot;</code>.现在，假设我们移动<code>alert</code>代码的位置，就像下面这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  var bar = 2;</div><div class="line">  var baz = 3;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>如果有人确实写过这样的代码，有可能是不小心写错的。明显地，弹框会在变量<code>bar</code>和<code>baz</code>声明之前就执行。然而这是完全可用而且不会产生异常的JavaScript代码。然而<code>alert</code>会显示<code>1 undefined undefined</code>。</p>
<p>基于我们之前的试验，JavaScript可以引用未声明的变量。现在，让我们执行相同的自执行函数(IIFE),但是完全移除了<code>baz</code>变量的声明，如下所示。突然间，因为<code>baz</code>变量未定义我们收到一个<code>ReferenceError</code>错误.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  var bar = 2;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<p>这是一个有趣的行为。为了理解这里发生了什么，你得理解提升声明。<code>Hoisting</code>是JavaScript解析器把所有的变量和函数声明移到目前脚本作用范围的顶部的操作(这里的脚本作用范围如果是在函数内部则是函数作用范围,否则是全局范围)然而，只有实际声明的变量才会<code>hoisted</code>.任何赋值都会留在原来的位置。因而，我们的第二段自执行的函数可以转化为以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo;</div><div class="line">  var bar;</div><div class="line">  var baz;</div><div class="line"></div><div class="line">  foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  bar = 2;</div><div class="line">  baz = 3;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>现在你明白了为什么第二个例子不会产生异常。在经过提升声明后，变量<code>bar</code>和<code>baz</code>实际上会在alert语句之前声明，即使是undefined值。在第三个例子中，变量<code>baz</code>被完全移除。这样就没有变量可以用来提升声明,因此alert语句会抛出异常。</p>
<p>另外，需要注意的是如下的代码也是会同样抛出<code>ReferenceError</code>错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar);</div><div class="line">  bar = 2;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure>
<h1 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h1><p>如前所述，函数声明也可以hoisted.然而,<strong>函数表达式不会提升声明</strong>。例如,得益于函数声明提升以下代码会如期正常运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">  alert(&quot;Hello!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，如下示例将肯定会失败。<code>foo</code>变量声明会提升在调用函数之前。然而，因为<code>foo</code>的赋值并没有提升,将会抛出一个由于试图调用一个非函数变量的异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">var foo = function() &#123;</div><div class="line">  alert(&quot;Hello!&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><em>提升声明</em>会影响变量生命周期，它包含了三个步骤:</p>
<ul>
<li>变量声明 - 创建变量。比如<code>var myvar</code></li>
<li>变量初始化 - 给变量赋值。比如<code>myvar = 150</code></li>
<li>访问变量 - 访问并且使用变量的值。比如<code>alert(myvar)</code></li>
</ul>
<p><em>提升声明</em>影响的范围:</p>
<ul>
<li>变量声明: 使用<code>var</code>, <code>let</code>或者<code>const</code>关键字</li>
<li>函数声明: 使用<code>function &lt;name&gt;(){...}</code>语法</li>
<li>类声明: 使用<code>class</code>关键字</li>
</ul>
<h1 id="函数作用域变量"><a href="#函数作用域变量" class="headerlink" title="函数作用域变量"></a>函数作用域变量</h1><p>声明的变量默认值是<code>undefined</code>.代码如下:<br><a href="http://jsbin.com/xizusi/edit?js,console" target="_blank" rel="external">打开Jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Declare num variable</div><div class="line">var num;  </div><div class="line">console.log(num); // =&gt; undefined  </div><div class="line">// Declare and initialize str variable</div><div class="line">var str = &apos;Hello World!&apos;;  </div><div class="line">console.log(str); // =&gt; &apos;Hello World!&apos;</div></pre></td></tr></table></figure>
<h1 id="块作用范围-let"><a href="#块作用范围-let" class="headerlink" title="块作用范围:let"></a>块作用范围:let</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">let声明</a>在块作用范围内声明并且初始化变量:<code>let myvar,myvar2 = &#39;Init&#39;</code>。默认情况下一个声明没初始化的变量拥有<code>undefined</code>值.</p>
<p><em>let</em>是由es6的一个极大的补充，它允许让代码模块化并且封装在块语句范围内.<br><a href="http://jsbin.com/jeyono/edit?js,console" target="_blank" rel="external">打开Jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;  </div><div class="line">  // Declare name block variable</div><div class="line">  let month;  </div><div class="line">  console.log(month); // =&gt; undefined  </div><div class="line">  // Declare and initialize year block variable</div><div class="line">  let year = 1994;  </div><div class="line">  console.log(year); // =&gt; 1994</div><div class="line">&#125;</div><div class="line">// name and year or not accessible here, outside the block</div><div class="line">console.log(year); // ReferenceError: year is not defined</div></pre></td></tr></table></figure>
<h1 id="Hoisting和let"><a href="#Hoisting和let" class="headerlink" title="Hoisting和let"></a>Hoisting和let</h1><p>摘自这篇<a href="https://github.com/getify/You-Dont-Know-JS/issues/767#issuecomment-227946671" target="_blank" rel="external">文章</a>:</p>
<blockquote>
<p>From the code author’s perspective, “declaring” is the var x part and “initializing” is the x = 2 part. But from the perspective of the spec/engine, these shift. “Declaring” is like registering a variable to a scope, “initializing” is reserving space/memory/binding for that variable so it can be used (and giving it its initial undefined value), and “assigning” is giving it a value explicitly in code.</p>
<p>Declaring always happens at time of compilation, and its effect can be seen whenever a scope is first entered. Initializing for var happens at the beginning of the scope, whereas it happens at the site of the declarator for let and const. Initialization is what gives a value its initial undefined value. Assignment then is when you actually use = to assign something to it.</p>
</blockquote>
<p>大概意思是说:在代码的作者看来,<code>声明</code>就是var x部分而<code>初始化</code>是指的x=2.但是从es6文档来看,<br><code>声明</code>是指在作用范围内注册这个变量，<code>初始化</code>是指为变量保留空间/内存/绑定以便它可以被引用(并且赋值它初始值<code>undefined</code>),而<code>赋值</code>是指显式地在代码中赋值。</p>
<p>声明永远发生在编译时，当进入作用域就只可以引用它。var变量的初始化发生在作用范围顶部，而let和const是在声明它们的地方。初始化就是赋值一个未定义的初始值。然后赋值是当你确实用<code>=</code>来赋值。</p>
<p>换句话也就是说，当声明<code>let</code>和<code>const</code>的时候，在它们之前只是进行了变量的注册，而未初始化，所以在<code>let</code>和<code>const</code>之前引用变量会出现<strong>变量引用错误</strong>.</p>
<p><code>let</code>会在块作用范围的顶部注册，但是当变量在声明前被访问会抛出错误：<code>ReferenceError: &lt;variable&gt; is not defined</code>.从变量声明语句到块作用范围的顶部，变量是在一个临时的死区(Temporal Dead Zone, 简称TDZ)并且不能够被访问.请看以下代码:<br><a href="http://jsbin.com/jodegoy/edit?js,console" target="_blank" rel="external">打开jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function isTruthy(value) &#123;  </div><div class="line">  var myVariable = &apos;Value 1&apos;;</div><div class="line">  if (value) &#123;</div><div class="line">    /**</div><div class="line">     * temporal dead zone for myVariable</div><div class="line">     */</div><div class="line"></div><div class="line">    console.log(myVariable);// Throws ReferenceError: myVariable is not defined</div><div class="line">    let myVariable = &apos;Value 2&apos;;</div><div class="line">    // end of temporary dead zone for myVariable</div><div class="line">    console.log(myVariable); // =&gt; &apos;Value 2&apos;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  return false;</div><div class="line">&#125;</div><div class="line">var m = isTruthy(1); // =&gt; true</div><div class="line">console.log(m)</div></pre></td></tr></table></figure>
<p>在<code>myVariable</code>在从<code>let myVariable</code>到块语句<code>if (value) {...}</code>都是临时死区。如果在这个区间访问变量就会抛出一个引用的错误<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-referenceerror" target="_blank" rel="external">ReferenceError</a></p>
<p>但是这里有一个疑问就是说:是否<code>myVariable</code>真的提升变量声明至在块声明语句中的顶,或者只是在临时死区未定义而已？</p>
<p>一个准确的解释是：当引擎遇到一个包含了<code>let</code>语句的块语句之中的时候，这个变量首先会在块语句顶部声明，在声明状态它仍然不能够被访问，但是它覆盖了作用范围外的同名的变量。之后当<code>let myvAR</code>被传值后，变量在初始化状态就可以被使用了。可以查看这个<a href="https://github.com/getify/You-Dont-Know-JS/issues/767#issuecomment-227946671" target="_blank" rel="external">解释</a></p>
<h1 id="常量-const"><a href="#常量-const" class="headerlink" title="常量:const"></a>常量:const</h1><p>常量<code>const</code>会在块语句顶部被注册。由于<em>临时死区</em>常量不能够在声明之前被访问.<br><code>const</code>提升声明和<code>let</code>语句一致的行为<br>比如以下代码:<br><a href="http://jsbin.com/desugig/edit?js,console" target="_blank" rel="external">打开jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function double(number) &#123;  </div><div class="line">   // temporal dead zone for TWO constant</div><div class="line">   console.log(TWO); // ReferenceError: TWO is not defined</div><div class="line">   const TWO = 2;</div><div class="line">   // end of temporal dead zone</div><div class="line">   return number * TWO;</div><div class="line">&#125;</div><div class="line">double(5); // =&gt; 10</div></pre></td></tr></table></figure>
<h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_declarations" target="_blank" rel="external">类声明</a>定义了一个包含了名字的构造函数和方法。类声明是ES6的一个很好的补充。类是建立在JavaScript原型继承之上的并且拥有一些其它的优点比如<code>super</code>(用来访问父类），<code>static</code>（用来定义静态方法）,<code>extends</code>(定义子类)还有其它。<br>一个类声明如下:<br><a href="http://jsbin.com/doqelut/edit?js,console" target="_blank" rel="external">打开jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Point &#123;  </div><div class="line">   constructor(x, y) &#123;</div><div class="line">     this.x = x;</div><div class="line">     this.y = y;     </div><div class="line">   &#125;</div><div class="line">   move(dX, dY) &#123;</div><div class="line">     this.x += dX;</div><div class="line">     this.y += dY;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">// Create an instance</div><div class="line">var origin = new Point(0, 0);  </div><div class="line">// Call a method</div><div class="line">origin.move(50, 100);</div></pre></td></tr></table></figure>
<p>如果在类声明之前访问类就会引发错误，JavaScript会抛出<code>ReferenceError: &lt;name&gt; is not defined</code>的错误。<br>如下代码:<br><a href="http://jsbin.com/budopew/edit?js,console" target="_blank" rel="external">打开jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Use the Company class</div><div class="line">// Throws ReferenceError: Company is not defined</div><div class="line">var apple = new Company(&apos;Apple&apos;);  </div><div class="line">// Class declaration</div><div class="line">class Company &#123;  </div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;    </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// Use correctly the Company class after declaration</div><div class="line">var microsoft = new Company(&apos;Microsoft&apos;);</div></pre></td></tr></table></figure>
<p>也可以用类表达式的方式来创建类。<br>代码如下:<br><a href="http://jsbin.com/vumomeq/edit?js,console" target="_blank" rel="external">打开jsbin</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Use the Sqaure class</div><div class="line">console.log(typeof Square);   // =&gt; &apos;undefined&apos;  </div><div class="line">//Throws TypeError: Square is not a constructor</div><div class="line">var mySquare = new Square(10);  </div><div class="line">// Class declaration using variable statement</div><div class="line">var Square = class &#123;  </div><div class="line">  constructor(sideLength) &#123;</div><div class="line">    this.sideLength = sideLength;    </div><div class="line">  &#125;</div><div class="line">  getArea() &#123;</div><div class="line">    return Math.pow(this.sideLength, 2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">// Use correctly the Square class after declaration</div><div class="line">var otherSquare = new Square(5);</div></pre></td></tr></table></figure>
<p>因为<code>Square</code>类声明提升到作用域的顶端，在类声明行之前都是<code>undefined</code>的值，所以当在类声明之前用<code>var mySquare = new Square(10)</code>会导致JavaScript抛出错误<code>TypeError: Square is not a constructor</code>.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>Hoisting</code>很容易理解，但是是经常忽视了JavaScript语言的细微差别。没有清晰地理解提升声明，你的程序将会容易受微妙bug的影响.为了帮助解决这个问题，很多开发者（和linting语法校验工具）主张在每个脚本作用范围的顶端单独写变量声明的语句。因为本质上这是JavaScript解析器如何解析你的代码，这条规则是有效的-即使我会因为打破这条规则而内疚。<br>有一个地方就是关于函数的提升声明，如果当程序员想要在源文件的顶部知道函数是如何调用的而不用滚动到函数声明的地方去查看函数的详细实现细节，例如<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#bindable-members-up-top" target="_blank" rel="external">看这里</a>来查看这种技术是如何增加了<em>Angular</em>控制器的可读成性的.</p>
<p>以上文字译自<a href="https://www.sitepoint.com/back-to-basics-javascript-hoisting/" target="_blank" rel="external">Back to Basics: JavaScript Hoisting</a>和<a href="https://rainsoft.io/javascript-hoisting-in-details/" target="_blank" rel="external">javascript-hoisting-in-details</a>,文字方面有进行过相关的缩略。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;变量声明是任何一门语言最基础的一个方面.然而，JavaScript也一点诡异，也就是被称为&lt;em&gt;声明提升&lt;/em&gt;,这会导致一个看起来无害的变量声明变成一个微妙的bug.本文将阐述什么是提升声明并且教你如何避免被其困扰。&lt;/p&gt;
&lt;p&gt;JavaScript是一门极其灵活的
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="Hoisting" scheme="http://yoursite.com/tags/Hoisting/"/>
    
  </entry>
  
  <entry>
    <title>NodeClub源码解析</title>
    <link href="http://yoursite.com/2017/08/10/NodeClub%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/10/NodeClub源码解析/</id>
    <published>2017-08-10T13:42:20.000Z</published>
    <updated>2017-08-10T13:42:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS组件库</title>
    <link href="http://yoursite.com/2017/08/10/CSS%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/10/CSS组件库/</id>
    <published>2017-08-10T13:38:17.000Z</published>
    <updated>2017-08-10T13:38:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Token-based-auth</title>
    <link href="http://yoursite.com/2017/08/10/Token-based-auth/"/>
    <id>http://yoursite.com/2017/08/10/Token-based-auth/</id>
    <published>2017-08-10T13:37:13.000Z</published>
    <updated>2017-08-13T09:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在前后端分离如火如荼，传统的基于<strong>cookie的认证</strong>也有诸多不便。就目前自己所知有如下限制：</p>
<ul>
<li><p>首先，按照传统的基于cookie的认证，基于cookie的认证即服务器通过保存于客户端中的<strong>sessionid</strong>标识符来识别用户, 服务器必须得维持一份认证的状态。那么为了持久化session即在当服务器宕机或者转移的情况下，可以保证当服务器恢复之后，客户端访问不需要再次登录。这样会增加服务器开销而如今的<em>API DESIGN</em>是围绕着api来进行设计的,<strong>restful设计</strong>,请允许我咬文嚼字一下，restful即无状态服务吧^-^.</p>
</li>
<li><p>第二，有的应用场景下并未支持cookie,这个时候的解决方案有:采用url重写，表单隐藏域。我没弄过url重写，表单隐藏域也没弄过，真抱歉。对了，在微信端的时候关于用户的识别，由于微信是没支持cookie的所以需要自己实现一下session,可以利用openid来作为唯一标识，因为openid是唯一的具体可以参见<a href="https://github.com/node-webot/wechat/blob/master/lib/session.js" target="_blank" rel="external">node-webot</a>的session实现。</p>
</li>
<li><p>第三, api服务器往往会部署在另一台服务器上面，这样会造成浏览器的跨域，所以这个时候的解决办法是服务器端需要进行跨域的设置。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With, accept, content-type, xxxx&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:8010&quot;);//这里必须指定地址而不能写成星号否则浏览器会提示不能为星号</div></pre></td></tr></table></figure>
<p>然后前端的ajax请求库中必须设置<code>withCredentials</code>为<code>true</code>。<s>然而基于token的认证并无跨域问题</s>。</p>
<p>那么基于token的认证用到的主要有以下插件:</p>
<ul>
<li><a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="external">bcrypt</a> 加盐哈希密码用，有效抵御彩虹攻击。</li>
<li><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="external">jsonwebtoken</a> 用来生成符合<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">JSON WEB Tokens</a>标准的令牌</li>
<li><a href="https://www.npmjs.com/package/express-jwt" target="_blank" rel="external">express-jwt</a> 用来验证JsonWebTokens的中间件</li>
<li><a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">crypto-js</a> 前后端密码加密</li>
</ul>
<p>关于JsonWebToken可以参考这个<a href="https://jwt.io/" target="_blank" rel="external">网站</a>。</p>
<p>项目是采用express-generator构建的。<code>npm i -g express-generator</code>即可。</p>
<p><em>express-jwt默认是检查请求头中的<code>authorization</code>字段来进行token的验证的但是也可以进行自定义获取token的方法</em>。然后会把相关的用户信息存储在<code>req.user</code>中。<br>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.use(jwt(&#123;</div><div class="line">  secret: &apos;hello world !&apos;,</div><div class="line">  credentialsRequired: false, // 未注册的用户也可访问</div><div class="line">  getToken: function fromHeaderOrQuerystring (req) &#123;</div><div class="line">    // 从头部信息获取或者在url上类似?token=adadfs这样获取</div><div class="line">    if (req.headers.authorization &amp;&amp; req.headers.authorization.split(&apos; &apos;)[0] === &apos;Bearer&apos;) &#123;</div><div class="line">        return req.headers.authorization.split(&apos; &apos;)[1]</div><div class="line">    &#125; else if (req.query &amp;&amp; req.query.token) &#123;</div><div class="line">      return req.query.token</div><div class="line">    &#125;</div><div class="line">    return null</div><div class="line">  &#125;</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>下面贴出主要的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/login&apos;, function(req, res) &#123;</div><div class="line">  let userName = req.body.username</div><div class="line">  let password = entities.encode(req.body.password)</div><div class="line">  // find user</div><div class="line">  conn.query(&apos;SELECT * FROM user WHERE user_name = ?&apos;, [</div><div class="line">    userName</div><div class="line">  ], function (err, results, fields) &#123;</div><div class="line">    if (!err) &#123;</div><div class="line">      let user = results[0]</div><div class="line">      // validate password</div><div class="line">      bcrypt.compare(password, user.password, function (err, result) &#123;</div><div class="line">        console.log(user)</div><div class="line">        if (result) &#123;</div><div class="line">        // Dispatch token expired after 2mins for client</div><div class="line">          let token = jwt.sign(&#123; user_name: user.user_name &#125;, secret, &#123; expiresIn: 60 * 2 &#125;)</div><div class="line">          res.json(&#123;</div><div class="line">            code: &apos;0&apos;,</div><div class="line">            token: token</div><div class="line">          &#125;)</div><div class="line">        &#125; else &#123;</div><div class="line">          res.json(&#123;</div><div class="line">            code: &apos;1&apos;,</div><div class="line">            error: &apos;用户不存在&apos;</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">      res.json(&#123;</div><div class="line">        code: &apos;2&apos;,</div><div class="line">        error: &apos;用户不存在&apos;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当用户登录的时候检测用户输入的用户名密码是否正确。如果正确则派发出token并在2分钟之后让其过期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// protected api</div><div class="line">app.all(&apos;/api/*&apos;, jwtVerify(&#123;secret: secret&#125;), function(err, req, res, next) &#123;</div><div class="line">  // 当令牌过期则返回401否则通过</div><div class="line">  if (err.name === &apos;UnauthorizedError&apos;) &#123;</div><div class="line">    res.status(401).send(&apos;Invalid token...&apos;)</div><div class="line">  &#125;</div><div class="line">  next()</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后再在所需要验证的api下使用中间件进行验证，当令牌过期则返回401。</p>
<p>以上就是主要的代码了，那么这里的话可以看到，完全是无状态的即真正的restful(休息ful哈哈，就是无状态嘛），服务端无需专门维护登录的用户状态信息，也省去维护的开销。</p>
<p>代码可见<a href="https://github.com/Troland/token-based-auth" target="_blank" rel="external">这里</a>。</p>
<p>可是这样做，会不会有什么问题呢？</p>
<p>Todolist:</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 登录次数限制</li>
<li style="list-style: none"><input type="checkbox"> 安全检测</li>
<li style="list-style: none"><input type="checkbox" checked> 权限控制</li>
<li style="list-style: none"><input type="checkbox"> 用户注册进行严格的密码字符的控制</li>
</ul>
<hr>
<p>2017.8.13</p>
<h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>现在由于有好些都是前后端分离的项目所以会出现跨域的问题，关于跨域的问题网上已有很多，这里不再赘述。这里只提供些方法:</p>
<ul>
<li>现在前后端分离，往往是后端作为API Server,然后关于前端的静态资源会走其它服务器。比如nginx配置成当请求数据服务器的时候导向后端的tomcats。</li>
</ul>
<p>举例如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">http</div><div class="line">&#123;</div><div class="line">  upstream tomcats</div><div class="line">  &#123;</div><div class="line">    server 127.0.0.1:9001;</div><div class="line">    server 127.0.0.1:9002;</div><div class="line">  &#125;</div><div class="line">  server &#123;</div><div class="line">      listen       8000;</div><div class="line">      server_name  localhost;</div><div class="line"></div><div class="line">      # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回</div><div class="line">      try_files $uri $uri/index.html;</div><div class="line">      location ^/(js|css|image|font)/ &#123;</div><div class="line">        # 静态资源都在 static 文件夹下</div><div class="line">        root /abc/static/;</div><div class="line">      &#125;</div><div class="line">      #charset koi8-r;</div><div class="line"></div><div class="line">      #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">      location / &#123;</div><div class="line">          root   /pathtoroot;</div><div class="line">          index  index.html index.htm;</div><div class="line">      &#125;</div><div class="line">      error_page  404              /404.html;</div><div class="line"></div><div class="line">      location /api &#123;</div><div class="line">          proxy_set_header X-Real-IP $remote_addr;</div><div class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">          proxy_set_header Host $http_host;</div><div class="line">          proxy_set_header X-NginX-Proxy true;</div><div class="line">          proxy_pass http://tomcats;</div><div class="line">          proxy_redirect off;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当请求的是静态资源的时候就会指向nginx指定的目录，当是请求的api的时候会指向tomcat集群</p>
<ul>
<li>服务器配置允许跨域</li>
</ul>
<p>如果是<code>node</code>的话可以去加载<a href="https://www.npmjs.com/package/cors" target="_blank" rel="external">cors</a>包。示例代码码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 当跨域配置用cors插件</div><div class="line">const cors = require(&apos;cors&apos;)</div><div class="line">// 设置白免单可以指定允许多个ip源访问</div><div class="line">const whitelist = [</div><div class="line">  &apos;http://192.168.1.139:3003&apos;,</div><div class="line">  &apos;http://192.168.1.139:3100&apos;</div><div class="line">]</div><div class="line">const corsOptions = &#123;</div><div class="line">  origin: (origin, callback) =&gt; &#123;</div><div class="line">    if (whitelist.indexOf(origin) !== -1) &#123;</div><div class="line">      callback(null, true)</div><div class="line">    &#125; else &#123;</div><div class="line">      callback(new Error(&apos;Not allowed by CORS&apos;))</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  credentials: true, //这里必须写这样才能够接收到header里面的cookie,若不需要获得cookie可不设置</div><div class="line">  optionsSuccessStatus: 200, // some legacy browsers (IE11, various SmartTVs) choke on 204</div><div class="line">  methods: &apos;GET,HEAD,PUT,PATCH,POST,DELETE&apos;</div><div class="line">&#125;</div><div class="line">const app = express()</div><div class="line"></div><div class="line">app.use(cors(corsOptions))</div><div class="line"></div><div class="line">app.post(&apos;/api/num&apos;, function (req, res) &#123;</div><div class="line">  // 假设头是request.setRequestHeader(&apos;Authorization&apos;, &apos;Bearer &apos; + token);</div><div class="line">  req.get(&apos;authorization&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>引用<a href="https://www.npmjs.com/package/express-jwt-permissions" target="_blank" rel="external">express-jwt-permissions</a>。<br>你可以全局使用这个权限的检查也可以只为某些受保护的资源进行权限控制，例如：</p>
<p>全局使用:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const guard = require(&apos;express-jwt-permissions&apos;)()</div><div class="line">guard.check(&apos;admin&apos;)</div></pre></td></tr></table></figure>
<p>为受保护资源进行权限控制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/api/user&apos;, guard.check(&apos;status1&apos;), function (req, res) &#123;</div><div class="line">  console.log(&apos;Permissions:&apos;, req.user)</div><div class="line">  res.json(&#123;</div><div class="line">    code: 200,</div><div class="line">    username: &apos;tristan&apos;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>那么这里的<code>permission</code>是从哪来的呢？<br>首先用户注册，会获得默认的权限值, 或者由超级管理员进行注册生成用户。然后，超级管理员为用户设置权限。生成用户对应的<code>permission</code>值。</p>
<p>代码可见<a href="https://github.com/Troland/permission" target="_blank" rel="external">这里</a>。</p>
<p>Todolist:</p>
<ul>
<li style="list-style: none"><input type="checkbox"> <strong>那么当项目是否是前后端分离的时候，这个权限应该如何控制会是最优解呢？</strong></li>
</ul>
<p>且听下回分解^.^。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在前后端分离如火如荼，传统的基于&lt;strong&gt;cookie的认证&lt;/strong&gt;也有诸多不便。就目前自己所知有如下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，按照传统的基于cookie的认证，基于cookie的认证即服务器通过保存于客户端中的&lt;strong&gt;sess
    
    </summary>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
      <category term="jsonwebtoken" scheme="http://yoursite.com/tags/jsonwebtoken/"/>
    
  </entry>
  
  <entry>
    <title>CSS常用库</title>
    <link href="http://yoursite.com/2017/08/10/CSS%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/10/CSS常用库/</id>
    <published>2017-08-10T13:35:14.000Z</published>
    <updated>2017-08-10T13:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>input的line-height样式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.input &#123;</div><div class="line">  width: 100px;</div><div class="line">  line-height: 1.8;</div><div class="line">  font-size: 18px;</div><div class="line">  box-sizing: border-box;</div><div class="line">  padding: 5px;</div><div class="line">  border: 1px solid #f00;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样输入文字居中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;input的line-height样式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap scrollspy 源码解读</title>
    <link href="http://yoursite.com/2017/08/06/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/06/源码解读/</id>
    <published>2017-08-06T07:35:13.000Z</published>
    <updated>2017-08-06T15:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：</p>
<p>功能需求:</p>
<ul>
<li>当点击导航栏的时候会显示对应的内容块到顶部。</li>
<li>当页面滚动的时候，当到达对应导航的内容块，则会激活导航。</li>
</ul>
<p><strong>需要注意的是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动，从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets，这个时候就需要调用refresh方法进行重新计算offsets和targets。</strong></p>
<p>Bootstrap scrollspy源码解读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">this.$scrollElement: 滚动的容器</div><div class="line">this.selector: 导航选择器</div><div class="line">this.targets: 导航的元素</div><div class="line">this.activeTarget: 激活状态的导航元素</div><div class="line">this.offsets: 内容块元素的在页面中的位移</div><div class="line">*/</div><div class="line">function ScrollSpy(element, options) &#123;</div><div class="line">    this.$body          = $(document.body)</div><div class="line">    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)</div><div class="line">    this.options        = $.extend(&#123;&#125;, ScrollSpy.DEFAULTS, options)</div><div class="line">    this.selector       = (this.options.target || &apos;&apos;) + &apos; .nav li &gt; a&apos;</div><div class="line">    this.offsets        = []</div><div class="line">    this.targets        = []</div><div class="line">    this.activeTarget   = null</div><div class="line">    this.scrollHeight   = 0</div><div class="line"></div><div class="line">    this.$scrollElement.on(&apos;scroll.bs.scrollspy&apos;, $.proxy(this.process, this))</div><div class="line">    this.refresh()</div><div class="line">    this.process()</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>首先在<code>ScrollSpy</code>构造函数中,先获得滚动容器，导航选择器等，然后调用<code>refresh</code>和<code>process</code>函数来初始化实例。<br>获得容器的内容高度<code>scrollHeight</code>,<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">scrollHeight</a>。<br>并绑定滚动容器的滚动事件为<code>this.process</code>。</p>
<p>再来看<code>refresh</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.refresh = function () &#123;</div><div class="line">    var that          = this</div><div class="line">    var offsetMethod  = &apos;offset&apos;</div><div class="line">    var offsetBase    = 0</div><div class="line">    </div><div class="line">    this.offsets      = []</div><div class="line">    this.targets      = []</div><div class="line">    this.scrollHeight = this.getScrollHeight()</div><div class="line">    </div><div class="line">    /*判断滚动窗口是否为body*/</div><div class="line">    if (!$.isWindow(this.$scrollElement[0])) &#123;</div><div class="line">      offsetMethod = &apos;position&apos;</div><div class="line">      offsetBase   = this.$scrollElement.scrollTop()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    this.$body</div><div class="line">      .find(this.selector)</div><div class="line">      .map(function () &#123;</div><div class="line">        var $el   = $(this)</div><div class="line">        var href  = $el.data(&apos;target&apos;) || $el.attr(&apos;href&apos;)</div><div class="line">        var $href = /^#./.test(href) &amp;&amp; $(href)</div><div class="line">    </div><div class="line">        return ($href</div><div class="line">          &amp;&amp; $href.length</div><div class="line">          &amp;&amp; $href.is(&apos;:visible&apos;)</div><div class="line">          &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null</div><div class="line">      &#125;)</div><div class="line">      .sort(function (a, b) &#123; return a[0] - b[0] &#125;)</div><div class="line">      .each(function () &#123;</div><div class="line">        that.offsets.push(this[0])</div><div class="line">        that.targets.push(this[1])</div><div class="line">      &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里的意思是设置实例的内容块的offsets和导航栏的targets,并按升序排列。</p>
<p>接下来是<code>process</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scrollTop: 元素已经滚动的距离加上距离顶部的距离</div><div class="line">maxScroll: 滚动容器可滚动距离</div><div class="line">activeTarget: 当前激活的导航元素</div><div class="line"></div><div class="line">*/</div><div class="line">ScrollSpy.prototype.process = function () &#123;</div><div class="line">    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset</div><div class="line">    var scrollHeight = this.getScrollHeight()</div><div class="line">    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()</div><div class="line">    var offsets      = this.offsets</div><div class="line">    var targets      = this.targets</div><div class="line">    var activeTarget = this.activeTarget</div><div class="line">    var i</div><div class="line">    </div><div class="line">    /*</div><div class="line">    这里的意思是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动</div><div class="line">    从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets</div><div class="line">    */</div><div class="line">    if (this.scrollHeight != scrollHeight) &#123;</div><div class="line">      this.refresh()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /*</div><div class="line">    当滚动距离超过最大可滚动距离，并且activeTarget和最后一个激活元素地址不一致则激活最后一级导航</div><div class="line">    */</div><div class="line">    if (scrollTop &gt;= maxScroll) &#123;</div><div class="line">      return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     当滚动距离小于offsets中的第一个并且有激活的导航的时候就不激活导航</div><div class="line">    */</div><div class="line">    if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) &#123;</div><div class="line">      this.activeTarget = null</div><div class="line">      return this.clear()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (i = offsets.length; i--;) &#123;</div><div class="line">      activeTarget != targets[i]</div><div class="line">        &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">        &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">        &amp;&amp; this.activate(targets[i])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (i = offsets.length; i--;) &#123;</div><div class="line">  activeTarget != targets[i]</div><div class="line">    &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">    &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">    &amp;&amp; this.activate(targets[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前激活的导航和targets数组一一比对如果不是当前激活导航则再比对，注意到这里的比对是<em>从位移数组的最后一个开始倒序进行比对的</em>, 然后当滚动距离大于位移数组的当前并且小于下一个，或者位移数组的最后一个不存在，即为最后一个导航的时候。则激活目标导航。当然这里也有性能优化的意思，然后倒序来比较有一个好处就是，如果是升序比较就得计算那个<em>内容元素的高度来进行比较</em>，但是倒序则不用。</p>
<p>疑问:</p>
<ul>
<li>为什么当滚动容器是body的时候<code>offsetMethod</code>为<em>offset</em>非<code>body</code>的时候为<em>position</em>?</li>
</ul>
<p>因为当滚动容器为body的时候就得计算元素在body上面的位移，而如果非body的话就在滚动容器里面比如<br><code>&lt;div class=&quot;scroll-container&quot;&gt;&lt;/div&gt;</code>当滚动的内容在里面的时候得设置滚动容器的样式<code>position: relative</code>。<br>当设置为<code>position</code>的时候里面的内容元素即为相对于此容器的位移而不是相对于<code>body</code>。</p>
<p>接下来是激活导航的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.activate = function (target) &#123;</div><div class="line">  this.activeTarget = target</div><div class="line">  </div><div class="line">  this.clear()</div><div class="line"></div><div class="line">  var selector = this.selector +</div><div class="line">    &apos;[data-target=&quot;&apos; + target + &apos;&quot;],&apos; +</div><div class="line">    this.selector + &apos;[href=&quot;&apos; + target + &apos;&quot;]&apos;</div><div class="line"></div><div class="line">  var active = $(selector)</div><div class="line">    .parents(&apos;li&apos;)</div><div class="line">    .addClass(&apos;active&apos;)</div><div class="line">   </div><div class="line">  // 若激活的导航的父元素有dropdown-men类则为其</div><div class="line">  if (active.parent(&apos;.dropdown-menu&apos;).length) &#123;</div><div class="line">    active = active</div><div class="line">      .closest(&apos;li.dropdown&apos;)</div><div class="line">      .addClass(&apos;active&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  active.trigger(&apos;activate.bs.scrollspy&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>疑问：<br>这里为什么要用<code>parents</code>?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var active = $(selector)</div><div class="line">          .parents(&apos;li&apos;)</div><div class="line">          .addClass(&apos;active&apos;)</div></pre></td></tr></table></figure>
<p>清除激活状态导航的激活状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.clear = function () &#123;</div><div class="line">    $(this.selector)</div><div class="line">      .parentsUntil(this.options.target, &apos;.active&apos;)</div><div class="line">      .removeClass(&apos;active&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>疑问:</p>
<ul>
<li>当那些导航是异步请求加载出来的，这个时候应该如何做？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：&lt;/p&gt;
&lt;p&gt;功能需求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当点击导航栏的时候会显示对应的内容块到顶部。&lt;/li&gt;
&lt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="scrollSpy" scheme="http://yoursite.com/tags/scrollSpy/"/>
    
      <category term="offset" scheme="http://yoursite.com/tags/offset/"/>
    
      <category term="position" scheme="http://yoursite.com/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>二维码登录</title>
    <link href="http://yoursite.com/2017/07/21/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2017/07/21/二维码登录/</id>
    <published>2017-07-21T01:21:16.000Z</published>
    <updated>2017-07-21T01:21:16.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用CSS3详解</title>
    <link href="http://yoursite.com/2017/06/18/%E5%B8%B8%E7%94%A8CSS3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/06/18/常用CSS3详解/</id>
    <published>2017-06-18T15:24:15.000Z</published>
    <updated>2017-07-22T13:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理CSS3的属性的原理，特意分享一下个人的一些理解。</p>
<h2 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h2><p><code>transform-origin</code>是改变一个元素的变形的原点通常是和<code>transform</code>一起使用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin" target="_blank" rel="external">transform-origin</a> MDN上说明:</p>
<blockquote>
<p>transform-origin CSS属性让你更改一个元素变形的原点。例如，rotate()的transform-origin 是旋转的中心点 (这个属性的应用原理是先用这个属性的负值translate该元素，进行变形，然后再用这个属性的值把元素translate回去)。</p>
</blockquote>
<p>假设有以下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.grid &#123;</div><div class="line"> transform: rotate(30deg);</div><div class="line"> transform-origin: 70% 50%;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>transform-origin</code>属性的默认值是<code>50% 50%</code>。等于是<strong>放置的中心点水平移动到70%移动了20%</strong>,为了保持旋转的角度仍旧为30deg,这个时候元素必须往上移动，否则那个旋转的角度将会变大。</p>
<p>如下图所示：<br><img src="/images/css-transform-origin.png" alt=""></p>
<p>可以玩一下<a href="http://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html" target="_blank" rel="external">w3Ctransform-origin演示地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在整理CSS3的属性的原理，特意分享一下个人的一些理解。&lt;/p&gt;
&lt;h2 id=&quot;transform-origin&quot;&gt;&lt;a href=&quot;#transform-origin&quot; class=&quot;headerlink&quot; title=&quot;transform-origin&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>ES6碎碎念</title>
    <link href="http://yoursite.com/2017/06/11/ES6%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/06/11/ES6碎碎念/</id>
    <published>2017-06-11T13:51:31.000Z</published>
    <updated>2017-08-13T02:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习和使用<em>ES6</em>了, 下面是自己的一些使用心得:</p>
<h2 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h2><p>隐蔽死区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function bar(x = y, y = 2) &#123;</div><div class="line">  return [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line">bar() // 报错</div></pre></td></tr></table></figure>
<p><code>x</code>默认值等于另一个参数<code>y</code>， <code>y</code>还没声明，属于死区.</p>
<p>ES6支付宝临时性死区和<code>let</code>, <code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量。</p>
<p>不能在函数内部重新声明参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func(arg) &#123;</div><div class="line">	let args; // 报错</div><div class="line">&#125;</div><div class="line"></div><div class="line">function func(arg) &#123;</div><div class="line">	&#123;</div><div class="line">		let arg; // 不报错</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function f1() &#123;</div><div class="line">	let n = 5;</div><div class="line">	if (true) &#123;</div><div class="line">		let n = 10;</div><div class="line">	&#125;</div><div class="line">	console.log(n); // 5</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码表示外层代码块不受内层代码块的影响。<br>ES6 允许块级作用域任意嵌套。<br>块级作用域的出现，使得广泛使用的立即执行函数表达式（IIFE）不再必要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">	var tmp = ...;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 块级作用域</div><div class="line">&#123;</div><div class="line">  let tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>为了兼容老代码函数声明。浏览器实现可以不遵守块级作用域内声明的函数类似于<code>let</code>的规定。</p>
<ul>
<li>允许在块级作用域内声明函数</li>
<li>函数声明类似于<code>var</code>,即会提升到全局作用域或函数作用域的头部</li>
<li>同时，函数声明还会提升到所在块级作用域的头部</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 浏览器的 ES6 环境</div><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line">  if (false) &#123;</div><div class="line">    // 重复声明一次函数f</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div><div class="line">// Uncaught TypeError: f is not a function</div></pre></td></tr></table></figure>
<p>实际运行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 浏览器的 ES6 环境</div><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  var f = undefined;</div><div class="line">  if (false) &#123;</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div><div class="line">// Uncaught TypeError: f is not a function</div></pre></td></tr></table></figure>
<p>考虑到环境导致的行为差异太大，应避免在块级作用域内声明函数。如果确实需要，也应写成函数表达式，而不是函数声明语句。</p>
<p><code>const</code>只声明不赋值也会报错。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存不得改动。对于简单类型的数据(数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据(对象和数组),变量指向的内存地址，保存的只是一个指针。<code>const</code>仅保证这个指针固定，上面的值却不能够保证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line"></div><div class="line">// 赋值</div><div class="line">foo.a = 123;</div><div class="line">foo.a // 123</div><div class="line"></div><div class="line">// 将foo指向另一个对象，报错</div><div class="line">foo = &#123;&#125;; // Uncaught TypeError: Assignment to constant variable</div></pre></td></tr></table></figure>
<p>想将对象冻结使用<code>Object.freeze</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;&#125;);</div><div class="line"></div><div class="line">// 常规模式时，下面一行不起作用；</div><div class="line">// 严格模式时，该行会报错</div><div class="line">foo.prop = 123;</div></pre></td></tr></table></figure>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p><code>var</code>命令和<code>function</code>命令声明的全局变量,依旧是顶层对象的属性,另一方面,<code>let</code>,<code>const</code>,<code>class</code>命令声明的全局变量不属于顶层对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">// 如果在Node的REPL环境，可以写成global.a</div><div class="line">// 或者采用通用方法，写成this.a</div><div class="line">window.a // 1</div><div class="line"></div><div class="line">let b = 1;</div><div class="line">window.b // undefined</div></pre></td></tr></table></figure>
<h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>ES5的顶层对象，在不同环境里面不一样.</p>
<ul>
<li>浏览器是<code>window</code>, 但Node和Web Worker没有<code>window</code></li>
<li>浏览器和Web Worker里面，<code>self</code>也指向顶层对象,但是Node没有<code>self</code></li>
<li>Node里面，顶层对象是<code>global</code>,但其它环境都不支持</li>
</ul>
<p>同一段代码为了能在各种环境中都取到顶层对象，一般使用<code>this</code>变量。</p>
<ul>
<li>全局环境中，<code>this</code>会返回顶层对象, 但Node模块和ES6模块，<code>this</code>返回当前模块</li>
<li>函数里面的<code>this</code>, 如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这是<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<p>两种方法可以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">(typeof window !== &apos;undefined&apos;</div><div class="line">   ? window</div><div class="line">   : (typeof process === &apos;object&apos; &amp;&amp;</div><div class="line">      typeof require === &apos;function&apos; &amp;&amp;</div><div class="line">      typeof global === &apos;object&apos;)</div><div class="line">     ? global</div><div class="line">     : this);</div><div class="line"></div><div class="line">// 方法二</div><div class="line">var getGlobal = function () &#123;</div><div class="line">  if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125;</div><div class="line">  if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125;</div><div class="line">  if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125;</div><div class="line">  throw new Error(&apos;unable to locate global object&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>有一个提案引入<code>global</code>作为顶层对象，这样所有环境下<code>global</code>都存在。<br><a href="https://github.com/ljharb/System.global" target="_blank" rel="external">system.global</a>模拟了这个提案可以在所有环境中拿到<code>global</code>.</p>
<h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>Object.assign(target, source1, source2)只会将源对象的枚举的属性拷贝到目标对象上。只拷贝源对象自身属性，不拷贝不可枚举属性。</p>
<p>Symbol属性也会被Object.assign拷贝。</p>
<p>尽量使用<code>Object.keys()</code>来循环对象自身的属性。</p>
<p><code>Object.getPrototypeOf()</code>获取对象的原型对象。<br><code>Object.setPrototypeOf()</code>设置对象的原型对象。</p>
<p>…用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let z = &#123; a: 3, b: 4 &#125;;</div><div class="line">let n = &#123; ...z &#125;;</div><div class="line">n // &#123; a: 3, b: 4 &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始学习和使用&lt;em&gt;ES6&lt;/em&gt;了, 下面是自己的一些使用心得:&lt;/p&gt;
&lt;h2 id=&quot;let与const&quot;&gt;&lt;a href=&quot;#let与const&quot; class=&quot;headerlink&quot; title=&quot;let与const&quot;&gt;&lt;/a&gt;let与const&lt;/h2&gt;
    
    </summary>
    
      <category term="ES2015" scheme="http://yoursite.com/categories/ES2015/"/>
    
    
  </entry>
  
  <entry>
    <title>Nodejs碎碎念</title>
    <link href="http://yoursite.com/2017/06/08/Nodejs%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/06/08/Nodejs碎碎念/</id>
    <published>2017-06-08T14:21:01.000Z</published>
    <updated>2017-08-10T13:41:29.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Session与Cookie小结</title>
    <link href="http://yoursite.com/2017/05/20/Session%E4%B8%8ECookie%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/20/Session与Cookie小结/</id>
    <published>2017-05-20T03:57:05.000Z</published>
    <updated>2017-08-10T13:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学session与cookie相关的内容，有以下几点疑点：</p>
<ul>
<li>Session存储在哪？</li>
<li>记住密码功能及相关的bug</li>
<li>Session持久化</li>
<li>如果在cookie中保存那个登录信息应该保存些信息？</li>
</ul>
<p>当为检查是否已经登录是通过检查<code>req.session</code>还是通过<code>req.cookies[&#39;isLogged&#39;]</code>,这两者有区别吗？过期时间都是一致的吗？</p>
<p>登录流程:</p>
<ul>
<li>登录系统，填写用户名和密码，后端检测用户名和密码，成功则设置一个登录的cookie</li>
<li>这个sessid标识符和token应该是随机的值，且都在表中，就应该那个数据库表tokens应该是一个sessid标识符对应一个token吧，然后这个token应该是个哈希值</li>
<li><p>最后当未从登录页登录的用户并且有一个登录的cookie的时候:</p>
<ul>
<li>首先判断那个sessionid存在并且从表中查找到这个sessid对应的hash了的token，则判断为认证通过的用户，然后再重新分配一个sessid和token覆盖掉这条记录，并且生成一个新的登录cookie写到客户端上</li>
<li>如果sessid存在但token不匹配，则认为被攻击了，然后删除这个session对应的cookie全部删除</li>
<li>如果sessid和用户名都不存在则忽略login cookie返回到登录页面</li>
</ul>
<p>但是这是有并发的问题即:<br>当用户的两个tab同时打开的时候，这个前一个tab会更新token,然后后一个tab由于去比较token导致token不匹配，因为前面的tab已经更新过了，从而导致被认为是被伪造的攻击而退出到登录界面。</p>
<p>创建用户和登录的时候要加密那个密码，当登录的时候，</p>
</li>
</ul>
<h2 id="基于Cookie认证"><a href="#基于Cookie认证" class="headerlink" title="基于Cookie认证"></a>基于Cookie认证</h2><p>步骤如下:<br>-</p>
<h2 id="基于Token认证"><a href="#基于Token认证" class="headerlink" title="基于Token认证"></a>基于Token认证</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学session与cookie相关的内容，有以下几点疑点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session存储在哪？&lt;/li&gt;
&lt;li&gt;记住密码功能及相关的bug&lt;/li&gt;
&lt;li&gt;Session持久化&lt;/li&gt;
&lt;li&gt;如果在cookie中保存那个登录信息应该保存些信息？
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端开发相关</title>
    <link href="http://yoursite.com/2017/03/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/03/14/移动端开发相关/</id>
    <published>2017-03-14T14:51:15.000Z</published>
    <updated>2017-07-22T13:34:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做移动开发的过程中难免会遇到一些奇奇怪怪的问题，在此罗列如下:</p>
<ul>
<li>1像素问题</li>
</ul>
<p>##1像素问题</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做移动开发的过程中难免会遇到一些奇奇怪怪的问题，在此罗列如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1像素问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##1像素问题&lt;/p&gt;

    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
      <category term="1像素" scheme="http://yoursite.com/tags/1%E5%83%8F%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>React源码解读</title>
    <link href="http://yoursite.com/2017/03/06/React%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/03/06/React源码解读/</id>
    <published>2017-03-05T16:45:02.000Z</published>
    <updated>2017-08-10T13:06:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>React源码.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React源码.&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lib-flexible源码解读</title>
    <link href="http://yoursite.com/2016/12/30/lib-flexible%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2016/12/30/lib-flexible源码解读/</id>
    <published>2016-12-30T00:52:07.000Z</published>
    <updated>2016-12-30T00:54:10.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="源码阅读" scheme="http://yoursite.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Gulp work flow</title>
    <link href="http://yoursite.com/2016/12/05/Gulp-work-flow/"/>
    <id>http://yoursite.com/2016/12/05/Gulp-work-flow/</id>
    <published>2016-12-05T01:18:08.000Z</published>
    <updated>2016-12-08T07:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于前端自动化的文章已经有很多，最近，我一直在做这个前端的工程化，说简单一点就是把现有的插件进行整合，从而形成自己的工具集，偶也只是站在巨人的肩膀上^-^.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于前端自动化的文章已经有很多，最近，我一直在做这个前端的工程化，说简单一点就是把现有的插件进行整合，从而形成自己的工具集，偶也只是站在巨人的肩膀上^-^.&lt;/p&gt;

    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="automate" scheme="http://yoursite.com/tags/automate/"/>
    
  </entry>
  
  <entry>
    <title>一些Javascript的习题</title>
    <link href="http://yoursite.com/2016/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Javascript/"/>
    <id>http://yoursite.com/2016/10/16/深入理解Javascript/</id>
    <published>2016-10-16T12:48:29.000Z</published>
    <updated>2016-10-17T05:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>孔子日:学而实习之，不亦乐乎。</p>
</blockquote>
<p>在学习前端的道路上有很多的细节，也就是经验是值得去研究的，这不今天就研究了一把对象.且看以下题目：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var president = &#123;name: &apos;bush&apos;&#125;;</div><div class="line">function setName(obj) &#123;</div><div class="line">	obj.name = &apos;obama&apos;;</div><div class="line">	obj = &#123;name: &apos;clinton&apos;&#125;;</div><div class="line">&#125;</div><div class="line">setName(president);</div></pre></td></tr></table></figure></p>
<p>请问以上president将为何值?一开始我会想当然地觉得应该输出<code>{name: clinton&#39;}</code>,不过其实是错的，应该是为<code>{name: &#39;obama&#39;}</code>.那么为什么会这样呢？<br>因为对象的创建其实只是创建了一个内存地址来存放里面的内容，也就是说只是创建了一个函数指针。带着这个思考的方法，我又在函数<code>setName</code>里面打印出新创建的对象:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var president = &#123;name: &apos;bush&apos;&#125;;</div><div class="line">function setName(obj) &#123;</div><div class="line">	obj.name = &apos;obama&apos;;</div><div class="line">	obj = &#123;name: &apos;clinton&apos;&#125;;</div><div class="line">	console.log(obj);</div><div class="line">	return obj;</div><div class="line">&#125;</div><div class="line">var newPresident = setName(president);</div><div class="line">console.log(president, newPresident);</div></pre></td></tr></table></figure></p>
<p>返回值是<code>{name: &#39;clinton&#39;}, {name: &#39;obama&#39;}, {name: &#39;clinton&#39;}</code><br>结果，输出如预期，在函数setName里面<code>obj = {name: &#39;clinton&#39;}</code>实际上是创建了一个新的指针来存放新的内容，所以你得返回obj才会看到新建立的对象.<br><strong>以上是自己的思路，欢迎童鞋指正.</strong><br>今天先到这，未完待续……</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;孔子日:学而实习之，不亦乐乎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习前端的道路上有很多的细节，也就是经验是值得去研究的，这不今天就研究了一把对象.且看以下题目：&lt;br&gt;    &lt;figure class=&quot;highlight plain&quot;
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>紧凑的生活</title>
    <link href="http://yoursite.com/2016/04/13/%E7%B4%A7%E5%87%91%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2016/04/13/紧凑的生活/</id>
    <published>2016-04-13T14:28:15.000Z</published>
    <updated>2016-04-14T08:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我从上海辞职回老家了，在上海工作期间，最近的这家公司，我基本上早上5点半起床，上个厕所，烧开水，上完厕所喝开水，然后开始做瑜珈，吃苹果和面包，大约6点半出门，7点半左右到公司后再到小卖部喝了点稀饭。</p>
<p>因为是8点半上班的所以，喝完稀饭后，我会看些自己感兴趣的事情，比如我会看些养生方面的文章，IT技术类的网站比如<a href="https://cnodejs.org" target="_blank" rel="external">cnodejs</a>, <a href="http://fex.baidu.com/" target="_blank" rel="external">百度前端</a>, etc.</p>
<p>接下来就是开始紧张的工作了。</p>
<p>晚上回家，大多数时间我都会看会电影。或者看些文章，去跑跑步。</p>
<p>看起来，我生活得很健康，很紧凑，可是我却感觉到了前所未有的空虚，为什么呢？我问自己，我迷失了自我。没有目标的生活让自己陷于一种光鲜的消沉之路。</p>
<p>我的家在一座小岛上面，靠捕渔为生，在家的几天，每天母亲都会把美味的饭菜准备好来，因为我身体进行了专门的调理，我比以前要能吃了，不像以前吃了会吐。望着父母满头的白发，这么大年纪了还在努力赚钱为了给我娶媳妇。我心里很内疚。我感觉到了家的温暖，最近这几天，脑海中总是有个声音在告诫我，必须过上紧凑的生活，有目标的生活。</p>
<blockquote>
<p>生活不止眼前的苟且还有诗和远方</p>
</blockquote>
<p>我应该去探索，应该让自己更加紧凑地生活，目标是让父母不用再为我操劳了。因为我有看过中医方面的理论，所以我觉得5点起床是可以的。</p>
<ul>
<li>5点起床,烧开水，上厕所，完后喝水。</li>
<li>5点半开始yoga，如果假期瑜珈后就跑步</li>
<li>6点开始吃早餐</li>
<li>6:15 看新闻</li>
<li>6点半开始写东西</li>
<li>如果在假期就在下午打篮球</li>
<li>晚上看书做项目，如非假期就跑步</li>
<li>10点半入睡</li>
</ul>
<p>先坚持一段时间再说吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，我从上海辞职回老家了，在上海工作期间，最近的这家公司，我基本上早上5点半起床，上个厕所，烧开水，上完厕所喝开水，然后开始做瑜珈，吃苹果和面包，大约6点半出门，7点半左右到公司后再到小卖部喝了点稀饭。&lt;/p&gt;
&lt;p&gt;因为是8点半上班的所以，喝完稀饭后，我会看些自己感兴趣
    
    </summary>
    
      <category term="Essays" scheme="http://yoursite.com/categories/Essays/"/>
    
    
      <category term="愉快生活" scheme="http://yoursite.com/tags/%E6%84%89%E5%BF%AB%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
