<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Poeticlife</title>
  
  <subtitle>大知闲闲，小知间间；大言炎炎，小言詹詹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-17T15:00:53.362Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Troland</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>babel-runtime, babel-preset-env, babel-plugin-transform-runtime, babel-polyfill 详解</title>
    <link href="http://yoursite.com/2018/02/08/babel-runtime-babel-preset-env-babel-plugin-transform-runtime-babel-polyfill-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/02/08/babel-runtime-babel-preset-env-babel-plugin-transform-runtime-babel-polyfill-详解/</id>
    <published>2018-02-08T15:11:27.000Z</published>
    <updated>2018-03-17T15:00:53.362Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来都对<code>babel-runtime</code>，<code>babel-preset-env</code>，<code>babel-plugin-transform-runtime</code>，<code>babel-polyfill</code>等库之间的关系，所以就去仔细研究下喽。</p><p>先简单介绍一下<code>Babel</code>。</p><blockquote><p>它是一个编译器可以让你使用最新版本的<code>ES</code>规范比如<code>ES2015（ES6）</code>，<code>ES2016（ES7）</code>，<code>ES2017（ES8）</code>的写法并把它编译成老的<code>ES5</code>的写法。</p></blockquote><p>babel-core 是 babel 的编译器核心。</p><p>意思即你可以使用最新的<code>JavaScript</code>规范的写法比如<code>async</code>等来写代码，然后<code>Babel</code>会帮你编译成<code>ES5</code>以兼容老旧的浏览器。</p><p>转换前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 3, 5].reduce((accumulator, currentValue) =&gt; &#123;</div><div class="line">    return accumulator + currentValue;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 3, 5].reduce(function (accumulator, currentValue) &#123;</div><div class="line">    return accumulator + currentValue;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><strong>文章中凡是以<code>@babel</code>开头的都是指的Babel 7.x的否则是Babel 6.x，<code>@</code>的意思可参考<a href="https://docs.npmjs.com/misc/scope" target="_blank" rel="external">npm 官方</a>，标星号的表示只有 @babel 版本的才会有的参数。</strong></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以选择全局或者本地安装，最好是依据项目本地安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -D babel-cli</div></pre></td></tr></table></figure><p>在项目根目录下创建<code>.babelrc</code>文件来配置<code>Babel</code>或者是在<code>package.json</code>里面进行设置。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><code>babel script.js --out-file script-compiled.js</code> babel来编译输出</p><p><code>babel-node</code>是一个和<code>babel</code>一样功能的命令，但是它有缓存功能并且会编译 ES6 代码后再运行它。</p><h2 id="babel-polyfil"><a href="#babel-polyfil" class="headerlink" title="babel-polyfil"></a>babel-polyfil</h2><p>根据官网的表述由于<code>Babel</code>只是转换了语法比如箭头函数，但是并没有实现兼容那些新的原生方法比如<code>Promise</code>和 <code>Array.reduce</code>所以必须使用。它使用了<a href="https://github.com/zloirock/core-js" target="_blank" rel="external">core-js</a>和 <a href="https://facebook.github.io/regenerator/" target="_blank" rel="external">regenerator</a>。</p><p>必须安装为依赖<code>npm i babel-polyfill</code>。<br><strong>需要注意的是这个有一个弊端会污染全局的变量，后面会有解决方案。</strong></p><h2 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h2><p><code>npm i -D babel-preset-env</code>当不进行任何设置的时候和<code>babel-preset-latest</code>一样就是默认使用 <code>ES2015（ES6）</code>，<code>ES2016（ES7）</code>，<code>ES2017（ES8）</code>的新语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [&quot;env&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>这里有一个参数<code>useBuiltIns</code>，这个参数默认值为<code>false</code>意思是不为每个文件自动添加兼容插件，或者把 <code>import &quot;@babel/polyfill&quot;</code>根据不同目标环境拆分为多个的兼容插件。</p><p>比如当启用的时候：</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;@babel/polyfill&quot;;</div></pre></td></tr></table></figure><p>输出依据不同的输出环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &quot;core-js/modules/es7.string.pad-start&quot;;</div><div class="line">import &quot;core-js/modules/es7.string.pad-end&quot;;</div></pre></td></tr></table></figure><p>这里的输出环境即目标环境比如下 .babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;@babel/preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [</div><div class="line">            &quot;last 2 versions&quot;</div><div class="line">          ]</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>这里需要注意的是只有2.x版本的useBuiltIns参数才会有<code>usage</code>和<code>entry</code>选项，参见<a href="https://github.com/babel/babel-preset-env/issues/443" target="_blank" rel="external">这里</a>。</strong></p><p><code>useBuiltIns</code>在<code>babel 6</code>版本只有两个值<code>true</code>和<code>false</code>。默认<code>false</code>表示不自动为每个文件添加兼容插件或者把对<code>import &quot;@babel/polyfill&quot;</code>的引用依据不同的目标环境输出不同的兼容插件。</p><p>Babel 的插件有两种模式：</p><ul><li>正常模式，尽量贴近 ES6 的书写语法。</li><li>更类似 ES5 的代码</li></ul><p>loose选项大概的意思即编译出来的代码更像<code>ES5</code>而不是<code>ES6</code>的语法。<br>优缺点如下：</p><ul><li>编译出来的代码在旧的引擎中可能会运行得更快和兼容</li><li>缺点是在以后的版本中当从编译的ES6切换到原生ES6可能会有问题，不过这种情况极少。</li></ul><p>例如如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Point &#123;</div><div class="line">    constructor(x, y) &#123;</div><div class="line">        this.x = x;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line">    toString() &#123;</div><div class="line">        return `($&#123;this.x&#125;, $&#123;this.y&#125;)`;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意看如下行（Ａ）那里的不同，一个是使用ES6语法一个是使用ES5。<br>正常模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">var _createClass = (function () &#123;</div><div class="line">    function defineProperties(target, props) &#123;</div><div class="line">        for (var i = 0; i &lt; props.length; i++) &#123;</div><div class="line">            var descriptor = props[i];</div><div class="line">            descriptor.enumerable = descriptor.enumerable || false;</div><div class="line">            descriptor.configurable = true;</div><div class="line">            if (&quot;value&quot; in descriptor) descriptor.writable = true;</div><div class="line">            Object.defineProperty(target, descriptor.key, descriptor); // (A)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return function (Constructor, protoProps, staticProps) &#123;</div><div class="line">        if (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">        if (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">        return Constructor;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123;</div><div class="line">    if (!(instance instanceof Constructor)) &#123;</div><div class="line">        throw new TypeError(&quot;Cannot call a class as a function&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var Point = (function () &#123;</div><div class="line">    function Point(x, y) &#123;</div><div class="line">        _classCallCheck(this, Point);</div><div class="line"></div><div class="line">        this.x = x;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _createClass(Point, [&#123;</div><div class="line">        key: &quot;toString&quot;,</div><div class="line">        value: function toString() &#123;</div><div class="line">            return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;]);</div><div class="line"></div><div class="line">    return Point;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>宽松模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; ··· &#125;</div><div class="line"></div><div class="line">var Point = (function () &#123;</div><div class="line">    function Point(x, y) &#123;</div><div class="line">        _classCallCheck(this, Point);</div><div class="line"></div><div class="line">        this.x = x;</div><div class="line">        this.y = y;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Point.prototype.toString = function toString() &#123; // (A)</div><div class="line">        return &quot;(&quot; + this.x + &quot;, &quot; + this.y + &quot;)&quot;;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    return Point;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p><p>具体可参见<a href="http://2ality.com/2015/12/babel6-loose-mode.html" target="_blank" rel="external">这里</a>。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><code>Babel</code>是一个编译器，在高级层面它分三阶段解析，转换，生成代码。</p><h3 id="官方-Presets"><a href="#官方-Presets" class="headerlink" title="官方 Presets"></a>官方 Presets</h3><p>如果不想自己设置一堆插件的话，官方有<code>env</code>，<code>react</code>，<code>flow</code>三个 Presets。即预安装了 plugins 的配置。</p><h3 id="Stage-X（试验性-Presets）"><a href="#Stage-X（试验性-Presets）" class="headerlink" title="Stage-X（试验性 Presets）"></a>Stage-X（试验性 Presets）</h3><p>stage-x presets指的是任何未被包括在官方发布版比如（ES6/ES2015）中的草案。任何 <code>stage-3</code> 之前的都应该要谨慎使用，<br>一共有以下几个试验性的版本：</p><ul><li>Stage 0 - 草稿：只是一个设想可能是一个 Babel 插件</li><li>Stage 1 - 提案：值得去推进的东西</li><li>Stage 2 - 草案：初始化规范</li><li>Stage 3 - 候选：完整规范和初始化浏览器实现</li><li>Stage 4 - 完成：会加入到下一版中</li></ul><h3 id="转换插件"><a href="#转换插件" class="headerlink" title="转换插件"></a>转换插件</h3><p>有很多的转换插件具体可查看<a href="https://babeljs.io/docs/plugins/" target="_blank" rel="external">这里</a>。</p><h3 id="语法插件"><a href="#语法插件" class="headerlink" title="语法插件"></a>语法插件</h3><p>这种插件可以让 <code>Babel</code> 来解析特殊类型的语法。</p><blockquote><p>如果对应的转换插件已经使用了转换插件会自动使用语法插件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;parserOpts&quot;: &#123;</div><div class="line">    &quot;plugins&quot;: [&quot;jsx&quot;, &quot;flow&quot;]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Plugins-Preset-路径"><a href="#Plugins-Preset-路径" class="headerlink" title="Plugins/Preset 路径"></a>Plugins/Preset 路径</h3><p>如果插件发布到npm上面则可以使用<code>&quot;plugins&quot;: [&quot;babel-plugin-myPlugin&quot;]</code>，也可以使用<code>&quot;plugins:&quot;: [&quot;./node_modules/pluginPath&quot;]</code>。</p><h3 id="Plugins-Preset-快捷方式"><a href="#Plugins-Preset-快捷方式" class="headerlink" title="Plugins/Preset 快捷方式"></a>Plugins/Preset 快捷方式</h3><p>如果插件前缀是<code>babel-plugin-</code>则可以使用<code>&quot;plugins:&quot;: [&quot;myPlugin&quot;]</code>，<code>presets</code>同理<br><code>&quot;presets&quot;: [&quot;@org/babel-preset-name&quot;]</code>。作用域包也是如此，<code>&quot;presets&quot;: [&quot;@org/babel-preset-name&quot;]</code> 快捷方式为：<code>&quot;presets&quot;: [&quot;@org/name&quot;]</code>。</p><h3 id="Plugin-Preset-顺序"><a href="#Plugin-Preset-顺序" class="headerlink" title="Plugin/Preset 顺序"></a>Plugin/Preset 顺序</h3><p>当这两种插件同时处理代码的时候，将以插件或者preset的顺序来进行转换。</p><ul><li>插件在<code>presets</code>之前运行</li><li>插件顺序是从第一到最后</li><li>Preset顺序是相反的从最后到第一</li></ul><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    &quot;transform-decorators-legacy&quot;,</div><div class="line">    &quot;transform-class-properties&quot;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将会先运行<code>transform-decorators-legacy</code>后<code>transform-class-properties</code>。</p><p>Presets的顺序是相反的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    &quot;es2015&quot;,</div><div class="line">    &quot;react&quot;,</div><div class="line">    &quot;stage-2&quot;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将会以<code>stage-2</code>，<code>react</code> 和 <code>es2015</code>的顺序运行。这主要是因为向后兼容性，因为大多数用户把<code>es2015</code> 放在 <code>stage-0</code> 之前。</p><h3 id="Plugins-和-Preset-参数"><a href="#Plugins-和-Preset-参数" class="headerlink" title="Plugins 和 Preset 参数"></a>Plugins 和 Preset 参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    [&quot;transform-async-to-module-method&quot;, &#123;</div><div class="line">      &quot;module&quot;: &quot;bluebird&quot;,</div><div class="line">      &quot;method&quot;: &quot;coroutine&quot;</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [&quot;es2015&quot;, &#123;</div><div class="line">      &quot;loose&quot;: true,</div><div class="line">      &quot;modules&quot;: false</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="开发插件"><a href="#开发插件" class="headerlink" title="开发插件"></a>开发插件</h3><p>参考<a href="https://github.com/thejameskyle/babel-handbook" target="_blank" rel="external">babel-handbook</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">export default function () &#123;</div><div class="line">  return &#123;</div><div class="line">    visitor: &#123;</div><div class="line">      Identifier(path) &#123;</div><div class="line">        const name = path.node.name;</div><div class="line">        // reverse the name: JavaScript -&gt; tpircSavaJ</div><div class="line">        path.node.name = name.split(&quot;&quot;).reverse().join(&quot;&quot;);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="开发-Preset"><a href="#开发-Preset" class="headerlink" title="开发 Preset"></a>开发 Preset</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// Presets can contain other presets, and plugins with options.</div><div class="line">module.exports = &#123;</div><div class="line">  presets: [</div><div class="line">    require(&quot;babel-preset-es2015&quot;),</div><div class="line">  ],</div><div class="line">  plugins: [</div><div class="line">    [require(&quot;babel-plugin-transform-es2015-template-literals&quot;), &#123; spec: true &#125;],</div><div class="line">    require(&quot;babel-plugin-transform-es3-member-expression-literals&quot;),</div><div class="line">  ],</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>查看<a href="https://github.com/babel/babel/tree/master/packages/babel-preset-es2015" target="_blank" rel="external">es2015 preset</a>。</p><h3 id="Plugins-和-Preset-配合使用"><a href="#Plugins-和-Preset-配合使用" class="headerlink" title="Plugins 和 Preset 配合使用"></a>Plugins 和 Preset 配合使用</h3><p>如果Plugins和Preset配合使用的话假设如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [&quot;@babel/plugin-transform-for-of&quot;],</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [&quot;@babel/preset-env&quot;, &#123;</div><div class="line">      &quot;targets&quot;: &#123;</div><div class="line">        &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;not ie &lt;= 10&quot;],</div><div class="line">      &#125;,</div><div class="line">      &quot;debug&quot;: true,</div><div class="line">    &#125;],</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上 <code>@babel</code> 指的是在<code>babel</code>组织下的相关包这里即是兼容的<code>babel 7.x</code> 版本。按照解析的规则是 <code>plugins</code>先于<code>presets</code>，之后再进入<code>presets</code>，转化出来的代码是一样的，因为<code>@babel/preset-env</code>即是兼容了那个<code>es6</code>的<code>for...of</code> 写法。</p><h3 id="babel-runtime-和-babel-plugin-transform-runtime"><a href="#babel-runtime-和-babel-plugin-transform-runtime" class="headerlink" title="babel-runtime 和 babel-plugin-transform-runtime"></a>babel-runtime 和 babel-plugin-transform-runtime</h3><p>先来介绍 babel-plugin-transform-runtime。</p><blockquote><p>需要注意的是实例方法例如<code>&quot;foobar&quot;.includes(&quot;foo&quot;)</code>因为会更改内置的方法所以不会正常工作需要引用<code>babel-polyfill</code> 。</p></blockquote><p>这个插件的作用有两个：</p><ul><li><p>由于<code>Babel</code>使用工具函数作为常用函数比如<code>_extend</code>。默认情况下会被添加进每个文件中。这样就会导致重复，特别是当程序包含了多个文件。所有的工具函数都会引用模块<code>babel-runtime</code>来减少代码重复，运行时会被编译进构建的代码之中。</p></li><li><p>另一个作用是代码提供一个沙箱环境。当你使用<code>babel-polyfill</code>和其内置的诸如 <code>Promise</code>, <code>Set</code> 等新 API，这些会污染全局变量。当是一个 app 的时候或者是一个命令行工具的时候不会有问题，但是如果是想要发布来给别人用的时候就会因为无法控制目标环境而出现问题。</p></li></ul><p>这个转换插件将对这些内置函数的引用指向<code>core-js</code>这样就可以不需要使用 polyfill。<br>一般情况下需要安装<code>babel-plugin-transform-runtime</code>来作为一个开发依赖包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -D babel-plugin-transform-runtime</div></pre></td></tr></table></figure><p>然后安装<code>babel-runtime</code>来作为生产环境的依赖包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i babel-runtime</div></pre></td></tr></table></figure><p>转换插件只是在开发环境使用，但是运行时插件依赖于部署发布的代码。<br>在 .babelrc 中使用如下配置即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    [&quot;transform-runtime&quot;, &#123;</div><div class="line">      &quot;helpers&quot;: false,</div><div class="line">      &quot;polyfill&quot;: false,</div><div class="line">      &quot;regenerator&quot;: true,</div><div class="line">      &quot;moduleName&quot;: &quot;babel-runtime&quot;</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li><p>helpers</p><p>默认为 true，是否内联的 Babel 工具函数替换为对模块的引用。<br>即以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class Person &#123;&#125;</div></pre></td></tr></table></figure></li></ul><p>  一般会转换为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">  function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line">  </div><div class="line">  var Person = function Person() &#123;</div><div class="line">    _classCallCheck(this, Person);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><p>  使用 <code>babel-runtime</code> 转换插件会转换为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">  var _classCallCheck2 = require(&quot;babel-runtime/helpers/classCallCheck&quot;);</div><div class="line">  </div><div class="line">  var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);</div><div class="line">  </div><div class="line">  function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</div><div class="line">  </div><div class="line">  var Person = function Person() &#123;</div><div class="line">    (0, _classCallCheck3.default)(this, Person);</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><p>  这里在实际操作过程中需要添加类似如下的代码否则是不会进行任何转换：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> &quot;plugins&quot;: [</div><div class="line">   [&quot;@babel/plugin-transform-runtime&quot;, &#123;</div><div class="line">      &quot;moduleName&quot;: &quot;@babel/runtime&quot;</div><div class="line">  &#125;]</div><div class="line"> ],</div><div class="line"> &quot;presets&quot;: [</div><div class="line">  [</div><div class="line">    &quot;@babel/preset-env&quot;,</div><div class="line">    &#123;</div><div class="line">      &quot;targets&quot;: &#123;</div><div class="line">        &quot;browsers&quot;: [</div><div class="line">          &quot;last 2 versions&quot;</div><div class="line">        ]</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line"> ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li><p>polyfill</p><p>默认 true，是否允许让内置的诸如<code>Promise</code>，<code>Set</code>，<code>Map</code>使用不会污染全局作用域的兼容插件。</p></li></ul><ul><li><p>regenerator</p><p>默认为 true，是否设置生成器函数是否使用再生器运行时插件来避免污染全局作用域。</p></li><li><p>moduleName</p><p>默认为<code>&quot;babel-runtime&quot;</code>。当使用工具函数的时候设置模块的名称 / 路径。</p></li><li><p>useBuiltIn*</p><p>默认为 false。当启用的意思即当使用工具函数的时候不再引用<code>core-js</code>中的兼容插件。</p></li><li><p>useESModules*</p><p>默认 false，当启用的时候转换插件就不会使用经过 <strong>@babel/plugin-transform-modules-commonjs</strong> 处理的工具函数。这样有利于为诸如 webpack 的模块构建系统减少构建包的大小，因为 webpack 不需要保存 commonjs 的语法。</p></li></ul><h2 id="babel-plugin-transform-runtime，babel-preset-env，babel-polyfill-的使用"><a href="#babel-plugin-transform-runtime，babel-preset-env，babel-polyfill-的使用" class="headerlink" title="babel-plugin-transform-runtime，babel-preset-env，babel-polyfill 的使用"></a>babel-plugin-transform-runtime，babel-preset-env，babel-polyfill 的使用</h2><p>  这三个插件是如何配合的？这里主要是因为 Babel 7 和 Babel 6，会造成一些区别，分情况来说明吧。</p><p>  举个例子吧，目录结构如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">|-----build</div><div class="line">|      |</div><div class="line">|      |----test.js</div><div class="line">|      |----test-compiled.js </div><div class="line">|</div><div class="line">|-----.babelrc</div><div class="line">|</div><div class="line">|-----package.json</div><div class="line">|</div><div class="line">|-----webpack.config.js</div></pre></td></tr></table></figure><p>  执行如下命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mkdir babel-learn</div><div class="line"></div><div class="line">npm init -y</div><div class="line"></div><div class="line">npm i -D  @babel/cli @babel/core @babel/plugin-transform-runtime @babel/preset-env webpack@3.7.1</div><div class="line"></div><div class="line">npm i @babel/polyfill @babel/runtime</div></pre></td></tr></table></figure><ul><li><p>Babel 7</p><p>babel-preset-env 需要和 babel-polyfill 配合使用。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;@babel/preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [</div><div class="line">            &quot;last 2 versions&quot;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>package.json 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;babel&quot;: &quot;babel build/test.js --out-file build/test-compiled.js&quot;</div></pre></td></tr></table></figure><p>运行 npm run babel 即可。</p><p><strong>例一</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;@babel/preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [</div><div class="line">            &quot;last 2 versions&quot;</div><div class="line">          ]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;&#125;</div><div class="line">    </div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">    </div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.promise&quot;);</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceofConstructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">  _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Promise(function (resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">a.then(function () &#123;</div><div class="line">  console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>可以看到上面是把 test.js 在目标浏览器环境下是通过引用 polyfill 的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(&quot;core-js/modules/es6.promise&quot;)</div></pre></td></tr></table></figure><p>这里如果不想要用 commonjs 的方式引入兼容的插件可以设置 modules 参数。</p><p><strong>例二</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;@babel/preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: &quot;entry&quot;,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &quot;@babel/polyfill&quot;;</div><div class="line"></div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.array.sort&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.date.to-json&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.typed.array-buffer&quot;);</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">  _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Promise(function (resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">a.then(function () &#123;</div><div class="line">  console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例三</strong></p><p>当设置 useBuiltIns 为 false 的时候的输出。<br>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &quot;@babel/polyfill&quot;;</div><div class="line"></div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">require(&quot;@babel/polyfill&quot;);</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">  _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Promise(function (resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">a.then(function () &#123;</div><div class="line">  console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例四</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    [&quot;@babel/plugin-transform-runtime&quot;, &#123;</div><div class="line">      &quot;moduleName&quot;: &quot;@babel/runtime&quot;</div><div class="line">    &#125;]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var _Promise = require(&quot;@babel/runtime/core-js/promise&quot;);</div><div class="line"></div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new _Promise(function (resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">a.then(function () &#123;</div><div class="line">  console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>可以看到上面的 Promise 并没有污染全局的 Promise 而是引用了 @babel/runtime/core-js/promise。</p><p><strong>例五</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    [&quot;@babel/plugin-transform-runtime&quot;, &#123;</div><div class="line">      &quot;moduleName&quot;: &quot;@babel/runtime&quot;,</div><div class="line">    &#125;]</div><div class="line">  ],</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;@babel/preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var _Promise = require(&quot;@babel/runtime/core-js/promise&quot;);</div><div class="line"></div><div class="line">var _classCallCheck = require(&quot;@babel/runtime/helpers/classCallCheck&quot;);</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">  _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new _Promise(function (resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">a.then(function () &#123;</div><div class="line">  console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例六</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    [&quot;@babel/plugin-transform-runtime&quot;, &#123;</div><div class="line">      &quot;moduleName&quot;: &quot;@babel/runtime&quot;,</div><div class="line">    &#125;]</div><div class="line">  ],</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;@babel/preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: &quot;entry&quot;,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import &quot;@babel/polyfill&quot;;</div><div class="line"></div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line"></div><div class="line">var _interopRequireDefault = require(&quot;@babel/runtime/helpers/interopRequireDefault&quot;);</div><div class="line"></div><div class="line">var _promise = _interopRequireDefault(require(&quot;@babel/runtime/core-js/promise&quot;));</div><div class="line"></div><div class="line">var _classCallCheck2 = _interopRequireDefault(require(&quot;@babel/runtime/helpers/classCallCheck&quot;));</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.array.sort&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.date.to-json&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.typed.array-buffer&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.typed.int8-array&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.symbol&quot;);</div><div class="line"></div><div class="line">require(&quot;core-js/modules/es6.number.parse-int&quot;);</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">  (0, _classCallCheck2.default)(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new _promise.default(function (resolve, reject) &#123;</div><div class="line">  console.log(&apos;Promise&apos;);</div><div class="line">  resolve();</div><div class="line">&#125;);</div><div class="line">a.then(function () &#123;</div><div class="line">  console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>当 @babel/preset-env 中的 useBuiltIns 为 false 的时候和 usage 是一样的（但是必须是 test.js 中没有有 import polyfill）。</p></li><li><p>Babel 6</p><p><strong>例一</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;babel-preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: true,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">    _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例二</strong></p><p>.babelrc 同例一。<br>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &quot;babel-polyfill&quot;;</div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.array-buffer&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.int8-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.uint8-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.uint8-clamped-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.int16-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.uint16-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.int32-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.uint32-array&apos;);</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">    _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例三</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;babel-preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: false,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js 同例二。<br>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">require(&apos;babel-polyfill&apos;);</div><div class="line"></div><div class="line">function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(&quot;Cannot call a class as a function&quot;); &#125; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">    _classCallCheck(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例四</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    &quot;transform-runtime&quot;</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import _Promise from &apos;babel-runtime/core-js/promise&apos;;</div><div class="line"></div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new _Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例五</strong></p><p>.babelrc 和例四一样。<br>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &quot;babel-polyfill&quot;;</div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import _Promise from &apos;babel-runtime/core-js/promise&apos;;</div><div class="line">import &quot;babel-polyfill&quot;;</div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new _Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例六</strong></p><p>.babelrc：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">    &quot;transform-runtime&quot;</div><div class="line">  ],</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [</div><div class="line">      &quot;babel-preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">        &quot;targets&quot;: &#123;</div><div class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">        &#125;,</div><div class="line">        &quot;useBuiltIns&quot;: true,</div><div class="line">        &quot;debug&quot;: true</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>test.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import &quot;babel-polyfill&quot;;</div><div class="line">class Person &#123;&#125;</div><div class="line"></div><div class="line">let a = new Promise(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var _promise = require(&apos;babel-runtime/core-js/promise&apos;);</div><div class="line"></div><div class="line">var _promise2 = _interopRequireDefault(_promise);</div><div class="line"></div><div class="line">var _classCallCheck2 = require(&apos;babel-runtime/helpers/classCallCheck&apos;);</div><div class="line"></div><div class="line">var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.array-buffer&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.int8-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.uint8-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.uint8-clamped-array&apos;);</div><div class="line"></div><div class="line">require(&apos;core-js/modules/es6.typed.int16-array&apos;);</div><div class="line">...还有其它兼容插件</div><div class="line"></div><div class="line">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">    (0, _classCallCheck3.default)(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new _promise2.default(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p><strong>例七</strong></p><p>.babelrc 和例六一样。<br>test.js和例六比去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;babel-polyfill&quot;</div></pre></td></tr></table></figure><p>test-compiled.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">var _promise = require(&apos;babel-runtime/core-js/promise&apos;);</div><div class="line"></div><div class="line">var _promise2 = _interopRequireDefault(_promise);</div><div class="line"></div><div class="line">var _classCallCheck2 = require(&apos;babel-runtime/helpers/classCallCheck&apos;);</div><div class="line"></div><div class="line">var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);</div><div class="line"></div><div class="line">function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;</div><div class="line"></div><div class="line">var Person = function Person() &#123;</div><div class="line">    (0, _classCallCheck3.default)(this, Person);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var a = new _promise2.default(function (resolve, reject) &#123;</div><div class="line">    console.log(&apos;Promise&apos;);</div><div class="line">    resolve();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">a.then(function () &#123;</div><div class="line">    console.log(&apos;resolved.&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;Hi&apos;);</div></pre></td></tr></table></figure><p>设置 .babelrc 中 useBuiltIns 为 false 和上面是一样的结果。<br>当设置 .babelrc 中 useBuiltIns 为 false 并且<code>test.js</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;babel-polyfill&quot;;</div></pre></td></tr></table></figure><p>则输出会多一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(&apos;babel-polyfill&apos;);</div></pre></td></tr></table></figure><p>当设置 .babelrc 中 useBuiltIns 为 true 并且 test.js 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &quot;babel-polyfill&quot;</div></pre></td></tr></table></figure><p>则输出会多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">require(&apos;core-js/modules/es6.typed.int16-array&apos;);</div><div class="line">require(&apos;core-js/modules/es6.typed.uint16-array&apos;);</div><div class="line">require(&apos;core-js/modules/es6.typed.array-buffer&apos;);</div><div class="line">...还有其它</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>这里有一个非常重要的问题就是关于transform-runtime<a href="https://babeljs.io/docs/plugins/transform-runtime/#core-js-aliasing" target="_blank" rel="external">官方文档</a>上写的关于有些方法必须使用 babel-polyfill 中的方法。</strong></p><p><strong>那么这样导致的结果就是如果是在 Babel 6 中的时候当在源文件中写上</strong>“foobar”.includes(“foo”)<strong>就必须写上<em>import “babel-polyfill”;</em>。</strong></p><p><strong>但是 Babel 7 就不需要在源文件中写<code>_import &quot;@babel/polyfill&quot;;_</code>会智能判断是否需要去引用这个<code>includes</code>的 polyfill。</strong></p><p>当<code>test.js</code>中有<strong>import “babel-polyfill”;</strong>的时候，Babel 6 版本的<strong>“useBuiltIns”: true</strong>即是 Babel 7 的<strong>“useBuiltIns”: “entry”</strong>。</p><p>在 Babel 7 中即使是源文件中不写<strong>import “@babel/polyfill”;</strong>当设置<strong>“useBuiltIns”: “usage”</strong>会根据情况输出<strong>“@babel/polyfill”</strong>对应兼容插件的输出。</p><p>安装<code>babel-polyfill</code>。</p><p>当是 Babel 7 的时候使用 .babelrc 配置建议如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">      &quot;@babel/plugin-transform-runtime&quot;</div><div class="line">  ],</div><div class="line">  &quot;presets&quot;: [</div><div class="line">  [</div><div class="line">    &quot;@babel/preset-env&quot;,</div><div class="line">    &#123;</div><div class="line">      &quot;targets&quot;: &#123;</div><div class="line">        &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">      &#125;,</div><div class="line">      &quot;useBuiltIns&quot;: &quot;usage&quot;,</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Babel 6</p><p>如果有使用 babel-polyfill。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;plugins&quot;: [</div><div class="line">      &quot;transform-runtime&quot;</div><div class="line">  ],</div><div class="line">  &quot;presets&quot;: [</div><div class="line">      [</div><div class="line">      &quot;babel-preset-env&quot;,</div><div class="line">      &#123;</div><div class="line">          &quot;targets&quot;: &#123;</div><div class="line">              &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari 7&quot;]</div><div class="line">          &#125;,</div><div class="line">          &quot;useBuiltIns&quot;: true,</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  ],</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Babel 6 webpack 中的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    index: [&quot;babel-polyfill&quot;, &quot;./test.js&quot;]</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;[name].bundle.js&apos;,</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">        &#123;</div><div class="line">            test: /\.js$/,</div><div class="line">            exclude: /(node_modules|bower_components)/,</div><div class="line">            use: &#123;</div><div class="line">                loader: &apos;babel-loader&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>Babel 7 webpack 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: [&quot;./test.js&quot;],</div><div class="line">  output: &#123;</div><div class="line">    filename: &apos;[name].bundle.js&apos;,</div><div class="line">    path: path.resolve(__dirname, &apos;dist&apos;)</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">        &#123;</div><div class="line">            test: /\.js$/,</div><div class="line">            exclude: /(node_modules|bower_components)/,</div><div class="line">            use: &#123;</div><div class="line">                loader: &apos;babel-loader&apos;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直以来都对&lt;code&gt;babel-runtime&lt;/code&gt;，&lt;code&gt;babel-preset-env&lt;/code&gt;，&lt;code&gt;babel-plugin-transform-runtime&lt;/code&gt;，&lt;code&gt;babel-polyfill&lt;/code&gt;等库之
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="babel" scheme="http://yoursite.com/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>DCloud 个推总结</title>
    <link href="http://yoursite.com/2018/01/13/Dcloud-%E4%B8%AA%E6%8E%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/13/Dcloud-个推总结/</id>
    <published>2018-01-13T08:54:07.000Z</published>
    <updated>2018-03-18T04:25:32.768Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司有用 DCloud 的产品来开发 app 里面涉及到一些问题听我细细道来。<br>推送使用的是个推平台，参见<a href="http://getui.com/cn/index.html" target="_blank" rel="external">官网</a>。这里分为<a href="http://docs.getui.com/getui/more/plugin/" target="_blank" rel="external">客户端</a>和<a href="http://docs.getui.com/getui/more/plugin/" target="_blank" rel="external">服务端</a>。DCloud的HBuilder里面有集成推送的 sdk。</p><p>推送的步骤可参见官方<a href="http://ask.dcloud.net.cn/article/34" target="_blank" rel="external">文档</a>。<br>大致的推送流程是：服务端发送推送 -&gt; 个推平台会进行处理 -&gt; App 的个推进程收到推送信息 -&gt; App进行消息处理和推送事件的监听。</p><p>这里主要遇到的问题有如下：</p><ul><li><p>应该采用何种模板才能够让 ios 和 android 客户端都可以收到推送？</p><p>这里只能采用透传模板TransmissionTemplate，查看个推官方 <a href="http://docs.getui.com/question/getui/ios/" target="_blank" rel="external">FAQ</a></p></li><li><p>关于离线的信息的推送，android和ios应该如何处理？</p><p>关于android的离线处理，我询问了安卓的小伙伴，得到的答复是无法保证离线状态下android可以收到推送。ios则可以通aps苹果推送服务来得到推送信息。</p><p>这里有一个地方需要注意的是服务端在发送ios离线信息的时候需要在<code>customMsg</code>参数下添加传递到客户端的参数比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let payload = new APNPayload();</div><div class="line">let alertMsg = new SimpleAlertMsg();</div><div class="line">alertMsg.alertMsg=&quot;&quot;;</div><div class="line">payload.alertMsg = alertMsg;</div><div class="line">payload.badge=5;</div><div class="line">payload.contentAvailable =1;</div><div class="line">payload.category=&quot;&quot;;</div><div class="line">payload.sound=&quot;&quot;;</div><div class="line">payload.customMsg.body = &quot;rolman&quot;;</div></pre></td></tr></table></figure></li></ul><p>  ios当app在线的时候会通过<code>receive</code>事件创建消息到消息中心，若离线则通过苹果aps推送到消息中心。</p><p>  <strong>需要注意的是：ios的消息展示方式，这里统一为不管app是在前台还是后台都是把推送消息显示在消息中心，这样就和android的信息展示方式统一。</strong></p><ul><li><p>在 ios app 登记的时候必须是苹果推服务证书！否则无法通过 aps 接收推送信息。</p><p> 查看<a href="http://docs.getui.com/question/getui/ios/" target="_blank" rel="external">这里</a>，客户端看下 devicetoken 是否有获取到，获取到了，应用配置里面上传证书的地方有个测试一下，测试看看返回什么结果，返回测试可用才说明证书环境是一致的。</p></li><li><p>关于角标的处理</p><p>　app 角标的处理是个比较复杂的问题，考虑的问题会比较多，这里只做了简单的处理：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> document.addEventListener(&apos;newintent&apos;, function () &#123;</div><div class="line">plus.runtime.setBadgeNumber(0);</div><div class="line">&#125;, false);</div><div class="line">    </div><div class="line">document.addEventListener(&apos;resume&apos;, function () &#123;</div><div class="line">plus.runtime.setBadgeNumber(0);</div><div class="line">&#125;, false);</div><div class="line">    </div><div class="line">document.addEventListener(&apos;foreground&apos;, function () &#123;</div><div class="line">plus.runtime.setBadgeNumber(0);</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure><p>　</p></li><li><p>在<code>receive</code>事件中接收到的参数问题</p><p>在<code>receive</code>事件中传过来的参数<code>ios</code>和<code>android</code>接收到的数据类型会不一致。就是那个<code>msg.payload</code>这个参数即<code>transmissionContent</code>，ios解析为object，android解析为string。　</p></li><li>ios 在<code>receive</code>事件中必须区分是本地消息还是服务器推送的消息否则会一直循环创建消息。</li></ul><p>消息处理的代码必须写在 HBuilder 的 manifest.json 文件中的页面入口页面中。</p><p>下面列出消息处理的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">$.plusReady(function() &#123;</div><div class="line">    document.addEventListener(&apos;newintent&apos;, function () &#123;</div><div class="line">    plus.runtime.setBadgeNumber(0);</div><div class="line">    &#125;, false);</div><div class="line">    </div><div class="line">    document.addEventListener(&apos;resume&apos;, function () &#123;</div><div class="line">    plus.runtime.setBadgeNumber(0);</div><div class="line">    &#125;, false);</div><div class="line">    </div><div class="line">    document.addEventListener(&apos;foreground&apos;, function () &#123;</div><div class="line">    plus.runtime.setBadgeNumber(0);</div><div class="line">    &#125;, false);</div><div class="line"></div><div class="line">    // 监听在线消息事件</div><div class="line">    // ios 和 android 传过来的 msg.payload，ios 解析为 object，android 解析为 string</div><div class="line">plus.push.addEventListener(&apos;receive&apos;, function( msg ) &#123;</div><div class="line">   var payload = (typeof msg.payload == &apos;string&apos; ?</div><div class="line">       JSON.parse(msg.payload) : msg.payload);</div><div class="line"></div><div class="line"></div><div class="line">// 判断是否 ios</div><div class="line">if ($.os.ios) &#123;</div><div class="line">// 只有当不是本地消息的时候才创建</div><div class="line">if (!payload._isLocal) &#123;</div><div class="line">payload._isLocal = true;</div><div class="line">msg.payload = payload;</div><div class="line">plus.push.createMessage(payload.body, JSON.stringify(payload), &#123;</div><div class="line"> title: payload.title,</div><div class="line"> cover: false</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125; else &#123;</div><div class="line">plus.push.createMessage(payload.body, msg.payload, &#123;</div><div class="line"> title: payload.title,</div><div class="line"> cover: false</div><div class="line">&#125;);</div><div class="line">&#125;</div><div class="line">&#125;, false);</div><div class="line"></div><div class="line">// 监听在消息通知点击，这里写具体的跳转业务</div><div class="line">plus.push.addEventListener(&apos;click&apos;, function( msg ) &#123;</div><div class="line">var payload = (typeof msg.payload == &apos;string&apos; ? JSON.parse(msg.payload) : msg.payload),</div><div class="line">  type = payload.type,</div><div class="line">  openUrl;</div><div class="line"></div><div class="line">&#125;, false);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里在进行调试的时候需要考虑蛮多的东西，多去查查个推平台的文档，然后自己可以在本地起个 nodejs 服务器，然后那个苹果的推服务的证书也得测试于是。这样就可以解决问题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这里安卓的离线的消息通知仍然有些问题，关于透传的标准格式会不会触发 click 事件，这里有个<a href="http://ask.dcloud.net.cn/article/836" target="_blank" rel="external">帖子</a>。<br>还有另一个问题就是关于角标的处理，安卓是不是也可以设置？还有如何根据业务，比如当用户读取消息再让角标减少？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近公司有用 DCloud 的产品来开发 app 里面涉及到一些问题听我细细道来。&lt;br&gt;推送使用的是个推平台，参见&lt;a href=&quot;http://getui.com/cn/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;。
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="app" scheme="http://yoursite.com/tags/app/"/>
    
      <category term="mui" scheme="http://yoursite.com/tags/mui/"/>
    
      <category term="hybrid" scheme="http://yoursite.com/tags/hybrid/"/>
    
  </entry>
  
  <entry>
    <title>任务，微任务，队列，计划</title>
    <link href="http://yoursite.com/2017/12/21/%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%EF%BC%8C%E9%98%9F%E5%88%97%EF%BC%8C%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2017/12/21/任务，微任务，队列，计划/</id>
    <published>2017-12-21T15:34:13.000Z</published>
    <updated>2017-12-23T05:09:08.255Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了一篇文章讲述的关于任务，微任务，队列之类的文章觉得非常有用在这里谨添加上自己的理解，原文在<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="external">这里</a>。</p><p>Task,Microtask,queues,schedules在这里分别翻译成：任务，微任务，队列，计划。</p><p>以下代码输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">console.log(&apos;script start&apos;);</div><div class="line"></div><div class="line">setTimeout(function() &#123;</div><div class="line">  console.log(&apos;setTimeout&apos;);</div><div class="line">&#125;, 0);</div><div class="line"></div><div class="line">Promise.resolve().then(function() &#123;</div><div class="line">  console.log(&apos;promise1&apos;);</div><div class="line">&#125;).then(function() &#123;</div><div class="line">  console.log(&apos;promise2&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(&apos;script end&apos;);</div></pre></td></tr></table></figure><p>这道题目会出现在面试题之中，一般来说会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">script start</div><div class="line">script end</div><div class="line">promise1</div><div class="line">promise2</div><div class="line">setTimeout</div></pre></td></tr></table></figure><p>为什么会这样呢？以下为摘抄自原文：</p><blockquote><p>每个线程都有其事件循环，所以每个 web worker(工作线程)也有。这样它就可以独立执行，但是同一个源上的所有窗口共享一个事件循环，因为他们可以同步通信。事件循环一直运行，执行排队的任务。一个事件循环拥有多个任务源以保证任务的顺序执行，但是浏览器在每次循环的时候会选择从哪个源选择任务来执行。这样允许浏览器优先执行对性能敏感的任务比如用户输入。</p><p><strong>任务</strong> 是浏览器可以从其中获取内部构件从而执行JavaScript/DOM 作用域并且保证这些操作都顺序执行。在任务之间，浏览器可能会渲染更新。鼠标的点击事件回调，比如解析 HTML, setTimeout都会需要创建任务。<code>setTimeout</code>是在一个时间间隔后为其回调安排一个任务。这样那个<code>setTimeout(function() { console.log(&#39;setTimeout&#39;);}, 0)</code>就会在<code>script end</code>最后输出。</p><p>微任务一般是指在当前执行脚本执行完毕的时候立即执行的任务，比如批量操作之后的动作，或者不以创建一个新任务的性能作为代价来让某些事件异步执行。微任务队列的执行时机是在回调之后执行的因为在这期间没有其它 JavaScript 脚本在执行，并且必须是在每个任务结束之前。在微任务运行期间添加的其它排队的微任务会添加在微任务队列的末尾并且执行。微任务包括<code>mutation observer</code>回调和 promise 回调。<br>MutationObserver是异步的。</p></blockquote><p>关于 Mutataion 可以查看<a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="external">这里</a>。</p><p>当 promise 创建以后，会排入微任务队列中。所以 promise1 和 promise2 会在 setTimeout 之前输出，因为微任务问题会发生在下一个任务之前，当前任务结束之前。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>任务会顺序执行，浏览器会在任务之间渲染</li><li>微任务会顺序执行，执行时机是在每个回调之后并且期间没有其它 JavaScript 在执行并且必须是在每个任务结束之前</li></ul><p>这里有一个很有意思的地方是原文下文的评论有人提问的关于那个<code>es6-promise</code>兼容库使用的<code>setImmediate</code>和<code>process.nextTick</code>方法。前一个是属于任务，后一个差不多是微任务。那么如果写过 vue 的家伙应该对这个 nextTick 很熟悉吧？那么为什么 vue 的数据更新是异步的呢？因为他应该是用了 MutationObserver 所有的操作是异步缓存入队列再在一定的时间内 flush 到 DOM 中，如果使用 nextTick 意思即再插入一个微任务，这个微任务是在对 DOM 更新完毕后执行然后就可以获取到 DOM 更新后的元素内容。<strong>是这么理解的吗？</strong>。欢迎指正。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>原文说的微任务执行时机：</p><blockquote><p>after every callback, as long as no other JavaScript is mid-execution</p></blockquote><p>这里的回调指的是什么？是指每个 JavaScript 堆栈还是什么？不理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看了一篇文章讲述的关于任务，微任务，队列之类的文章觉得非常有用在这里谨添加上自己的理解，原文在&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot; target=&quot;
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="microtask" scheme="http://yoursite.com/tags/microtask/"/>
    
      <category term="task" scheme="http://yoursite.com/tags/task/"/>
    
      <category term="event loop" scheme="http://yoursite.com/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>第五种定位属性</title>
    <link href="http://yoursite.com/2017/12/16/%E7%AC%AC%E4%BA%94%E7%A7%8D%E5%AE%9A%E4%BD%8D%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/12/16/第五种定位属性/</id>
    <published>2017-12-16T15:17:47.000Z</published>
    <updated>2017-12-17T04:26:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章翻译自<a href="https://www.quirksmode.org/blog/archives/2010/12/the_fifth_posit.html" target="_blank" rel="external">The fifth position value</a>，是关于移动端中的定位元素 <code>fixed</code> 的值的问题。<strong>这里只做部分翻译</strong>。前言省略，只是讲述关于浏览器产商历史及 fixed 在桌面和移动端的差异性问题。</p><p><strong>fixed 元素统称为绝对定位元素。</strong></p><h2 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position: fixed"></a>position: fixed</h2><p>引用自 CSS2.1 的规范：</p><blockquote><p>绝对定位是 绝对定位的一个子类。唯一的区别是 fixed 定位是相对于视口的定位。在连续的媒体文档中，fixed 定位的盒子不会随着文档滚动。从这方面上看他们更像是固定的背景图片。</p></blockquote><p>规范和移动端的实际情况分歧越来越大。「fixed 定位的元素没有随着文档流动」被大多数的移动端浏览器所忽略。规范忽略了缩放功能。</p><p>什么是视口？在桌面浏览器中是浏览器窗口，这样 fixed 元素会相对于窗口定位当文档滚动的时候不会滚动。我们需要在移动浏览器中也实现。</p><p>然而移动浏览器有两个视口：视觉视口和布局视口。浏览器应该相对于哪个视口来定位元素呢？</p><p>没有人会感到奇怪如果这是视不同的浏览器而定的。大多数的浏览器会相对于布局视口(layout viewport)。只有诺基亚 Webkit 内核浏览器不是这样的。可以在这个<a href="https://www.quirksmode.org/m/tests/positionfixed.html" target="_blank" rel="external">页面</a>测试.也可以在<a href="https://www.quirksmode.org/css/css2/mobile.html" target="_blank" rel="external">兼容表</a>中查看。</p><h2 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h2><p>当你为 fixed 元素写<code>bottom: 0</code>的样式的时候你就可以更好地看出两种定位方案的区别了。它是被相对定位在盒子的底部。</p><p>以下是绝对定位元素相对于视觉视口：</p><p><img src="/images/visual1.gif" alt=""></p><p>绝对定位元素会像桌面端一样当页面滚动的时候保持不动。</p><p><img src="/images/visual2.gif" alt=""></p><p>虽然这是移动浏览器是很大程度上受到了桌面浏览器的上绝对定位元素的影响，但是在大多数移动浏览器上只有 Nokia WebKit 实现了但是并不是在所有的情况下都是这样的效果。之前讨论过，桌面端的绝对定位元素相对于最小的视觉窗口并不适用于移动浏览器。</p><p>当用户缩放的时候会发生什么？Nokia N8 移除了整个的绝对定位元素。这并不是最好的行为。那么应该去如何展现呢？文档上没说，浏览器也不知道如何去处理。</p><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>其它浏览器尤其是 iOS 上的 Safari，把元素相对于布局视口定位随着文档滚动。这样他们就忽略了文档的最重要的关于绝对定位元素的定义。</p><p>(从本质上来说这样导致<code>position: fixed</code>元素和<code>position: absolute</code>都是是相对于布局视口的，如果<code>position: absolute</code>没有祖先元素是<code>position: realtive</code>定位的，打开<a href="https://www.quirksmode.org/m/tests/positionfixed.html" target="_blank" rel="external">测试页面</a>来观察。</p><p><img src="/images/layout1.gif" alt=""></p><p>绝对定位元素设置为<code>bottom: 0</code>会被放置在布局视口的底部，随着页面滚动。这样他的固定的本质就丢失了，但是是因为它和页面的剩余部分一起滚动和缩放这样就可读性仍然是非常强的。</p><p><img src="/images/layout2.gif" alt=""></p><p>这个方案也不是完美的。绝对元素也许会覆盖住重要的页面内容。设计师们确定<code>absolute</code>元素不可以覆盖任何元素，但是他们可能会忽略掉绝对定位元素因为他们假设用户始终可以滚动一段距离来看元素。如果滚动元素随着页面滚动，那么在滚动元素下的内容将永远不可能被看到。</p><h2 id="hopping-跳跃"><a href="#hopping-跳跃" class="headerlink" title="hopping(跳跃)"></a>hopping(跳跃)</h2><p>其它浏览器尤其是 Opera 和 黑莓 WebKit 浏览器，试图融合这两种技术。初始化的时候会相对于布局窗口定位元素，但是当用户滚动元素的时候会让元素跳到到相对于目前视觉视口的底部。当用户再次滚动的时候又会保持在视觉视口的底部。</p><p>问题是这个跳跃只发生在用户停止滚动半秒之后。这个效果会非常的让人奇怪，在用户没有做出任何命令的时候，绝对定位元素发生了变化。(这里的命令指的是滚动，但是对于大多数普通用户来说可能是不起眼的)。这就解决了绝对元素覆盖住重要信息的问题了。</p><p>缩放怎么办？Opera 移动浏览器表现是最为合理的：当用户放大的时候，绝对定位的元素没有改变其位置。这样用户就可以观察于是它。只有当用户再次缩小的时候，它才会跳跃。</p><p>与此相反，黑莓 WebKit 以复杂的方法试图让元素保持在视力中，但是这个效果很有问题。有时候元素直接消失了，有时候会偏离定位几个像素。然后结果导致绝对定位的元素的内容溢出并且变得不可读。</p><h2 id="其它发现"><a href="#其它发现" class="headerlink" title="其它发现"></a>其它发现</h2><p>安卓就很诡异了。Nexus One 2.2 使用布局视口方案，但是 HTC Legend 2.1 使用 hopping(跳跃)方案(有问题)。我不知道是不是 2.2 和 2.1 版本的问题还是谷哥和 HTC 的差别。</p><p>Samsung Dolfin, Android WebKit, Nokia WebKit 当页面中有<code>&lt;meta viewport&gt;</code>的时候会改变对于绝对定位元素的行为。Nexus One 实现真实的绝对定位(即相对于视觉视口)当你写上<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;</code>，换种说法即如果你不想要优秀的 UI 交互的话。</p><h2 id="position-device-fixed"><a href="#position-device-fixed" class="headerlink" title="position: device-fixed"></a>position: device-fixed</h2><p>两种方案都并不特别地完美。相应地，不妨给出定位的第五个属性<code>device-fixed</code>。这样就可以用来一劳永逸地解决最大的问题。</p><p>如果移动浏览器支持<code>device-fixed</code>并且桌面端不支持，开发者就可以为其中之一创建绝对定位的方案。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>position: device-fixed</code>即像是真实的绝对定位元素相对于视觉视口。无论用户滚动或者缩放都不会改变位置。</p><p>另外，<code>device-fixed</code>元素和其后代元素使用的CSS 像素单位不是 CSS 像素而是物理设备像素(或者如果设备实现了即逻辑像素)。可见这里<a href="https://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html" target="_blank" rel="external">查看</a>三种像素。</p><p>本质上说这样就会让<code>device-fixed</code>元素不可缩放。缩放对于<code>device-fixed</code>元素是没有任何意义的因为这会使里面的内容溢出并且不可读。</p><p>不可缩放是最重要的。不然将和绝对定位元素一样。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>可以用 <strong>Safari 和 黑莓 WebKit</strong> 来浏览<a href="https://www.quirksmode.org/m/tests/devicefixed.html" target="_blank" rel="external">示例</a>，因为只有这些　浏览器暴露了视觉视口和布局视口的分辨率，这样就可以用来计算缩放倍数。</p><h2 id="支持"><a href="#支持" class="headerlink" title="支持"></a>支持</h2><p>这里是假设桌面浏览器不支持<code>device-fixed</code>，移动端浏览器不支持<code>fixed</code>。这样开发者就可以使用<code>fixed</code>和<code>device-fixed</code>这两种效果，确保桌面浏览器和移动浏览器只会对一种样式起效果。</p><p>如果桌面浏览器使用<code>device-fixed</code>或者移动浏览器使用<code>fixed</code>呢？那将不会是绝对定位的元素，应该隐藏还是让其像页面一般的块级元素呢？</p><p>老的黑莓浏览器完全隐藏。平板浏览器支持<code>fixed</code>和<code>device-fixed</code>吗？目前尚不可知。</p><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>事实上<code>device-fixed</code>处理了一种可以被目前的关于定位的定义的规范处理的例子而反对这个<code>device-fixed</code>的定义。虽然规范没有定义缩放而导致规范不完整。</p><p>开发仍然是需要这个真实的绝对定位属性的。与此同时，移动浏览器产商是不会实现这个真实的绝对定位提案的。</p><p><code>device-fixed</code>提供了解决这个方案的方式。首先这是实验性的属性。我理解关于这个提议是不合理的观点。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>有一点是确定的是没有<code>position: device-fixed</code>属性或者类似的方案在移动并不是真正的绝对定位。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在实际工作过程中会遇到 ios 的<code>fixed</code>问题，即当在页面的底部是 fixed 元素的时候，元素里面有 input 框的时候，当点击输入框输入法会遮盖住输入框，通过上面的学习和这个<a href="https://www.quirksmode.org/css/css2/mobile.html" target="_blank" rel="external">文档</a>可知当输入法弹出的时候，由于绝对定位元素是相对于布局视口定位的所以这个时候输入法会遮盖住绝对定位的元素。因为 ios 中当输入法弹出的时候，布局视口并没有滚动，而 ios 中绝对定位元素是相对于 layout viewport(布局视口)来定位，会随着布局视口的滚动而滚动的。这里的解决方案就是可以把元素设置为绝对定位或者滚动窗口即可。不知道是不是这个理？＾。^</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://www.quirksmode.org/blog/archives/2010/12/the_fifth_posit.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The fifth position 
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="fixed" scheme="http://yoursite.com/tags/fixed/"/>
    
  </entry>
  
  <entry>
    <title>常用 Git 命令及工作流</title>
    <link href="http://yoursite.com/2017/12/09/%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2017/12/09/常用-Git-命令及工作流/</id>
    <published>2017-12-09T14:15:24.000Z</published>
    <updated>2017-12-20T16:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>工作过程中使用 Git 作为版本控制和协作的工具经常会遇到各种问题，自己整理了自己常用的命令及一些常见的工作流。</p><h2 id="工作区、暂存区、历史区"><a href="#工作区、暂存区、历史区" class="headerlink" title="工作区、暂存区、历史区"></a>工作区、暂存区、历史区</h2><p>工作区：新添加的文件，任何不在暂存区的文件，不在版本记录中的文件。<br>暂存区：当把工作区的文件用<code>git add</code>之后文件便会在暂存区中。<br>版本库：当使用<code>git commit</code>之后文件就会记入版本库中。</p><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p><code>git init</code>，用 <code>git init --bare /path/to/repo.git</code>创建一个裸的中央仓库。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><code>git log --oneline</code>简略地显示提交信息为一行即只显示<code>SHA1</code>值和少量的提交信息。</p><p><code>git log -p</code>显示提交的详细信息。</p><p><code>git log -p</code>显示最为详细的提交视图。</p><p><code>git log --graph --oneline --decorate</code>详细信息的缩略图。</p><p><code>git log --oneline master..origin/master</code>查看两个分支或者提交之间的差别。<code>master</code>和<code>origin/master</code>可以是提交的 ID 或者是分支。</p><h2 id="检出提交"><a href="#检出提交" class="headerlink" title="检出提交"></a>检出提交</h2><p><code>git checkout commitID file</code>切换文件到指定的提交。</p><p><strong>检出提交 不会损害现在的分支，因为这个已经处于游离的状态。HEAD 一般指向 master 或是其他的本地分支。当检出提交的时候就不再指向一个分支。而是指向一个提交，是一个分离的 HEAD 的状态</strong>。</p><p>当切换到那个提交的时候，那个 commit 上更改文件并不会影响到这个提交，当你在这个状态下添加文件并且提交的时候会发现那个处于游离状态的 commitID 会变化为 commitID2。再次切换回之前的分支的时候，那个 commitID 上的内容并没有被影响，请看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git checkout 75e7a</div><div class="line">touch a.css</div><div class="line">git add a.css</div><div class="line">git commit -am &quot;commit messaege&quot; // 这个时候commid会变</div><div class="line">git checkout test</div><div class="line">git log -p 75e7a</div></pre></td></tr></table></figure><p><code>git commit -am</code>这里只对已经进版本的文件有用，新添加的文件得先<code>git add</code>。</p><p><code>git checkout HEAD file</code>选择文件在暂存区中的修改回归到其最近的提交。</p><p>如果想要回滚某个文件到指定的提交的话可以使用如下命令：</p><p><code>git checkout commitId -- file1/to/restore file2/to/restore</code><br><code>git checkout commitId~1 -- file1/to/restore file2/to/restore</code> 表示回滚到 commitId 前一个 commitId。</p><h2 id="不可撤消及危险的命令"><a href="#不可撤消及危险的命令" class="headerlink" title="不可撤消及危险的命令"></a>不可撤消及危险的命令</h2><p><code>git rebase</code>，<code>git commit --amend</code>，<code>git reset</code>，都不要用在仓库的公共的分支、提交上面。<strong>只适宜操作自己本地的提交即在自己本地的未发布到分支上的提交。</strong></p><p><code>git rebase &lt;base&gt;</code>即将本分支的提交变更到目标提交，base 可以是分支、提交等，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout new-feature</div><div class="line">git rebase master</div><div class="line">git checkout master</div><div class="line">git merge new-feature</div></pre></td></tr></table></figure><p>这样产生一个快速向前的线性提交，而不用再多一次合并提交。</p><p><code>git reset --hard</code>和<code>git reset</code>的区别是当在暂存区里面有文件的时候，<code>--hard</code>会把处于暂存区的文件清除掉，而未加<code>--hard</code>的时候只是把暂存区的文件退回到工作区域，文件并没有消失。</p><p>比如下面的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">touch a.css</div><div class="line">touch b.js</div><div class="line">git add b.js</div><div class="line"></div><div class="line">git status // 查看工作状态</div><div class="line"></div><div class="line">git reset --hard // 重设这个时候处于暂存区的文件 b.js 将不会在工作区域中存在！</div></pre></td></tr></table></figure><p><code>git reset --hard</code>通常和<code>git clean -f</code>一起使用，因为前一个命令只是是将暂存区的文件删除，但是在工作区的文件并没有删除。</p><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>当提交发生了错误的时候可以使用<code>git revert</code>回滚到指定的提交。</p><h2 id="变基和合并"><a href="#变基和合并" class="headerlink" title="变基和合并"></a>变基和合并</h2><p>根据<a href="https://git-scm.com/book/en/v2/Git-Branching-Rebasing" target="_blank" rel="external">Gitbook</a>的描述:</p><blockquote><p>如果是本地的更改使用<code>rebase</code>如果是和他人共享的提交出去分支就不要使用<code>merge</code>。</p></blockquote><h2 id="拉取及合并"><a href="#拉取及合并" class="headerlink" title="拉取及合并"></a>拉取及合并</h2><p><code>git fetch &lt;remote&gt; [branch]</code>当未加上分支名即拉取远程仓库所有的分支否则是拉取指定分支。</p><p><code>git pull</code>是<code>git fetch</code>和<code>git merge</code>的快捷方式。</p><p><code>git pull remote branch:localbarnch</code>若不写 localbarnch 表示默认和当前分支合并。<br><code>git merge --no-ff &lt;branch&gt;</code>将指定分支并入当前分支，但总生成合并提交，用来记录仓库中发生的所有合并。</p><p>当你不想提交暂存区的本地的修改的时候可以先用<code>git stash</code>然后当合并完成再用<code>git stash pop</code>取出之前在暂存区的本地修改。</p><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p><code>git push &lt;remote&gt; --all</code>本地所有分支推送到远程仓库不包含 tags。</p><p><code>git push &lt;remote&gt; --tags</code>本地所有标签推送到远程仓库。</p><p><code>git push -u origin branch</code>将分支推送到远程中央仓库(origin)即在远程也创建一个分支并和本地的分支关联在一起。<code>-u</code>标记将它添加为远程跟踪的分支。设置完可以直接使用<code>git push</code>提交更新了。</p><p><code>git branch -u origin/test</code>分支会和上游分支 test 同步后就可以直接使用<code>git pull</code>拉取代码。</p><p><strong>只推送到那些以 –bare 方式初始化的仓库。</strong></p><p><em>为防止覆盖中央仓库的历史，会拒绝你会导致非快速向前合并的推送请求。如果远程提交历史和本地提交历史分叉，就需要先拉取远程分支再进行提交。慎重使用 –force 选项</em></p><h2 id="提交引用"><a href="#提交引用" class="headerlink" title="提交引用"></a>提交引用</h2><p><code>git show commitID</code>显示提交 id 的信息。</p><h2 id="比较分支不同"><a href="#比较分支不同" class="headerlink" title="比较分支不同"></a>比较分支不同</h2><p><code>git diff</code> 比较工作环境和暂存区的不同，<code>git diff --staged</code> 比较暂存区和上次最新的提交的不同。<code>git diff master branchB</code> 比较两个提交的不同。<br><code>git diff origin/test a.txt</code> 比较远程分支上的文件和现在的文件的不同。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p><code>git branch -m &lt;branch&gt;</code>重命名当前分支</p><p><code>git checkout -b &lt;new-branch&gt; &lt;existing-branch&gt;</code>以<code>&lt;existing-branch&gt;</code>作为基准，若无则是当前分支。</p><p><code>git branch -r</code>查看远程的分支。</p><p>若是想要抓取远程的分支到本地首先得把远程的分支先 fetch 到本地，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch remote remotebranch</div><div class="line">git co -b new-branch remote/remotebranch</div></pre></td></tr></table></figure><p><code>git push origin --delete [分支名]</code>和<code>git push 远程名 :[分支名]</code>删除远程分支。</p><h2 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h2><p>Pull Request 是协作者向目标仓库发起合并请求的方式，在 Github 上假设用户 tristan Fork 了 isolde 的项目，这个时候 tristan 有了项目的副本，然后在本地<code>git clone user/a.git</code>到本地，然后创建功能分支<code>git co -b new-feature</code>在 new-feature 分支上作了修改然后提交到自己的远程仓库，然后在 Github 上面点击 Pull Request 按钮指明自己的源库和源分支和目标仓库(即 isolde 的仓库)和目标分支，然后写上标题就可以了。Github 会发邮件给 isolde。</p><p>当 isolde 接到合并请求进行审阅，然后提建议，tristan 可以进行修改，提交之后会自动通知到 Pull Request中，当 isolde 觉得可以了就会合并请求并关闭 Pull Request。</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><h3 id="中心化工作流"><a href="#中心化工作流" class="headerlink" title="中心化工作流"></a>中心化工作流</h3><p>中心化非常简单即只有一个 master 分支，所有的成员都只是在这一分支下工作。</p><h3 id="功能分支的工作流"><a href="#功能分支的工作流" class="headerlink" title="功能分支的工作流"></a>功能分支的工作流</h3><p>每个人在开始新功能的时候创建功能分支，完成了提交到远程服务器，发布一个 Pull Request，审核通过，再合并到本地的 master 分支然后再推送到远程中央仓库，最后关闭 Pull Request。</p><h3 id="GitFlow-工作流"><a href="#GitFlow-工作流" class="headerlink" title="GitFlow 工作流"></a>GitFlow 工作流</h3><p>一共两个分支：master 和 dev。dev 用于合并功能分支，最后的 master 会为提交打标签。功能分支不合并进 master。</p><p>其实还不止这些，当开发分支新功能收集完毕了可以 fork 开发分支为发布分支，在这个发布分支进行其它 bug 修复，文档等。完成了再合并进 master 并打版本号。随后合并进 dev 分支。 </p><p><img src="/images/git-workflow.png" alt=""></p><p>开发者要在本有一个 master 和 dev 分支。</p><p>当功能开发完成使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git pull origin develop</div><div class="line">git checkout develop</div><div class="line">git merge some-feature</div><div class="line">git push</div><div class="line">git branch -d some-feature</div></pre></td></tr></table></figure><p><code>git checkout -b release-0.1 develop</code>在这个分支上面进行测试文档整理。<br>一旦发布好了就会合并进<code>master</code>和<code>dev</code>分支，并删除<code>release-0.1</code>发布分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge release-0.1</div><div class="line">git push</div><div class="line">git checkout develop</div><div class="line">git merge release-0.1</div><div class="line">git push</div><div class="line">git branch -d release-0.1</div></pre></td></tr></table></figure><p>最后要打标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git tag -a 0.1 -m &quot;Initial public release&quot; master</div><div class="line">git push --tags</div></pre></td></tr></table></figure><p>紧急修复是唯一可以直接从 master 创建的分支。修复完成合并进 master 和 dev 分支。在 master 上打上更新版本。</p><p>当发现紧急 bug</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout -b issue-#001 master</div><div class="line">git checkout master</div><div class="line">git merge issue-#001</div><div class="line">git push</div></pre></td></tr></table></figure><p>最后开发分支也要合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge issue-#001</div><div class="line">git push</div><div class="line">git branch -d issue-#001</div></pre></td></tr></table></figure><h3 id="Fork-工作流"><a href="#Fork-工作流" class="headerlink" title="Fork 工作流"></a>Fork 工作流</h3><p>每个开发都都有两个仓库，一个本地的，一个是服务器的。<strong>开发都是可以推送到自己的服务器仓库。只有项目管理者可以推送到官方仓库。</strong></p><p>大型项目和开源的项目大抵选择这种模式。</p><p>大概过程是项目创建创建裸仓库<code>git init --bare path/to/repo.git</code>，开发者进行 fork，最后开发者在自己的私有仓库进行更改，好了向官方提交 Pull Reqeust，然后项目维护都审核，通过则合并到 master 中。</p><p><a href="https://github.com" target="_blank" rel="external">github</a> 即是这种模式。</p><h2 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h2><p>钩子分为本地钩子和服务端钩子。<br>钩子即在特定事件发生的时候触发的脚本，在<code>.git/hooks</code>下面有默认的示例钩子。</p><h3 id="常用的本地钩子"><a href="#常用的本地钩子" class="headerlink" title="常用的本地钩子"></a>常用的本地钩子</h3><ul><li>pre-commit 提前之前做的事可以用来做<code>lint</code>代码风格，测试等检查。</li><li>prepare-commit-msg 在文本编辑器生成提交信息后调用。用来方便修改压缩的或者合并的提交的提交信息。</li><li>commit-msg 用户输入完提交信息之后用来警告开发者开发没有符合规范。</li><li>post-commit 提交之后的操作。用来在提交之后发送邮件之类的。</li><li>post-checkout 当切换分支或者提交的时候激活。比如 python 在切换分支之后有可能生成 .pyc 文件。这里可以在切换之后删除这些多余的文件。</li><li>pre-rebase 在 git rebase 之前调取，可以用来警告开发者。</li></ul><p>一般来说对于团队来说比如定义代码规范可以在<strong>pre-receive</strong>中进行设置，在本地钩子也可以但是 <strong>.git/hooks</strong> 是不会记入版本历史的所以可以采取符号链接的形式。</p><p><strong>post-receive</strong> 是在 push 推送成功之后可以发送邮件和持续集成系统 jenkins 等。</p><h2 id="日志引用"><a href="#日志引用" class="headerlink" title="日志引用"></a>日志引用</h2><p>当执行了<code>git reflog</code>用来查看引用日志。记录了仓库中的所有更改，而不管有没有提交。比如当使用了<code>git reset</code> 去除了功能分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ad8621a HEAD@&#123;0&#125;: reset: moving to HEAD~3</div><div class="line">298eb9f HEAD@&#123;1&#125;: commit: 一些提交信息</div><div class="line">bbe9012 HEAD@&#123;2&#125;: commit: 继续开发</div><div class="line">9cb79fa HEAD@&#123;3&#125;: commit: 开始新特性开发</div></pre></td></tr></table></figure><p>若要回到 reset 之前的状态可以使用<code>git checkout HEAD@{1}</code>。这样会处于分支分离的状态，可以从那里创建新的分支。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工作过程中使用 Git 作为版本控制和协作的工具经常会遇到各种问题，自己整理了自己常用的命令及一些常见的工作流。&lt;/p&gt;
&lt;h2 id=&quot;工作区、暂存区、历史区&quot;&gt;&lt;a href=&quot;#工作区、暂存区、历史区&quot; class=&quot;headerlink&quot; title=&quot;工作区、暂存
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>两种视口的故事系列之二</title>
    <link href="http://yoursite.com/2017/12/04/%E4%B8%A4%E7%A7%8D%E8%A7%86%E5%8F%A3%E7%9A%84%E6%95%85%E4%BA%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8C/"/>
    <id>http://yoursite.com/2017/12/04/两种视口的故事系列之二/</id>
    <published>2017-12-04T15:18:28.000Z</published>
    <updated>2017-12-09T02:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>前一篇介绍了桌面浏览器的 <code>viewport</code> 的行为。本篇是来讨论移动端浏览器的行为的。此翻译来自<a href="https://www.quirksmode.org/mobile/viewports2.html" target="_blank" rel="external">这里</a>。</p><h2 id="移动端浏览器的问题"><a href="#移动端浏览器的问题" class="headerlink" title="移动端浏览器的问题"></a>移动端浏览器的问题</h2><p>当我们比较两种浏览器的不同的时候，最为显著的区别就是屏幕的大小。在一个桌面浏览器为主的网站中，移动浏览器所显示的内容要比桌面浏览器明显少很多，除非要么缩小字体到难以阅读的地步或者为了在手机屏幕上显示而只显示网站的一小部分。</p><p>一个移动端屏幕比桌面端的屏幕要小上很多，设想一下一个最大为 400px 有时候甚至要更小的移动端屏幕。(某些手机可能会检测出更大的屏幕宽度不过其实这是设备在撒谎-至少他们提供是对我们无用的信息)。</p><p>处于中间层的平板设备比如 iPad 或者传闻中的基于 HP webOS 的设备会抹平移动端和桌面端之间的差异，然而还是无法解决根本的问题。网站必须在移动端上运行良好，所以我们不得不让其在小屏幕上适配显示得好些。</p><p>主要的问题在于 CSS 样式表，特别是视口的分辨率。如果我们照抄桌面端的话，移动端的样式将会是灾难性地失败。</p><p>让我们回到设置侧边栏宽度为 <code>10%</code> 上。如果移动端如桌面端的行为那样，会给侧边栏最多 40px 的宽度而这显然太拥挤了。你的流式布局看上去将会压得非常扁平。</p><p>解决问题的方法之一是单独为移动端构建一个网站。即使抛开是否应该那样做的最根本的问题，实际的问题是只有极少数的建站者能够胸有成竹地构建适配移动端设备。</p><p>移动浏览器产商想要为客户提供最好的可能的体验即尽量向桌面端靠拢。一些技巧是必要的。</p><h2 id="两种视口视觉"><a href="#两种视口视觉" class="headerlink" title="两种视口视觉"></a>两种视口视觉</h2><p>视口太小无法作为你的 CSS 布局的基础。最容易想到的办法就是让视口更宽。即，然而需要划分为两部分：visual viewport(视觉的视口)和 layout viewport(布局视口)。</p><p>George Cummins 在 Stack Overflow <a href="http://stackoverflow.com/questions/6333927/difference-between-visual-viewport-and-layout-viewport" target="_blank" rel="external">这里</a> 解释道：</p><blockquote><p>把布局视口想象为一张不会改变大小和形状的图片。想象一下你有一个比图片小的相框，透过它你观看到整个大图像。小相框是由不透明的材料所包裹着这样就会遮挡你的视线除了大图片中的一小部分。你能透过相框看见的图像的一部分即为视觉的视口。当你握住相框的时候你可以往后退(缩小)以便看到整张图片，或者你可以走近(放大)只看图片的一小部分。你也可以转动相框的角度，然而这张大图的大小和形状(布局视口)从来不会改变。</p></blockquote><p>也可以看 chris <a href="http://stackoverflow.com/questions/7344886/visual-viewport-vs-layout-viewport-on-mobile-devices" target="_blank" rel="external">这里</a> 的评论：</p><p>视觉视口是此时在屏幕上显示的页面的一部分。用户可以滚动来浏览网页或者缩放来改变视觉口的大小。</p><p><img src="/images/mobile_visualviewport.jpg" alt=""></p><p>然而，在 CSS 布局中，特别是百分比宽度，是相对于布局视口来计算宽度的，布局视口往往比视觉视口要宽得多。</p><p>所以 <code>&lt;html&gt;</code> 元素初始化会是布局视口的宽度，并且你的样式会被渲染得好似屏幕会明显比手机屏幕要宽大得多。这样会确保你网站的布局和桌面端的保持一致。</p><p>布局视口的宽度有大呢？每个浏览器显示不一样，iPhone Safari 浏览器使用 980px，Opera 850px，Android WebKit 800px，IE 是 974px。</p><p>一些浏览器有些非常奇怪的行为：</p><ul><li>塞班 Webkit 试图让布局视口和视觉视口保持一致，这会导致百分比的元素看起来非常古怪。然而如果页面没有适配进视觉视口的话是由于浏览器的把布局视口的绝对宽度拉伸到了最大宽度 850px。</li><li>三星 WebKit(bada)以最宽的元素作为布局视口的最大宽度。</li><li>黑霉手机上布局视口在 100% 缩放的时候和视觉视口保持一致。</li></ul><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><p>两种视口都用像素表示。但是当视觉视口分辨率随着用户缩放而改变的时候(如果你放大，屏幕上会显示更少像素的样式)，布局视口分辨率保持不变。(如果不是那样的话你的页面会一直不断地重绘就像重新计算百分比宽度一样)。</p><h2 id="理解布局视口"><a href="#理解布局视口" class="headerlink" title="理解布局视口"></a>理解布局视口</h2><p>为了理解布局视口的大小我们不得不来理解一下当页面完全放大的时候会发生什么。许多移动浏览器初始化完全缩小的模式来显示页面。</p><p>原理是这样的：浏览器选择让他们的布局视口的分辨率以完全缩小的模式来完全覆盖屏幕(即等于视觉视口)。</p><p><img src="/images/mobile_viewportzoomedout.jpg" alt=""></p><p>这样一来布局视口的宽度和高度将在最大化缩放模式下等于屏幕上而不管屏幕上显示的任何元素。当用户放大分辨率保持不变。</p><p>布局视口是保持不变的。如果你放置你的苹果手机，视觉视口会改变，但是浏览器是以轻微地放大来适应这个新方向，所以布局视口再一次和视觉视口保持一致。</p><p><img src="/images/mobile_viewportzoomedout_la.jpg" alt=""></p><p>这会导致布局视口的高度受到影响，大体上会比纵向模式要小。但是开发者并不开心高度而只关心宽度。</p><p><img src="/images/mobile_layoutviewport_la.jpg" alt=""></p><h2 id="布局视口的分辨率"><a href="#布局视口的分辨率" class="headerlink" title="布局视口的分辨率"></a>布局视口的分辨率</h2><p>现在要测量这两个视口的分辨率。多亏了浏览器大战给予我们的两个属性对。</p><p><code>document.documentElement.clientWidth</code> 和 <code>-Height</code> 包含了视口的分辨率。</p><p><img src="/images/mobile_client.jpg" alt=""></p><p>当更改方向的话只是高度改变了，宽度不变。</p><p><img src="/images/mobile_client_la.jpg" alt=""></p><h2 id="视觉视口的分辨率"><a href="#视觉视口的分辨率" class="headerlink" title="视觉视口的分辨率"></a>视觉视口的分辨率</h2><p>视觉视口的分辨率是由 <code>window.innerWidth/Height</code> 得出。很明显地会随着用户放大或缩小而改变，这样屏幕上显示的更多或者更少的像素的内容。如果看过上一篇文章这个就当就是相当于桌面浏览器的 <code>html</code> 元素。</p><p><img src="/images/mobile_inner.jpg" alt=""></p><p>很不幸的是存在大量的不兼容性。这么多浏览器仍然不得不为视觉视口的测量添加支持。然后，没有任何浏览器在其它属性对中应用这种测量方法，所以我猜 <code>window.innerWidth/Height</code> 是一个标准的，虽然没有被很好地支持。</p><h2 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h2><p>在桌面浏览器中，<code>screen.width/height</code> 以设备像素为单位输出屏幕大小。在桌面端，作为开发进行你从来不关心这个信息。你只是关心在其上有多少像素的样式而不是屏幕的物理大小。</p><p><img src="/images/mobile_screen.jpg" alt=""></p><h2 id="缩放的比例"><a href="#缩放的比例" class="headerlink" title="缩放的比例"></a>缩放的比例</h2><p>直接读取缩放的比例是不可能的，但你可以通过 <code>window.innerWidth / screen.width</code> 来获得。当然这必须是两个属性都被支持的情况下。</p><p>幸运的是缩放比例并不重要。你只需要关心屏幕上有多少 CSS 像素即可。如果浏览器支持用 <code>window.innerWidth</code> 来获得。</p><h2 id="滚动位移"><a href="#滚动位移" class="headerlink" title="滚动位移"></a>滚动位移</h2><p>你也需要知道视觉视口相对于布局视口的坐标即滚动位移，在桌面端是存储在 <code>window.pageX/pageY</code>中。</p><p><img src="/images/mobile_page.jpg" alt=""></p><h2 id="html-元素"><a href="#html-元素" class="headerlink" title="html 元素"></a>html 元素</h2><p>在桌面端，<code>document.documentElement.offsetWidth/Height</code> 获得 <code>html</code> 元素的 CSS 像素的总大小。</p><p><img src="/images/mobile_offset.jpg" alt=""></p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>媒体查询和桌面端保持一致。<code>width/height</code> 使用布局视口作为参考 并且是以样式像素为单位，<code>device-width/height</code> 使用设备屏幕并且以设备像素来测算。</p><p>换句话说，<code>width/height</code> 表示 <code>document.documentElement.clientWidth/Height</code> 即布局视口的值，然而 <code>device-width/height</code> 表示 <code>screen.width/height</code>。(在所有浏览器均有效，即使表示的值不正确)。</p><p><img src="/images/mobile_mediaqueries.jpg" alt=""></p><p>那么对于开发者来说哪种计算方式更加有用呢？答案是，不知道。<br>起先我认为 <code>device-width</code> 会是更加重要的，因为它提供了设备更多的信息以便我们使用。比如，你会调整你的布局的宽度来适配设备的宽度。但是其实你可以就不用 <code>&lt;meta view-port&gt;</code> 标签，并不一定要在媒体查询中使用 <code>device-width</code>。</p><p>那么最终 <code>width</code> 会是更加重要的媒体查询吗？可能，它为浏览器产商提供了其认为的在这个设备上一个网站的合适的宽度的线索。但是是相当模糊的是，<code>width</code> 属性实际上并没有提供其它信息了。</p><p>所以我没下定论。我只是觉得媒体查询用来区分你是在桌面，平板或者移动端相当有用，但是在区分各种各样的平板和移动设备上却并不是那么有用。</p><h2 id="事件坐标"><a href="#事件坐标" class="headerlink" title="事件坐标"></a>事件坐标</h2><p>事件坐标在桌面端基本上是有效的。然而不幸的是，12 个被测试的浏览器中只有两个浏览器，塞班 WebKit 和 Iris, 得出了三个完全准确的属性值。其它浏览器都或多或少的严重问题。</p><p><code>pageX/Y</code> 还是相对于页面的位移的样式像素，和桌面端一样这是三个中最为有用的一个属性对。</p><p><img src="/images/mobile_pageXY.jpg" alt=""></p><p><code>clientX/Y</code> 是相对于视觉视口的样式像素值。这有用，虽然我不完全确定这有何好处。</p><p><code>screenX/Y</code> 是相对于设备的设备像素值。当然了这个和 <code>clientX/y</code>  的值是一样的，所以这个属性没啥用。所以就像桌面端的一样，不必关心这个值。</p><p><img src="/images/mobile_clientXY.jpg" alt=""></p><h2 id="Meta-viewport"><a href="#Meta-viewport" class="headerlink" title="Meta viewport"></a>Meta viewport</h2><p>最后来讨论元素 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=320&quot;&gt;;</code> 之前是苹果的一个扩展然后被许多其它产商拷贝了。这是为了改变布局视口的大小的，为了理解它为什么是属性的，可以先后退一步看下。</p><p>假设你在写一个简单页面并且没有为元素设置宽度。现在它们会扩张来占满布局视口 100% 的宽度。大多数浏览器会缩小以便在屏幕上显示整个的布局视口。效果如下：</p><p><img src="/images/mq_none.jpg" alt=""></p><p>所有的用户会立即放大，这是可行的，但是大多数浏览器会保持元素的宽度不变，让文字难以阅读。</p><p><img src="/images/mq_none_zoomed.jpg" alt=""></p><p>(安卓的 WebKit是个意外，它会减小包含文字的元素的大小以适配屏幕。这是明智的，我觉得其它浏览器产商应该复制这一行为。</p><p>现在你可以设置 <code>html {width: 320px}</code>。现在 <code>&lt;html&gt;</code> 元素收缩，其它元素现在也适配于是 320px 的宽度。但是当用户面对一个缩小到基本没有内容的时候并不是一开始时就会产生效果除非用户放大的时候这才会有用。</p><p><img src="/images/mq_html300.jpg" alt=""></p><p>为了解决这个问题苹果发明了视口元标签。当你设置 <code>&lt;meta name=&quot;viewport&quot; content=&quot;width=320&quot;&gt;</code> 你设置布局视口的宽度为 320px。现在页面的初始状态是正确的。</p><p><img src="/images/mq_yes.jpg" alt=""></p><p>你可以设置布局视口为任意的分辨率，包括 <code>device-width</code>.<code>device-width</code> 引用的是 <code>screen.width</code> 并且相应地调整布局视口 的大小。</p><p>有一个特殊情况。有时候准确的 <code>screen.width</code> 并没多大用处因为像素值太高了。举个例子，谷歌的 Nexus One 准确宽度是 480px，但是谷歌工程师认为当使用 <code>device-width</code> 赋值一个 480px 宽的布局视口显得太大了。所以他们决定缩小到之前的 2/3 大小，所以 <code>device-width</code> 变成 320px，和 iPhone一样。</p><p>据说，新苹果会拥有更高的像素值(并不一定是要更大的屏幕)。苹果复制这一行为我并不感到惊讶。或许最后 <code>device-width</code> 还是 320px呢。</p><p>最后还有一些相关的研究文章，在这就不一一写出了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么，这里个人的感觉就是一直不是明白这个移动端的渲染策略，现在明白了个大概，当没有设置 <code>&lt;meta name=&quot;viewport&quot;&gt;</code> 的时候会自动完全缩小以适配到视觉视口的大小。然后最形象的还是开头的那个相框里面的画，当你拿得越远的时候就会看到整幅画，当你离得越近的时候就只会看清某一部分。越远即缩小，越近即放大。视觉视口大小是会改变的，而布局视口是不变的。</p><p><strong>和桌面端对比这里的布局视口就是桌面端的视口，而视觉视口即 <code>html</code> 元素</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前一篇介绍了桌面浏览器的 &lt;code&gt;viewport&lt;/code&gt; 的行为。本篇是来讨论移动端浏览器的行为的。此翻译来自&lt;a href=&quot;https://www.quirksmode.org/mobile/viewports2.html&quot; target=&quot;_blank&quot; 
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
      <category term="viewport" scheme="http://yoursite.com/tags/viewport/"/>
    
  </entry>
  
  <entry>
    <title>两种视口的故事系列之一</title>
    <link href="http://yoursite.com/2017/12/03/%E4%B8%A4%E7%A7%8D%E8%A7%86%E7%AA%97%E7%9A%84%E6%95%85%E4%BA%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80/"/>
    <id>http://yoursite.com/2017/12/03/两种视窗的故事系列之一/</id>
    <published>2017-12-03T11:12:57.000Z</published>
    <updated>2017-12-08T12:15:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于视口即 <strong>viewport</strong> 的论述，本文章主要翻译自 <a href="https://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="external">A tale of two viewports</a>。</p><blockquote><p>在这个系列中将会阐述视口和各种重要元素比如 <code>html</code> 元素的宽度的显示机制，当然还包括 <code>window</code> 和 <code>screen</code> 元素。</p></blockquote><p>本篇文章主要讲述的是桌面浏览器，然而主要上的是为讲解移动浏览器所作的铺垫。大多数开发人员可可能将会直观地理解大多数桌面浏览器的概念。<br>在移动端中我们将会发现同样但更加复杂的概念，而事先基于大家都理解的概念进行讨论将会极大在帮助你理解移动端浏览器。</p><h2 id="概念：设备像素和-CSS-像素"><a href="#概念：设备像素和-CSS-像素" class="headerlink" title="概念：设备像素和 CSS 像素"></a>概念：设备像素和 CSS 像素</h2><p>CSS 像素和设备像素是不同的概念。</p><p>设备像素指的是那种可以直观地看到的正确的大小。这种像确定了你所在的设备的准确的分辨率，可以使用 <code>screen.width</code> 和 <code>screen.height</code> 读取出来。</p><p>如果设定元素的宽度为 <code>width: 128px</code>，而你的显示器是 1024px 宽，当你最大化你的浏览器的时候，元素会放大8倍以适配到你的显示器。</p><p>如果用户使用放大，计算将会改变。如果放大 2 倍, 宽度为 128px 的元素在 1024px 的显示器上只会适配到 4 倍大小。</p><p>放大在现代浏览器即扩张了像素的大小。并不是元素的宽度由 128 变为 256像素；相反是像素点放大了 2 倍大小。实际上元素还是 128px 宽度，即使他占用了 256px 的空间。</p><p>换句话说，放大到 2 倍让一个 CSS 像素变为设备像素的 4 倍（宽度的 2 倍，高度的 2 倍得到 4 倍）。</p><p>以下图片可以说明这种概念。4 像素在 100% 缩放。CSS 像素完全和设备像素重叠。</p><p><img src="/images/csspixels_100.gif" alt=""></p><p>现在当缩小。CSS 像素开始收缩，意味着一个设备像素会和几个 CSS 像素重叠。</p><p><img src="/images/csspixels_out.gif" alt=""></p><p>当你放大的时候，会发生相反的情况。CSS 像素开始增大，现在一个 CSS 像素是几个设备像素重叠。</p><p><img src="/images/csspixels_in.gif" alt=""></p><p>这里想指明的是你只需关注 CSS像素，这是你的样式表所渲染出来的。</p><p>设备像素基本上对你和用户是无用的。用户会缩放到自己认为适合阅读的样子。浏览器会自动让你的 CSS 样式放大或缩小。</p><h2 id="100-缩放"><a href="#100-缩放" class="headerlink" title="100% 缩放"></a>100% 缩放</h2><p>100% 缩放即 1 CSS 像素等于 1 设备像素。</p><p>100% 缩放对于接下来的阐述很有用，但是你无需在日常生活中过度担心。在桌面端即使用户放大或者缩小 CSS 像素会保证你的布局等比缩放。</p><h2 id="屏幕大小"><a href="#屏幕大小" class="headerlink" title="屏幕大小"></a>屏幕大小</h2><p>指的是用户显示器的大小而不是浏览器的。可以用 <code>screen.width</code> 和 <code>screen.height</code> 求出。这些像素是不可能改变的。</p><p><img src="/images/desktop_screen.jpg" alt=""></p><p>这些一般情况无用，只是对于网页统计网站有用。</p><h2 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h2><p>如果你想要知道浏览器容器的内部大小。这些是你的 CSS 布局可使用的。可以使用 <code>window.innerWidth</code> 和 <code>window.innerHeight</code> 求出。</p><p><img src="/images/desktop_inner.jpg" alt=""></p><p>很明显，浏览器窗口的内部宽度是用 CSS 像素来表示的。你需要知道你可以在浏览器窗口如何写布局，并且会随着用户的缩小而递减。当用户缩小你得到更少的可用的浏览器窗口空间，<code>window.innerWidth</code> 和 <code>window.innerHeight</code> 会减少。</p><p><strong>（唯一的例外是 Opera, 当用户缩小的时候 <code>window.innerWidth/innerHeight</code> 并没有减少，而是用设备像素来计算）在桌面端会非常恼人，对于移动端是致命的。</strong></p><p><img src="/images/desktop_inner_zoomed.jpg" alt=""></p><p>高度和宽度都包含滚动条的高度和宽度。</p><h2 id="滚动位移"><a href="#滚动位移" class="headerlink" title="滚动位移"></a>滚动位移</h2><p>可以通过 <code>window.pageXOffset</code> 和 <code>window.pageYOffset</code> 来计算窗口的滚动距离。这两个属性在不同的浏览器表现会有不同可用如下函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function getScrollOffset() &#123;</div><div class="line">  let supportPageOffset = window.pageXOffset !== undefined</div><div class="line">  let isCSS1Compat = ((document.compatMode || &quot;&quot;) === &quot;CSS1Compat&quot;)</div><div class="line"></div><div class="line">  let scrollLeft = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;</div><div class="line">  let scrollTop = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    scrollTop: scrollTop,</div><div class="line">    scrollLeft: scrollLeft</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><img src="/images/desktop_page.jpg" alt=""></p><p>这些属性都是以 CSS 像素计算的。你想要知道文档滚动了多少距离，处于什么的缩放状态。</p><p>理论上，当用户往上滚动并且放大，<code>window.pageX/YOffset</code> 将会改变。然而，当用户缩放的时候，浏览器试图保持相同的元素在可视区域的顶部。这个并不是像所期望的那样完美，但是这意味着实际上 <code>window.pageX/YOffset</code> 并不会真正改变：滚动的出浏览器窗口的距离会保持不变。</p><p><img src="/images/desktop_page_zoomed.jpg" alt=""></p><h2 id="视口概念"><a href="#视口概念" class="headerlink" title="视口概念"></a>视口概念</h2><p>在介绍更多的 JavaScript 属性之前介绍一个概念：视口。</p><p>视口是为了限制你最外层的元素 html。</p><p>或者有一点模糊。举个例子。当你有一个流式布局然后其中一个侧边栏的宽度是 10%，当你调整浏览器窗口大小的时候侧边栏的大小也会跟着改变。其中的原理是什么呢？</p><p>侧边是其父元素的宽度的 10%。这里是 <code>&lt;body&gt;</code> 元素，所有的块级元素都是其父元素的 100% 的宽度。<code>&lt;body&gt;</code> 元素的父元素是 <code>&lt;html&gt;</code>。</p><p><code>&lt;html&gt;</code> 的宽度为浏览器的宽度。这就是为什么侧边栏是浏览器窗口的 10% 宽度的缘故。所有的开发者都可以很直观地明白。</p><p>你所不知道的是，理论上，<code>&lt;html&gt;</code> 元素宽度是由视口所决定的。<code>&lt;html&gt;</code> 是 100% 的视口的宽度。</p><p>视口被定义为浏览器窗口。但并不是一个 HTML 的结构的一部分，所以你无法用 CSS 来影响它。桌面端它拥有浏览器窗口的宽度和调试。在移动端则会更加复杂。</p><h2 id="视口的影响"><a href="#视口的影响" class="headerlink" title="视口的影响"></a>视口的影响</h2><p>有些奇怪的问题。可以缩放 <a href="https://www.quirksmode.org/mobile/viewports.html" target="_blank" rel="external">该页面</a>。滚动到顶，然后缩小些浏览器窗口直到浏览器内容超出浏览器窗口。</p><p>然后水平滚动到右边就会发现顶部的条没有正确地显示，空出一一块白色的区域，没有填满整个浏览器窗口。</p><p><img src="/images/desktop_htmlbehaviour.jpg" alt=""></p><p>这个行为是视口如何被定义造成的。定义了头部栏宽度为 <code>html</code> 元素的 100%，即浏览器窗口的 100%。</p><p>问题在于：当是 100% 缩放的时候显示是正常的，但是当你缩小视口，而网站的内容超出了视口的宽度的时候。这其实并没有什么问题，内容现在溢出了 <code>&lt;html&gt;</code> 元素，但是元素有一个 <code>overflow: visible</code> 属性，意味着溢出的内容在任何情况下都会显示。</p><p>蓝色的背景条没有溢出。因为我我为它赋值 <code>width: 100%</code> 然后，浏览器会给他视口的宽度。浏览器并不会关心宽度是否过小。</p><p><img src="/images/desktop_100percent.jpg" alt=""></p><h2 id="文档宽度"><a href="#文档宽度" class="headerlink" title="文档宽度?"></a>文档宽度?</h2><p>我们需要知道页面所有内容的宽度，包括那些溢出的。据我所知，不可能找得到(除非你为页面上的每个元素单独计算其宽度和外边距，但是是含蓄地说来，这是极易出错的)。</p><p>我觉得需要一个 JavaScript 的属性来计算出文档的宽度。</p><p><img src="/images/desktop_documentwidth.jpg" alt=""></p><p>如果我们想要更激进点，为什么不把这个值暴露到 CSS 上呢？我想要让我的蓝色的头部的背景是 document 宽度的 100% 而不是 <code>&lt;html&gt;</code> 元素的宽度。(这个一定会非常的难办的，并且如果它是难以实现地话，我并不会感到奇怪)。</p><p>你们觉得浏览器生产商会办到吗？</p><h2 id="测量视口的宽度和高度"><a href="#测量视口的宽度和高度" class="headerlink" title="测量视口的宽度和高度"></a>测量视口的宽度和高度</h2><p>使用 <code>document.documentElement.clientWidth/Height</code> 以获得视口的分辨率。</p><p><img src="/images/desktop_client.jpg" alt=""></p><p>如果你了解 DOM，你知道实际上 <code>document.documentElement</code> 实际上是 <code>&lt;html&gt;</code> 元素：HTML 文档的根元素。然而视口是比 <code>html</code> 更高一级的元素，它包含 <code>html</code> 元素。如果你给 <code>html</code> 元素赋值宽度可能会导致一些问题(虽然可以设置宽度)。</p><p>在这样的情况下 <code>document.documentElement.clientWidth/Height</code> 是提供的视口的宽度而不是 <code>html</code> 元素的。(这是这个元素的特殊的属性对特例。在其它情况下是表示的真实元素的宽度)。</p><p><img src="/images/desktop_client_smallpage.jpg" alt=""></p><p>所以 <code>document.documentElement.clientWidth/Height</code> 总是会返回的是视口的分辨率，而不管 <code>html</code> 元素的分辨率。</p><h2 id="两个属性值对"><a href="#两个属性值对" class="headerlink" title="两个属性值对"></a>两个属性值对</h2><p><code>window.innerWidth/Height</code> 也可以返回视口的分辨率。</p><p>官方两者的主要区别是 <code>window.innerWidth/Height</code> 包括了滚动条而 <code>document.documentElement.clientWidth/Height</code> 并不包含。这真是让人有些摸不着头脑。</p><p>这是由于浏览器大战的遗留问题。之前 Netscape 只支持 <code>window.innerWidth/Height</code>，而 IE 只支持 <code>document.documentElement.clientWidth/Height</code>，从那里起其它浏览器也开始支持 <code>document.documentElement.clientWidth/Height</code>，而 IE 不支持 <code>window.innerWidth/Height</code>。</p><p>在桌面端拥有这两个属性值对只有细微的影响然而在移动却不尽然。</p><h2 id="测量-lt-html-gt-元素"><a href="#测量-lt-html-gt-元素" class="headerlink" title="测量 &lt;html&gt; 元素"></a>测量 <code>&lt;html&gt;</code> 元素</h2><p><code>clientWidth/Height</code> 测量视口的分辨率。用 <code>document.documentElement.offsetWidth/Height</code> 可以得出。</p><p><img src="/images/desktop_offset.jpg" alt=""></p><p>这些属性会让你以块状元素的形式访问 <code>html</code> 元素；如果你设置 <code>html</code> 元素的宽度的时候就可以取得到值。</p><p><img src="/images/desktop_offset_smallpage.jpg" alt=""></p><h2 id="事件的坐标"><a href="#事件的坐标" class="headerlink" title="事件的坐标"></a>事件的坐标</h2><p>事件的坐标。当一个鼠标事件发生时，有不少于 5 个属性对会暴露给你为你提供准确的事件的坐标位置信息。这其中主要有三个是重要的：</p><p>－ <code>pageX/Y</code> 会提供相对于 <code>html</code> 元素的坐标以 CSS 像素表示。<br>－　<code>clientX/Y</code> 提供相对于视口的坐标以 CSS 像素表示。</p><ul><li><code>screenX/Y</code> 提供相对于屏幕的坐标以 设备像素表示。</li></ul><p><img src="/images/desktop_pageXY.jpg" alt=""></p><p>在 90% 的时间里，你会使用 <code>pageX/Y</code> 来获得事件发生的位置相对于文档的坐标。其它 10% 的时间你会使用 <code>clientX/Y</code>。你永远都不会想知道相对于屏幕的事件坐标。</p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>最后稍微谈一下媒体查询。主要思路是这样的：你想要定义 CSS 样式规则当页面大于，等于，小于设定的大小的时候生效。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">div.sidebar &#123;</div><div class="line">width: 300px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@media all and (max-width: 400px) &#123;</div><div class="line">// styles assigned when width is smaller than 400px;</div><div class="line">div.sidebar &#123;</div><div class="line">width: 100px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在侧边栏是 300 像素，除了当页面宽度比 400 像素还要小的时候它变为 100 像素。</p><p>现在的问题是这里的宽度是指的哪个元素？</p><p>主要有两个相关的媒体查询语句：<code>width/height</code> 和 <code>device-width/device-height</code>。</p><ul><li><code>width/height</code> 值和 <code>document.documentElement.clientWidth/Height</code>(即视口)。是以 CSS 像素表示。</li><li><code>device-width/device-height</code> 和 <code>screen.width/height</code> 一样。是以设备像素表示。</li></ul><p><img src="/images/desktop_mediaqueries.jpg" alt=""></p><p>你会使用哪个？毫无疑问当然是 <code>width</code>。开发进行们对于设备宽度是没有兴趣的。这个宽度是浏览器窗口计算得出的。</p><p>所以在桌面端使用 <code>width</code> 而不是 <code>device-width</code>。接下来，我们将会看到这种情况在移动端会相当的复杂。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>深入总结完了桌面浏览器的行为。<a href="http://troland.github.io/2017/12/04/两种视口的故事系列之二/" target="_blank" rel="external">第二部分</a>将会把这些概念应用于移动端并且着重指出其与移动端的不同的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于视口即 &lt;strong&gt;viewport&lt;/strong&gt; 的论述，本文章主要翻译自 &lt;a href=&quot;https://www.quirksmode.org/mobile/viewports.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;A 
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
      <category term="viewport" scheme="http://yoursite.com/tags/viewport/"/>
    
  </entry>
  
  <entry>
    <title>事件委托，事件代理，发布者订阅者模式</title>
    <link href="http://yoursite.com/2017/11/19/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%EF%BC%8C%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%EF%BC%8C%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/11/19/事件委托，事件代理，发布者订阅者模式/</id>
    <published>2017-11-19T14:51:21.000Z</published>
    <updated>2017-11-21T15:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>事件委托，事件代理，pub/sub 是工作常用的工作模式，也许只是你没有注意到而已。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><blockquote><p>事件委托：当你通过动态添加元素的时候，如果想要为这个元素绑定事件不能够直接使用诸如<code>onclick</code>方法，只能在其父元素绑定事件，常见于通过 <code>ajax</code> 请求数据。</p></blockquote><p>简单地写如下示例代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 通过target来实现来辨别是不是那个元素</div><div class="line">function delegate(dom, eventType, selector, fn) &#123;</div><div class="line">  dom.addEventListener(eventType, function (e) &#123;</div><div class="line">    // var target = e.target;</div><div class="line">    // for (target !== dom; target = e.target;) &#123;</div><div class="line">    //</div><div class="line">    // &#125;</div><div class="line">    var cur = e.target, target = e.target, cur;</div><div class="line">    for (; cur != this; cur = target.parentNode || this) &#123;</div><div class="line">      if (cur.classList.contains(selector)) &#123;</div><div class="line">        fn.call(cur, e);</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>即监听事件的 <code>target</code> 属性来和 <code>selector</code> 进行比对，若是则应用回调函数。</p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><blockquote><p>事件代理： 即为改变函数的上下文。</p></blockquote><p>使用场景：常见于 DOM 事件的绑定上下文的改变。之前有在用　<code>Backbone</code> 的时候经常会这样用：</p><p><code>this.$el.on(&#39;click&#39;, &#39;.item&#39;, $.proxy(this, this.itemClick))</code>　。</p><p>用于在　<code>itemClick</code> 绑定的事件中让其上下文为对象。而不是 <code>DOM</code> 元素。翻看 <code>jQuery</code> 源码可见如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">proxy: function( fn, context ) &#123;</div><div class="line">var tmp, args, proxy;</div><div class="line"></div><div class="line">if ( typeof context === &quot;string&quot; ) &#123;</div><div class="line">tmp = fn[ context ];</div><div class="line">context = fn;</div><div class="line">fn = tmp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Quick check to determine if target is callable, in the spec</div><div class="line">// this throws a TypeError, but we will just return undefined.</div><div class="line">if ( !jQuery.isFunction( fn ) ) &#123;</div><div class="line">return undefined;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Simulated bind</div><div class="line">args = slice.call( arguments, 2 );</div><div class="line">proxy = function() &#123;</div><div class="line">return fn.apply( context || this, args.concat( slice.call( arguments ) ) );</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// Set the guid of unique handler to the same of original handler, so it can be removed</div><div class="line">proxy.guid = fn.guid = fn.guid || jQuery.guid++;</div><div class="line"></div><div class="line">return proxy;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还是很容易理解的, 说到改变函数上下文还可以使用 <code>bind</code> 。</p><p>具体可查看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">这里</a>。</p><h2 id="发布者订阅者模式"><a href="#发布者订阅者模式" class="headerlink" title="发布者订阅者模式"></a>发布者订阅者模式</h2><p>发布进行订阅模式是常用的模式比如在 <code>Dom</code> 事件监听的时候就是这种模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$dom.on(&apos;click&apos;, fn);</div><div class="line">$dom.trigger(&apos;click&apos;, args);</div></pre></td></tr></table></figure><p>以上 <code>on</code> 即为订阅，<code>trigger</code> 即为发布。这个对于理解 <strong>JavaScript</strong> 框架中的双向监听是有益处的。可以手写一个如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var pubSub = &#123;</div><div class="line">  subscribers: [],</div><div class="line">  publish: function (eventType) &#123;</div><div class="line">    var slice = Array.prototype.slice;</div><div class="line">    var args = slice.apply(arguments);</div><div class="line"></div><div class="line">    this.subscribers.forEach(function (subscriber) &#123;</div><div class="line">      if (subscriber.eventType === eventType) &#123;</div><div class="line">        subscriber.cb.apply(undefined, args.slice(1))</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line">  subscribe: function (eventType, cb) &#123;</div><div class="line">    var isSubscribed = false;</div><div class="line">    for (var i = 0; i &lt; this.subscribers.length; i++) &#123;</div><div class="line">      if (this.subscribers.eventType === eventType) &#123;</div><div class="line">        isSubscribed = true;</div><div class="line">        this.subscribers[i].cb = cb;</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if (!isSubscribed) &#123;</div><div class="line">      this.subscribers.push(&#123;</div><div class="line">        eventType: eventType,</div><div class="line">        cb: cb</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 不带参数</div><div class="line">pubSub.subscribe(&apos;event1&apos;, function () &#123; console.log(&apos;订阅者执行&apos;); &#125;);</div><div class="line">pubSub.publish(&apos;event1&apos;);</div><div class="line"></div><div class="line">// 带参数</div><div class="line">pubSub.subscribe(&apos;event2&apos;, function (p1, p2) &#123; console.log(&apos;p1&apos;, p1); &#125;);</div><div class="line">pubSub.publish(&apos;event2&apos;, 2, 3);</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上为自己的对于常用的事件委托，事件代理的理解及发布者订阅进行的理解。</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> 那么Nodejs中的事件机制又是如何的呢？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事件委托，事件代理，pub/sub 是工作常用的工作模式，也许只是你没有注意到而已。&lt;/p&gt;
&lt;h2 id=&quot;事件委托&quot;&gt;&lt;a href=&quot;#事件委托&quot; class=&quot;headerlink&quot; title=&quot;事件委托&quot;&gt;&lt;/a&gt;事件委托&lt;/h2&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="Design Pattern" scheme="http://yoursite.com/tags/Design-Pattern/"/>
    
      <category term="Event Proxy" scheme="http://yoursite.com/tags/Event-Proxy/"/>
    
  </entry>
  
  <entry>
    <title>动画收集</title>
    <link href="http://yoursite.com/2017/11/12/%E5%8A%A8%E7%94%BB%E6%94%B6%E9%9B%86/"/>
    <id>http://yoursite.com/2017/11/12/动画收集/</id>
    <published>2017-11-12T08:51:24.000Z</published>
    <updated>2017-11-12T10:55:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>动画效果对于前端来说，我觉得是比较重要的内容。特别是对于界面的体验等，这个是相当重要的。</p><p>动画主要可以从js或者css来实现，常用的JS动画引擎有<a href="https://github.com/julianshapiro/velocity" target="_blank" rel="external">velocity</a>,CSS 动画库则有<a href="https://github.com/daneden/animate.css" target="_blank" rel="external">animate.css</a>。</p><p>jQuery方法有<code>animate</code>, <code>animate</code>, <code>slideDown</code>等。常用的css3属性有<code>transition</code>, <code>animation</code>, <code>transform</code>等。</p><p>以下就记录一下自己写过以及收集的一些动画效果的写作心得,还请各位看官拍砖：</p><p>要实现的效果是类似移动端购物网站的商品规格详情弹窗，这种效果非常常见。</p><p>这里给出两种写法：</p><h3 id="遮罩层是body的直接子元素"><a href="#遮罩层是body的直接子元素" class="headerlink" title="遮罩层是body的直接子元素"></a>遮罩层是body的直接子元素</h3><p>代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;animation&lt;/title&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">    .pop-modal.modal-in &#123;</div><div class="line">      opacity: 1;</div><div class="line">      -webkit-transition-duration: 400ms;</div><div class="line">      transition-duration: 400ms;</div><div class="line">      -webkit-transform: translate3d(0, 0, 0) scale(1);</div><div class="line">      transform: translate3d(0, 0, 0) scale(1);</div><div class="line">    &#125;</div><div class="line">    .pop-modal.modal-out &#123;</div><div class="line">      opacity: 0;</div><div class="line">      z-index: 10009;</div><div class="line">      -webkit-transition-duration: 400ms;</div><div class="line">      transition-duration: 400ms;</div><div class="line">      -webkit-transform: translate3d(0, 0, 0) scale(0.815);</div><div class="line">      transform: translate3d(0, 0, 0) scale(0.815);</div><div class="line">    &#125;</div><div class="line">    .pop-modal &#123;</div><div class="line">      position: absolute;</div><div class="line">      left: 0;</div><div class="line">      right: 0;</div><div class="line">      height: 800px;</div><div class="line">      /*top: 0;*/</div><div class="line">      bottom: 0;</div><div class="line">      opacity: 0;</div><div class="line">      z-index: 10400;</div><div class="line">      background-color: #fff;</div><div class="line">      -webkit-transition: all 0.2s cubic-bezier(0, 0, 0.25, 1);</div><div class="line">      transition: all 0.2s cubic-bezier(0, 0, 0.25, 1);</div><div class="line">      -webkit-transform: translate3d(0, 100%, 0);</div><div class="line">    &#125;</div><div class="line">    .popup-overlay &#123;</div><div class="line">      z-index: 10000;</div><div class="line">      position: absolute;</div><div class="line">      left: 0;</div><div class="line">      top: 0;</div><div class="line">      width: 100%;</div><div class="line">      height: 100%;</div><div class="line">      background: rgba(0, 0, 0, 0.4);</div><div class="line">      visibility: hidden;</div><div class="line">      opacity: 0;</div><div class="line">      -webkit-transition-duration: 400ms;</div><div class="line">      transition-duration: 400ms;</div><div class="line">    &#125;</div><div class="line">    .popup-overlay_visible &#123;</div><div class="line">      opacity: 1;</div><div class="line">      visibility: visible;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .tm &#123;</div><div class="line">      font-size: 60px;</div><div class="line">    &#125;</div><div class="line">  &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;button id=&quot;tm&quot; class=&quot;tm&quot;&gt;切换modal显示&lt;/button&gt;</div><div class="line">  &lt;buton id=&quot;J_close&quot;&gt;关闭modal&lt;/buton&gt;</div><div class="line">  &lt;div class=&quot;popup-overlay&quot; id=&quot;J_overlay&quot;&gt;&lt;/div&gt;</div><div class="line">  &lt;div id=&quot;pop&quot; class=&quot;pop-modal&quot;&gt;</div><div class="line">    &lt;div class=&quot;pop__content&quot;&gt;</div><div class="line">      这是弹出内容</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;script src=&quot;../jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script src=&quot;../adapter.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">    $(&apos;#J_close&apos;).on(&apos;click&apos;, function () &#123;</div><div class="line">      $(&apos;#pop&apos;).removeClass(&apos;modal-in&apos;).transitionEnd(function () &#123;</div><div class="line">        $(&apos;#J_overlay&apos;).removeClass(&apos;popup-overlay_visible&apos;)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    $(&apos;#J_overlay&apos;).on(&apos;click&apos;, function () &#123;</div><div class="line">      $(&apos;#pop&apos;).removeClass(&apos;modal-in&apos;).transitionEnd(function () &#123;</div><div class="line">        $(&apos;#J_overlay&apos;).removeClass(&apos;popup-overlay_visible&apos;)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    $(&apos;#tm&apos;).on(&apos;click&apos;, function () &#123;</div><div class="line">      $(&apos;#pop&apos;).addClass(&apos;modal-in&apos;)</div><div class="line">      $(&apos;#J_overlay&apos;).addClass(&apos;popup-overlay_visible&apos;)</div><div class="line">    &#125;)</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>这里模仿的是淘宝的<a href="http://m.sui.taobao.org/" target="_blank" rel="external">SUI</a>里面的<em>modal.js</em>插件。大概的意思就是在点击按钮的时候给遮罩层和弹窗内容添加类，元素会应用因为属性的更改而触发元素自身定义的动画。</p><p><strong>这里的adapter.js只是SUI里面的对于zepto.js的方法的补充源码里面有一个zepto-adapter.js里面包含了<code>transitionEnd</code>这个扩展方法</strong>，这个方法的意思是说监听动画完成的事件，当动画完成才去做某些动作比如当动画完成才去进行其它步骤。其实这个有点像是那个jQuery的<code>animate</code>的回调。</p><p>引用<a href="https://developer.mozilla.org/en-US/docs/Web/Events/transitionend" target="_blank" rel="external">MDN</a>上的说法:</p><blockquote><p>The transitionend event is fired when a CSS transition has completed. In the case where a transition is removed before completion, such as if the transition-property is removed or display is set to “none”, then the event will not be generated.</p></blockquote><p>意思是说当一个CSS的渐变效果完成而触发，但是这个渐变的属性被移除或者元素设置为<code>none</code>的时候这个事件不会触发。查看<a href="https://www.quirksmode.org/css/transitions/transitionend.html" target="_blank" rel="external">Quicks上的transimitionend</a><em>这个事件是每个属性触发一次</em>。与此相应的有<code>animitionend</code>事件。</p><h3 id="遮罩层和弹出出层的内容是同一级"><a href="#遮罩层和弹出出层的内容是同一级" class="headerlink" title="遮罩层和弹出出层的内容是同一级"></a>遮罩层和弹出出层的内容是同一级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;animation&lt;/title&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">    .pop-modal.modal-in &#123;</div><div class="line">      opacity: 1;</div><div class="line">      -webkit-transition-duration: 400ms;</div><div class="line">      transition-duration: 400ms;</div><div class="line">      -webkit-transform: translate3d(0, 0, 0) scale(1);</div><div class="line">      transform: translate3d(0, 0, 0) scale(1);</div><div class="line">    &#125;</div><div class="line">    .pop-modal.modal-out &#123;</div><div class="line">      opacity: 0;</div><div class="line">      z-index: 10009;</div><div class="line">      -webkit-transition-duration: 400ms;</div><div class="line">      transition-duration: 400ms;</div><div class="line">      -webkit-transform: translate3d(0, 0, 0) scale(0.815);</div><div class="line">      transform: translate3d(0, 0, 0) scale(0.815);</div><div class="line">    &#125;</div><div class="line">    /*.pop-modal &#123;</div><div class="line">      display: none;</div><div class="line">      position: fixed;</div><div class="line">      top: 0;</div><div class="line">      left: 0;</div><div class="line">      right: 0;</div><div class="line">      bottom: 0;</div><div class="line">      z-index: 9990;</div><div class="line">      background-color: rgba(0, 0, 0, 0.8);</div><div class="line">      webkit-transition: -webkit-transform .3s;</div><div class="line">      transition: -webkit-transform .3s;</div><div class="line">      transition: transform .3s;</div><div class="line">      transition: transform .3s, -webkit-transform .3s;</div><div class="line">    &#125;*/</div><div class="line">    .pop__content.modal-in &#123;</div><div class="line">      transform: translate3d(0px, 0px, 0px);</div><div class="line">    &#125;</div><div class="line">    .pop__content &#123;</div><div class="line">      position: absolute;</div><div class="line">      left: 0;</div><div class="line">      right: 0;</div><div class="line">      bottom: 0;</div><div class="line">      /*height: 700px;*/</div><div class="line">      /* top: 15%; */</div><div class="line">      background-color: #fff;</div><div class="line">      z-index: 5000;</div><div class="line">      /*-webkit-transition: all 0.2s cubic-bezier(0, 0, 0.25, 1);</div><div class="line">      transition: all 0.2s cubic-bezier(0, 0, 0.25, 1);</div><div class="line">      -webkit-transform: translate3d(0, 100%, 0);*/</div><div class="line">      -webkit-transition: -webkit-transform .3s;</div><div class="line">      transition: -webkit-transform .3s;</div><div class="line">      transition: transform .3s;</div><div class="line">      transition: transform .3s, -webkit-transform .3s;</div><div class="line">      -webkit-transform: translate3d(0, 100%, 0);</div><div class="line">    &#125;</div><div class="line">    .popup-overlay &#123;</div><div class="line">      display: none;</div><div class="line">      z-index: 100;</div><div class="line">      position: absolute;</div><div class="line">      left: 0;</div><div class="line">      right: 0;</div><div class="line">      top: 0;</div><div class="line">      bottom: 0;</div><div class="line">      /*visibility: hidden;*/</div><div class="line">      opacity: 0;</div><div class="line">      -webkit-transition-duration: 200ms;</div><div class="line">      transition-duration: 200ms;</div><div class="line">      background: rgba(0, 0, 0, 0.6);</div><div class="line">      /*width: 100%;</div><div class="line">      height: 100%;</div><div class="line">      background: rgba(0, 0, 0, 0.4);</div><div class="line">      visibility: hidden;</div><div class="line">      opacity: 0;</div><div class="line">      -webkit-transition-duration: 400ms;</div><div class="line">      transition-duration: 400ms;*/</div><div class="line">    &#125;</div><div class="line">    .popup-overlay_visible &#123;</div><div class="line">      opacity: 1;</div><div class="line">      visibility: visible;</div><div class="line">    &#125;</div><div class="line">    .tm &#123;</div><div class="line">      font-size: 60px;</div><div class="line">    &#125;</div><div class="line">    .pop-dialog__title &#123;</div><div class="line">      height: 500px;</div><div class="line">    &#125;</div><div class="line">  &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;button id=&quot;tm&quot; class=&quot;tm&quot;&gt;切换modal显示&lt;/button&gt;</div><div class="line">  &lt;buton id=&quot;J_close&quot;&gt;关闭modal&lt;/buton&gt;</div><div class="line">  &lt;div id=&quot;pop&quot; class=&quot;pop-modal&quot;&gt;</div><div class="line">    &lt;div class=&quot;popup-overlay&quot; id=&quot;J_overlay&quot;&gt;</div><div class="line"></div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;div class=&quot;pop__content&quot;&gt;</div><div class="line">      &lt;div class=&quot;pop-dialog__title&quot;&gt;</div><div class="line">        这是弹出内容</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">  &lt;script src=&quot;../jquery.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script src=&quot;../adapter.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">    function getStyle(el, styleProp) &#123;</div><div class="line">        var value, defaultView = (el.ownerDocument || document).defaultView;</div><div class="line">        // W3C standard way:</div><div class="line">        if (defaultView &amp;&amp; defaultView.getComputedStyle) &#123;</div><div class="line">            // sanitize property name to css notation</div><div class="line">            // (hypen separated words eg. font-Size)</div><div class="line">            styleProp = styleProp.replace(/([A-Z])/g, &apos;-$1&apos;).toLowerCase();</div><div class="line">            return defaultView.getComputedStyle(el, null).getPropertyValue(styleProp);</div><div class="line">        &#125; else if (el.currentStyle) &#123; // IE</div><div class="line">            // sanitize property name to camelCase</div><div class="line">            styleProp = styleProp.replace(/\-(\w)/g, (str, letter) =&gt; &#123;</div><div class="line">                return letter.toUpperCase();</div><div class="line">            &#125;);</div><div class="line">            value = el.currentStyle[styleProp];</div><div class="line">            // convert other units to pixels on IE</div><div class="line">            if (/^\d+(em|pt|%|ex)?$/i.test(value)) &#123;</div><div class="line">                return ((value) =&gt; &#123;</div><div class="line">                    var oldLeft = el.style.left, oldRsLeft = el.runtimeStyle.left;</div><div class="line">                    el.runtimeStyle.left = el.currentStyle.left;</div><div class="line">                    el.style.left = value || 0;</div><div class="line">                    value = el.style.pixelLeft + &apos;px&apos;;</div><div class="line">                    el.style.left = oldLeft;</div><div class="line">                    el.runtimeStyle.left = oldRsLeft;</div><div class="line">                    return value;</div><div class="line">                &#125;)(value);</div><div class="line">            &#125;</div><div class="line">            return value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    $(&apos;#J_close&apos;).on(&apos;click&apos;, function () &#123;</div><div class="line">      // addClass(&apos;modal-out&apos;)</div><div class="line">      $(&apos;.pop__content&apos;).removeClass(&apos;modal-in&apos;).transitionEnd(function () &#123;</div><div class="line">        // $(&apos;#pop&apos;).hide()</div><div class="line">        $(this).hide()</div><div class="line">        $(&apos;#J_overlay&apos;).removeClass(&apos;popup-overlay_visible&apos;).hide()</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    $(&apos;#J_overlay&apos;).on(&apos;click&apos;, function () &#123;</div><div class="line">      // addClass(&apos;modal-out&apos;)</div><div class="line">      $(&apos;#J_overlay&apos;).removeClass(&apos;popup-overlay_visible&apos;);</div><div class="line">      $(&apos;.pop__content&apos;).removeClass(&apos;modal-in&apos;).transitionEnd(function () &#123;</div><div class="line">        $(this).hide()</div><div class="line">        $(&apos;#J_overlay&apos;).removeClass(&apos;popup-overlay_visible&apos;).hide()</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    $(&apos;#tm&apos;).on(&apos;click&apos;, function () &#123;</div><div class="line">      $(&apos;.pop__content&apos;).show();</div><div class="line">      // 只有这样才可以触发动画效果</div><div class="line">      getStyle($(&apos;#pop&apos;)[0], &apos;transform&apos;);</div><div class="line">      $(&apos;#J_overlay&apos;).addClass(&apos;popup-overlay_visible&apos;).show();</div><div class="line">      $(&apos;.pop__content&apos;).addClass(&apos;modal-in&apos;);</div><div class="line"></div><div class="line">    &#125;)</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><p>这里的做法是模仿微信<a href="https://weui.io" target="_blank" rel="external">weui</a>里面的<code>actionSheet.js</code>有一个方法<code>$.getStyle($actionSheet[0], &#39;transform&#39;);</code>这里我看的注释是说：</p><blockquote><p>这里获取一下计算后的样式，强制触发渲染. fix IOS10下闪现的问题</p></blockquote><p>可是我怎么这里就是为了要有动画效果的。这里的关键点就在这个函数上面，其它的和上一段代码是差不多的。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实，动画就是对于元素的某个属性的渐变的效果。那么这里其实会涉及到好多东西比如<em>requestAnimationFrame</em>还有多个动画效果的叠加问题，<strong>复杂的动画是需要有一定的数学算法基础的</strong>。</p><p>TodoList:</p><ul><li style="list-style: none"><input type="checkbox"> 购物车的抛物线功能</li><li style="list-style: none"><input type="checkbox"> Vue动画</li><li style="list-style: none"><input type="checkbox"> Animation与Transimition的区别</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动画效果对于前端来说，我觉得是比较重要的内容。特别是对于界面的体验等，这个是相当重要的。&lt;/p&gt;
&lt;p&gt;动画主要可以从js或者css来实现，常用的JS动画引擎有&lt;a href=&quot;https://github.com/julianshapiro/velocity&quot; targe
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="animate" scheme="http://yoursite.com/tags/animate/"/>
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>DOM相关</title>
    <link href="http://yoursite.com/2017/10/28/DOM%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/10/28/DOM相关/</id>
    <published>2017-10-28T04:12:36.000Z</published>
    <updated>2017-12-24T05:22:00.338Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在整理一些JavaScript基础知识，因为这些知识对于框架的构建等是很有好处的，本文大部分是翻译加上自己的理解。</p><h2 id="getComputedStyle-和-getBoundingClientRect"><a href="#getComputedStyle-和-getBoundingClientRect" class="headerlink" title="getComputedStyle 和 getBoundingClientRect"></a>getComputedStyle 和 getBoundingClientRect</h2><p><code>getComputedStyle</code> 是获取元素的样式，这个属性在 IE9+ 支持，IE9 以下用 currentStyle。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getComputedStyle(el)</div></pre></td></tr></table></figure><p><code>getBoundingClientRect</code> 是获取元素在当前视窗的位置，会随着滚动的位置而发生数值上的变化。除了 <code>position: fixed</code> 的元素。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">el.getBoundingClientRect</div></pre></td></tr></table></figure><h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><p>假设有两个元素，元素A和元素B，元素A内嵌元素B。当两个元素同时绑定的相同的事件监听器的时候哪个会先触发？</p><p>事件模型有两种</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>以下图例为事件捕获的示意图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">            |  |</div><div class="line">------------|  |-------------</div><div class="line">| element1                  |</div><div class="line">|  ---------|  |----------   |</div><div class="line">| |element2 \ /         |  |</div><div class="line">|  -----------------------  |  </div><div class="line">|   事件捕获                  |</div><div class="line">|----------------------------</div></pre></td></tr></table></figure><p>元素1的事件句柄先执行，然后才是元素2。</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">           / \   </div><div class="line">-----------| |--------------</div><div class="line">| element1 | |              |</div><div class="line">| ---------| |-----------   |</div><div class="line">| |element2             |   |</div><div class="line">|  ----------------------   |</div><div class="line">|   事件冒泡                 |</div><div class="line">|---------------------------</div></pre></td></tr></table></figure><p>元素2的事件句柄先执行，然后才是元素1。</p><h3 id="W3C事件模型"><a href="#W3C事件模型" class="headerlink" title="W3C事件模型"></a>W3C事件模型</h3><p>W3C事件模型是先捕获到目标元素然后再冒泡。</p><figure class="highlight plain"><figcaption><span>|  / \</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---------------| |--| |-------------</div><div class="line">| element1     | |  | |             |</div><div class="line">|   -----------| |--| |---------    |</div><div class="line">|   | element2 \ /  | |         |   |</div><div class="line">|    ---------------------------    |</div><div class="line">|    W3C 事件模型                     |</div><div class="line">|-----------------------------------</div></pre></td></tr></table></figure><p>那么开发者可以选择在捕获阶段或者冒泡阶段注册事件句柄。<br><code>addEventListener</code>的最后一个参数为<code>true</code>表示是捕获阶段，否则是冒泡。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.addEventListener(&apos;click&apos;,doSomething2,true)</div><div class="line">element2.addEventListener(&apos;click&apos;,doSomething,false)</div></pre></td></tr></table></figure><p>如果用户点击了元素2的事件过程：</p><ul><li>在捕获阶段，查找元素2的祖先元素是否注册了事件句柄。</li><li>发现element1.doSomething2然后执行</li><li>事件来到目标元素2，没有为捕获阶段注册的事件句柄，事件开始冒泡并且执行元素2为冒泡注册的事件句柄<code>doSomething</code></li><li>事件来往上冒泡检查元素2的祖先元素有没有为冒泡阶段注册的事件句柄。</li></ul><p>与之相反：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.addEventListener(&apos;click&apos;,doSomething2,false)</div><div class="line">element2.addEventListener(&apos;click&apos;,doSomething,false)</div></pre></td></tr></table></figure><p>当点击元素2的时候事件过程如下：</p><ul><li><code>click</code>事件开始捕获阶段，检查元素2的祖先元素是否有为捕获阶段注册的事件句柄检查没有。</li><li>来到目标元素2，来到事件的冒泡阶段并且执行<em>doSomething</em>。</li><li>事件冒泡检查元素2的祖先元素有为冒泡阶段注册的事件句柄。</li><li>发现元素1有则执行<em>doSomething2</em>。</li></ul><p>可以看一下示例, <strong>打开控制台观察点击元素事件的输出</strong></p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Wudiemperor/rnr5sa2h/1/embedded/js,html,css,result/light" frameborder="0" allowfullscreen></iframe><h3 id="与传统模型兼容"><a href="#与传统模型兼容" class="headerlink" title="与传统模型兼容"></a>与传统模型兼容</h3><p>在支持W3C DOM浏览器中一个传统的事件注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element1.onclick = doSomething2;</div></pre></td></tr></table></figure><p>会被注册在冒泡阶段。</p><h3 id="事件捕获和冒泡一直都会发生"><a href="#事件捕获和冒泡一直都会发生" class="headerlink" title="事件捕获和冒泡一直都会发生"></a>事件捕获和冒泡一直都会发生</h3><p>事件冒泡和捕获一直都会发生。当你定义<code>document</code>的全局点击事件句柄的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document.onclick = doSomething;</div><div class="line">if (document.captureEvents) document.captureEvents(Event.CLICK);</div></pre></td></tr></table></figure><p>对于文档内的任意元素上的点击事件最终都会冒泡到<code>document</code>上，只有当之前的事件句柄明确不让事件冒泡，就不会传播到<code>document</code>上。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>因为所有的事件都会冒泡到<code>document</code>上，默认的事件句柄是可能的。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">--------------------------------</div><div class="line">| document                      |</div><div class="line">|    ------------   ---------   |</div><div class="line">|    | element1  | | element2|  |</div><div class="line">|    ------------- -----------  |</div><div class="line">|--------------------------------</div><div class="line"></div><div class="line">element1.onclick = doSomething;</div><div class="line">element2.onclick = doSomething;</div><div class="line">element3.onclick = defaultFunction;</div></pre></td></tr></table></figure><p>当用户点击元素1或者2的时候<code>doSomething</code>会执行。你可以在点击元素1或者2的时候阻止冒泡到<code>defaultFunction</code>.如果用户点击这两个元素以外的其它地方则会执行<code>defaultFunction</code>.</p><p>设置这个<em>文档</em>的事件句柄在写拖拽脚本的时候是必须的。<br>一般是<code>mousedown</code>事件在所选择的层上然后响应<code>mousemvoe</code>事件。虽然<code>mousedown</code>为了避免浏览器bugs而注册在拖拽目标上，其它的事件句柄必须是注册在<code>document</code>上。</p><p>有可能会发生用户非常粗野地移动鼠标然后脚本出现问题导致鼠标没有在目标层上。</p><ul><li>如果<code>onmousemove</code>事件句柄是注册在目标层上，目标层元素没有响应鼠标移动，让人困惑。</li><li>如果<code>onmouseup</code>事件句柄注册在目标层上，这个事件不会被捕捉到导致当用户认为他已经松开目标层的时候仍然在响应鼠标的移动事件。这会让人更加困惑。</li></ul><p>**所以在这种情况下<code>mousemove和mouseup</code>得注册在<code>document</code>上以确保这两个事件会一直被触发。</p><h3 id="关掉事件冒泡"><a href="#关掉事件冒泡" class="headerlink" title="关掉事件冒泡"></a>关掉事件冒泡</h3><p>可以关闭所有的事件冒泡。在IE下可以执行<code>window.event.cancelBubble = true</code>.</p><p>在W3C模型下可以执行<code>e.stopPropagation()</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function doSomething(e)</div><div class="line">&#123;</div><div class="line">if (!e) var e = window.event;</div><div class="line">e.cancelBubble = true;</div><div class="line">if (e.stopPropagation) e.stopPropagation();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h3><p>event有一个<code>target</code>或者<code>srcElement</code>(旧版本的IE包含这个属性)是指向触发了事件的元素。不管是在捕获还是冒泡阶段这个都会指向的<strong>触发了事件的元素</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.onclick = doSomething;</div><div class="line">element2.onclick = doSomething;</div></pre></td></tr></table></figure><p>当用户点击了元素2<code>doSomething</code>会执行两次。那么如何知道被点击的是哪个元素呢？<code>currentTarget</code>会指向<strong>注册该事件的元素</strong>。但是微软并没有类似的属性。</p><p>你可以在函数中用<code>this</code>关键字得到触发事件的元素。</p><h3 id="微软模型的问题"><a href="#微软模型的问题" class="headerlink" title="微软模型的问题"></a>微软模型的问题</h3><p>但是当你使用微软的事件注册模型<code>this</code>关键字并不指注册该事件的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element1.onclick = doSomething;</div><div class="line">element2.onclick = doSomething;</div></pre></td></tr></table></figure><p>在IE中无法知道<code>domeSomething</code>事件中的this指向的是哪个元素。微软并没有对应的类似<code>currentTarget</code>的属性。</p><p>在<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget" target="_blank" rel="external">MDN上的currentTarget</a>可以看到在<strong>IE6-8</strong>中是没有这个属性的。</p><h2 id="页面生命周期事件"><a href="#页面生命周期事件" class="headerlink" title="页面生命周期事件"></a>页面生命周期事件</h2><p>具体可查看<a href="https://javascript.info/onload-ondomcontentloaded" target="_blank" rel="external">原文</a>。</p><p>页面生命周期事件有：DOMContentLoaded、load、beforeunload、unload。主要有三个重要的事件：</p><ul><li><strong>DOMContentLoaded</strong> 浏览器完全加载完 HTML 并且 DOM 树已经构建完毕但不包含外部加载的资源比如图片 img 标签和样式表。</li><li><strong>load</strong> 浏览器加载完所有的资源比如图片、样式表</li><li><strong>beforeunload/unload</strong> 当用户离开页面时候</li></ul><p>带有 async 或者 defer 属性的带有 src 属性的 script 标签不会阻塞 DOMContentLoaded 的渲染。<br><code>document.readyState</code> 有三种状态值</p><ul><li><strong>loading</strong> 文档在加载</li><li><strong>interactive</strong> 文档完全读取</li><li><strong>complete</strong> 文档完全读取并且其它资源比如图片完全加载</li></ul><p>打开<a href="http://plnkr.co/edit/nnol4v777qQJ2OnFDjDX?p=preview" target="_blank" rel="external">示例</a>理解这些事件的触发顺序。</p><p>查看 <code>jQuery</code> <a href="https://github.com/jquery/jquery/blob/master/src/core/ready-no-deferred.js" target="_blank" rel="external">源码</a> 可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if ( document.readyState === &quot;complete&quot; ||</div><div class="line">( document.readyState !== &quot;loading&quot; &amp;&amp; !document.documentElement.doScroll ) ) &#123;</div><div class="line"></div><div class="line">// Handle it asynchronously to allow scripts the opportunity to delay ready</div><div class="line">window.setTimeout( jQuery.ready );</div><div class="line"></div><div class="line">&#125; else &#123;</div><div class="line"></div><div class="line">// Use the handy event callback</div><div class="line">document.addEventListener( &quot;DOMContentLoaded&quot;, completed );</div><div class="line"></div><div class="line">// A fallback to window.onload, that will always work</div><div class="line">window.addEventListener( &quot;load&quot;, completed );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到上面用到的 <code>DOMContentLoaded</code> 和 <code>document.readyState</code>。<br>总结如下：</p><ul><li><strong>DOMContentLoaded</strong> 当 DOM HTML 结构加载完毕形成 DOM 树，现在就执行脚本。</li><li><strong>onload</strong> 事件当页面和所有资源都加载完毕。</li><li><strong>beforeunload</strong> 在用户想离开页面时。</li><li><strong>unload</strong> 用户确认离开页面。不能用延时或者提醒用户，少用。</li><li><strong>document.readyState</strong> 文档当前状态，用 <code>readystatechange</code> 事件来取得。<ul><li><strong>loading</strong> 文档加载</li><li><strong>interactive</strong> 文档完全解析，几乎和 <strong>DOMContentLoaded</strong> 一样的时机但在其之前。</li><li><strong>complete</strong> 文档和资源完全加载完毕，几乎和 <strong>window.onload</strong> 同时，但在其之前。</li></ul></li></ul><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>Vue中有一个事件的修饰符<code>.self</code>是为了表示事件只能由当前的元素触发，而不能是其后代元素。</p><p>实现原理大概是要对<code>target</code>和<code>currentTarget</code>进行比对,相等则表示是注册了该事件的元素否则是其后代元素。相关代码就不贴出了。</p><p>那么Vue当中的事件的修饰符<code>.self</code>大概也是这个思路吧？过段时间再看下源码吧-^.^-。</p><p>以上文章是翻译的文章再加上自己的一些理解,原文见<a href="https://www.quirksmode.org/js/events_order.html" target="_blank" rel="external">这里</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在整理一些JavaScript基础知识，因为这些知识对于框架的构建等是很有好处的，本文大部分是翻译加上自己的理解。&lt;/p&gt;
&lt;h2 id=&quot;getComputedStyle-和-getBoundingClientRect&quot;&gt;&lt;a href=&quot;#getComputed
      
    
    </summary>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/FrontEnd/"/>
    
    
      <category term="Dom" scheme="http://yoursite.com/tags/Dom/"/>
    
      <category term="CurrentTarget" scheme="http://yoursite.com/tags/CurrentTarget/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs ES6</title>
    <link href="http://yoursite.com/2017/10/21/Nodejs-ES6/"/>
    <id>http://yoursite.com/2017/10/21/Nodejs-ES6/</id>
    <published>2017-10-21T09:08:48.000Z</published>
    <updated>2017-11-05T04:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在写前端大多数情况下会应用蛮多<code>ES6</code>的语法，当你在写<code>Node</code>的时候，当然也会希望使用<code>ES6</code>的特性了，不然会搞得你有些沮丧，淘宝有一篇专门写了<a href="http://taobaofed.org/blog/2016/01/07/find-back-the-lost-es6-features-in-nodejs/" target="_blank" rel="external">这个</a>。不过有些时间了，不是很赞同那样做。</p><p>根据自己的理解，查了下<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="external">Babel官网的介绍</a>, 可以作如下的配置:</p><p>不同的<code>Node</code>版本兼容的<code>ES6</code>可以查看<a href="http://node.green" target="_blank" rel="external">这里</a>。</p><h2 id="安装babel-preset及babel工具"><a href="#安装babel-preset及babel工具" class="headerlink" title="安装babel-preset及babel工具"></a>安装babel-preset及babel工具</h2><blockquote><p>根据官网的介绍，利用这个你可以指定不同的环境而不用去手动配置<code>plugins</code>, 旧的只支持当年批准的那个议案。</p></blockquote><p>安装自己所需要的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 安装 core 和命令行工具</div><div class="line">npm install --save-dev babel-core babel-cli</div><div class="line"># 安装 babel环境支持</div><div class="line">npm install babel-preset-env --save-dev</div><div class="line"># 安装 nodemon可以在你修改的时候自动重新加载node推荐安装哦</div><div class="line">npm i -g nodemon</div></pre></td></tr></table></figure><h2 id="配置-babelrc"><a href="#配置-babelrc" class="headerlink" title="配置.babelrc"></a>配置.babelrc</h2><p>创建<em>.babelrc</em>,当只写<code>[&quot;env&quot;]</code>的时候表示是兼容最新亦即包括(babel-preset-es2015, babel-preset-es2016, and babel-preset-es2017三个一起)。</p><p>因为这边是针对的<code>Node</code>，这里有一个配置蛮好:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;presets&quot;: [</div><div class="line">    [&quot;env&quot;, &#123;</div><div class="line">      &quot;targets&quot;: &#123;</div><div class="line">        &quot;node&quot;: &quot;current&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;]</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样配置以后，babel会根据你的<code>Node</code>的不同版本，自动添加不同的兼容插件，而不用你手动去加载。</p><h2 id="配置package-json"><a href="#配置package-json" class="headerlink" title="配置package.json"></a>配置package.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;main&quot;: &quot;dist/server.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</div><div class="line">    &quot;dev&quot;: &quot;nodemon --exec babel-node src/server.js&quot;,</div><div class="line">    &quot;build&quot;: &quot;babel src --out-dir dist&quot;,</div><div class="line">    &quot;release&quot;: &quot;npm run build &amp;&amp; NODE_ENV=production nodemon dist/server.js&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>然后最后如果plugins和presets一起也是可以的，就是需要注意这两个配置起来必须最后可以在任意一处可以输出对应的兼容的代码，否则打包出来的代码是不兼容的代码。比如没配置好那个<code>import</code>的支持就尴尬了</strong></p><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="对于Nodejs的原生代码"><a href="#对于Nodejs的原生代码" class="headerlink" title="对于Nodejs的原生代码"></a>对于Nodejs的原生代码</h3><p>根据<a href="https://nodejs.org/en/docs/inspector/" target="_blank" rel="external">nodejs官方调试文档</a>可以得知大概有以下步骤:</p><ul><li><p>nodejs内置了node-inspect当然也可以单独安装<code>npm i -g node-inspect</code>，使用命令<code>node --inspect 代码.js</code>即可。<strong>(这里如果是写成<code>node inspect 代码.js</code>的话是直接进入命令行的调试而不能在Chrome devtools中打开的，切记!)</strong>。</p></li><li><p>在Chrome <strong>55+</strong>的浏览器中打开<code>chrome://inspect</code>即可进行调试，或者你也可以安装<a href="https://chrome.google.com/webstore/detail/nim-node-inspector-manage/gnhhdgbaldcilmgcpfddgdbkhjohddkj" target="_blank" rel="external">NIM</a>。</p></li></ul><p>另外在<em>Visual Studio</em>, <em>JetBrains WebStorm</em>, <em>VS Code</em>都提供了对nodejs的友好调试，只需点击debug即可。</p><p>另外,nodejs使用的是<code>--inspect-brk</code>,<code>--debug-brk</code>已经被遗弃</p><h3 id="调试Node-ES6"><a href="#调试Node-ES6" class="headerlink" title="调试Node ES6"></a>调试Node ES6</h3><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>使用命令行<code>babel-node debug src/server.js</code>即可在命令行调试代码。然后用在命令行中用<code>next</code>执行下一条命令, 这个里面的命令其实和在控制台调试JavaScript是保持一致的,比如当你在浏览器中调试代码里面可以设置断点之类，然后在最面板中有<code>step</code>,<code>next</code>等图标。</p><p>另外当使用<code>babel-node --inspect</code>或者<code>babel-node --inspect-brk</code>的进修然后打开Chrome浏览器中输入chrome://inspect即可进行调试。</p><h3 id="WebStorm编辑器"><a href="#WebStorm编辑器" class="headerlink" title="WebStorm编辑器"></a>WebStorm编辑器</h3><p>在编辑器设置步骤是先打开配置搜索<em>JavaScript</em>在里面配置使其支持<strong>ES6</strong>。</p><p>然后在那个Debug的右边的第一个选项卡配置的<code>Node interpreter</code>设置成为自己本地或者全局安装的那个babel-node.js的路径。这个babel-node是由安装babel-cli包所生成的。可以指定本项目下面的或者是全局的那个都可以。</p><p>最后在<code>Node parameters</code>中设置参数由于node 8.x版本使用<code>--inspect-brk</code>或者<code>--inspect</code>都可以,<code>--debug-brk</code>已经被遗弃或者使用</p><p>最后，大功告成，就可以愉快地在<code>Node</code>下写<code>ES6</code>了。以上如有不对的地方还望指教，谢谢-^.^-。</p><p>TodoList:</p><ul><li style="list-style: none"><input type="checkbox"> 这个调试的时候发现不会热更新，笑哭，应该怎么实现呢？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在写前端大多数情况下会应用蛮多&lt;code&gt;ES6&lt;/code&gt;的语法，当你在写&lt;code&gt;Node&lt;/code&gt;的时候，当然也会希望使用&lt;code&gt;ES6&lt;/code&gt;的特性了，不然会搞得你有些沮丧，淘宝有一篇专门写了&lt;a href=&quot;http://taobaofed.o
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>ES6碎碎念经</title>
    <link href="http://yoursite.com/2017/10/13/ES6%E7%A2%8E%E7%A2%8E%E5%BF%B5%E7%BB%8F/"/>
    <id>http://yoursite.com/2017/10/13/ES6碎碎念经/</id>
    <published>2017-10-13T14:31:46.000Z</published>
    <updated>2017-10-14T07:48:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用<em>ES6</em>好些时间了, 下面是自己的一些使用心得:</p><h2 id="let与const"><a href="#let与const" class="headerlink" title="let与const"></a>let与const</h2><p>隐蔽死区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function bar(x = y, y = 2) &#123;</div><div class="line">  return [x, y]</div><div class="line">&#125;</div><div class="line"></div><div class="line">bar() // 报错</div></pre></td></tr></table></figure><p><code>x</code>默认值等于另一个参数<code>y</code>， <code>y</code>还没声明，属于死区.</p><p>ES6支付宝临时性死区和<code>let</code>, <code>const</code>语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量。</p><p>不能在函数内部重新声明参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func(arg) &#123;</div><div class="line">let args; // 报错</div><div class="line">&#125;</div><div class="line"></div><div class="line">function func(arg) &#123;</div><div class="line">&#123;</div><div class="line">let arg; // 不报错</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function f1() &#123;</div><div class="line">let n = 5;</div><div class="line">if (true) &#123;</div><div class="line">let n = 10;</div><div class="line">&#125;</div><div class="line">console.log(n); // 5</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上代码表示外层代码块不受内层代码块的影响。<br>ES6 允许块级作用域任意嵌套。<br>块级作用域的出现，使得广泛使用的立即执行函数表达式（IIFE）不再必要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">var tmp = ...;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">// 块级作用域</div><div class="line">&#123;</div><div class="line">  let tmp = ...;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>为了兼容老代码函数声明。浏览器实现可以不遵守块级作用域内声明的函数类似于<code>let</code>的规定。</p><ul><li>允许在块级作用域内声明函数</li><li>函数声明类似于<code>var</code>,即会提升到全局作用域或函数作用域的头部</li><li>同时，函数声明还会提升到所在块级作用域的头部</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 浏览器的 ES6 环境</div><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line"></div><div class="line">(function () &#123;</div><div class="line">  if (false) &#123;</div><div class="line">    // 重复声明一次函数f</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div><div class="line">// Uncaught TypeError: f is not a function</div></pre></td></tr></table></figure><p>实际运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 浏览器的 ES6 环境</div><div class="line">function f() &#123; console.log(&apos;I am outside!&apos;); &#125;</div><div class="line">(function () &#123;</div><div class="line">  var f = undefined;</div><div class="line">  if (false) &#123;</div><div class="line">    function f() &#123; console.log(&apos;I am inside!&apos;); &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  f();</div><div class="line">&#125;());</div><div class="line">// Uncaught TypeError: f is not a function</div></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应避免在块级作用域内声明函数。如果确实需要，也应写成函数表达式，而不是函数声明语句。</p><p><code>const</code>只声明不赋值也会报错。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存不得改动。对于简单类型的数据(数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据(对象和数组),变量指向的内存地址，保存的只是一个指针。<code>const</code>仅保证这个指针固定，上面的值却不能够保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line"></div><div class="line">// 赋值</div><div class="line">foo.a = 123;</div><div class="line">foo.a // 123</div><div class="line"></div><div class="line">// 将foo指向另一个对象，报错</div><div class="line">foo = &#123;&#125;; // Uncaught TypeError: Assignment to constant variable</div></pre></td></tr></table></figure><p>想将对象冻结使用<code>Object.freeze</code>方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;&#125;);</div><div class="line"></div><div class="line">// 常规模式时，下面一行不起作用；</div><div class="line">// 严格模式时，该行会报错</div><div class="line">foo.prop = 123;</div></pre></td></tr></table></figure><h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h3><p><code>var</code>命令和<code>function</code>命令声明的全局变量,依旧是顶层对象的属性,另一方面,<code>let</code>,<code>const</code>,<code>class</code>命令声明的全局变量不属于顶层对象的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">// 如果在Node的REPL环境，可以写成global.a</div><div class="line">// 或者采用通用方法，写成this.a</div><div class="line">window.a // 1</div><div class="line"></div><div class="line">let b = 1;</div><div class="line">window.b // undefined</div></pre></td></tr></table></figure><h3 id="global对象"><a href="#global对象" class="headerlink" title="global对象"></a>global对象</h3><p>ES5的顶层对象，在不同环境里面不一样.</p><ul><li>浏览器是<code>window</code>, 但Node和Web Worker没有<code>window</code></li><li>浏览器和Web Worker里面，<code>self</code>也指向顶层对象,但是Node没有<code>self</code></li><li>Node里面，顶层对象是<code>global</code>,但其它环境都不支持</li></ul><p>同一段代码为了能在各种环境中都取到顶层对象，一般使用<code>this</code>变量。</p><ul><li>全局环境中，<code>this</code>会返回顶层对象, 但Node模块和ES6模块，<code>this</code>返回当前模块</li><li>函数里面的<code>this</code>, 如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这是<code>this</code>会返回<code>undefined</code>。</li><li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li></ul><p>两种方法可以：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 方法一</div><div class="line">(typeof window !== &apos;undefined&apos;</div><div class="line">   ? window</div><div class="line">   : (typeof process === &apos;object&apos; &amp;&amp;</div><div class="line">      typeof require === &apos;function&apos; &amp;&amp;</div><div class="line">      typeof global === &apos;object&apos;)</div><div class="line">     ? global</div><div class="line">     : this);</div><div class="line"></div><div class="line">// 方法二</div><div class="line">var getGlobal = function () &#123;</div><div class="line">  if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125;</div><div class="line">  if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125;</div><div class="line">  if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125;</div><div class="line">  throw new Error(&apos;unable to locate global object&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>有一个提案引入<code>global</code>作为顶层对象，这样所有环境下<code>global</code>都存在。<br><a href="https://github.com/ljharb/System.global" target="_blank" rel="external">system.global</a>模拟了这个提案可以在所有环境中拿到<code>global</code>.</p><h2 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h2><h2 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h2><p>Object.assign(target, source1, source2)只会将源对象的枚举的属性拷贝到目标对象上。只拷贝源对象自身属性，不拷贝不可枚举属性。</p><p>Symbol属性也会被Object.assign拷贝。</p><p>尽量使用<code>Object.keys()</code>来循环对象自身的属性。</p><p><code>Object.getPrototypeOf()</code>获取对象的原型对象。<br><code>Object.setPrototypeOf()</code>设置对象的原型对象。</p><p>…用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let z = &#123; a: 3, b: 4 &#125;;</div><div class="line">let n = &#123; ...z &#125;;</div><div class="line">n // &#123; a: 3, b: 4 &#125;</div></pre></td></tr></table></figure><h2 id="关于函数"><a href="#关于函数" class="headerlink" title="关于函数"></a>关于函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">function add() &#123;&#125;</div></pre></td></tr></table></figure><p>以上函数的长度是多少，一般情况下<code>add.length</code>为函数的参数个数但是如果函数的参数是<code>rest</code>呢？<br><code>rest</code>参数是不计入函数的<code>length</code>属性里面的。并且<strong>rest</strong>参数之后不能再有其它参数，但之前可以有其它参数。<br>你可以在<a href="https://babeljs.io/repl/" target="_blank" rel="external">Babel转换器官网</a>上进行编码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function(a) &#123;&#125;).length  // 1</div><div class="line">(function(...a) &#123;&#125;).length  // 0</div><div class="line">(function(a, ...b) &#123;&#125;).length  // 1</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用&lt;em&gt;ES6&lt;/em&gt;好些时间了, 下面是自己的一些使用心得:&lt;/p&gt;
&lt;h2 id=&quot;let与const&quot;&gt;&lt;a href=&quot;#let与const&quot; class=&quot;headerlink&quot; title=&quot;let与const&quot;&gt;&lt;/a&gt;let与const&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>生活的意义</title>
    <link href="http://yoursite.com/2017/10/12/%E7%94%9F%E6%B4%BB%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://yoursite.com/2017/10/12/生活的意义/</id>
    <published>2017-10-12T15:33:13.000Z</published>
    <updated>2017-10-13T04:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来思绪繁多，有时夜不能寐，想起许多事情，自己的家族，爷爷，爷爷的工厂。</p><p>今天，大了我好多岁的大堂哥微信来和我聊天，平日里，作为生意人的他，蛮忙碌的，也是不易。然后，聊了我最近家里的事，我想他和我一样，关于爷爷冤死，还有家族的厂子。大抵家族遭遇了不幸，我很庆幸，我和他想的一样，我们都不愿意就这样苟且过活，至少我们心底里都非常想要<strong>光宗耀祖</strong>。而他基本上是已经实现了，当了小学的董事会的主席，还有什么一大堆的名头。犹记得他说过的话</p><blockquote><p>历尽沧桑欲何求，只为一生不低头</p></blockquote><p>作为家中长子的他始终记得耻辱，虽然当初生活压力很大，但仍旧是凭借自己的三寸不烂之舌，去争取，去做生意。哪怕遇到再大的困难都挺了过去。所以，每次我看见他的时候，我很难看到他的焦虑，从来都是从容不迫的西样子。</p><p>年轻的时候，我仅仅模糊地记得，父亲要替他出头，他可能和人发生了纠纷。</p><p>时间，会证明一切，也只有努力的人才应该得到回报。然后一直到现在，他都是我的榜样。</p><p>微信里面他说他理解我的问题，作为家中长子的责任感，我表示赞同，也非常感激他的建议。</p><p>有时候，会从半夜惊醒，因为家，因为责任。生活的意义是什么？家中尚有父母，当赡养之，若有妻儿当供养之，尽自己的责任。</p><p>大概你会问：<em>你的生活意义是什么？就是一直为别人活着吗？</em>, 告诉我:当你尽自己的责任之后是什么感觉？就像当你做了一件好事之后，你心里的感受是什么？作为社会个体的自我，就像蝙蝠侠里面的台词说的：力量越大，责任越大。难道不是这样的吗？</p><p>生活不止玩乐，现世下，太多的信息，太多的思想洪流，成天看微博，微信信息，但愿，自己不要为这些所淹没，求得内心一片清净地。<strong>努力实现自己的价值，尽到自己的职责，游山玩水，大概这就是我所认为的生活的意义吧。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近来思绪繁多，有时夜不能寐，想起许多事情，自己的家族，爷爷，爷爷的工厂。&lt;/p&gt;
&lt;p&gt;今天，大了我好多岁的大堂哥微信来和我聊天，平日里，作为生意人的他，蛮忙碌的，也是不易。然后，聊了我最近家里的事，我想他和我一样，关于爷爷冤死，还有家族的厂子。大抵家族遭遇了不幸，我很庆幸
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Essays" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/Essays/"/>
    
    
      <category term="生活" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="人生感悟" scheme="http://yoursite.com/tags/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>window.pageYOffset, window.pageXOffset, clientWidth, clientHeight, etc,一些JavaScript的基础属性及实战应用</title>
    <link href="http://yoursite.com/2017/10/08/window-pageYOffset-window-pageXOffset-clientWidth-clientHeight-etc-%E4%B8%80%E4%BA%9BJavaScript%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/10/08/window-pageYOffset-window-pageXOffset-clientWidth-clientHeight-etc-一些JavaScript的基础属性/</id>
    <published>2017-10-08T13:47:09.000Z</published>
    <updated>2017-11-04T15:39:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>当你在编写某些插件的时候，你对于JavaScript的基础知识的掌握情况将会极大地影响到你写的东西。下面介绍这些基础属性及实战如下：</p><h2 id="window-pageYOffset-window-pageXOffset"><a href="#window-pageYOffset-window-pageXOffset" class="headerlink" title="window.pageYOffset, window.pageXOffset"></a>window.pageYOffset, window.pageXOffset</h2><p>  获得文档在垂直方向或者水平方向的滚动距离。现如今<em>Vue</em>,<em>React</em>大行其道的今天好多兼容性都没在考虑的范围，不过这里还是要提下。这两个属性在IE&lt;9的浏览器是不支持的。所以完整的兼容代码是：</p><pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let supportPageOffset = window.pageXOffset !== undefined</div><div class="line">let isCSS1Compat = ((document.compatMode || &quot;&quot;) === &quot;CSS1Compat&quot;)</div><div class="line"></div><div class="line">let x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;</div><div class="line">let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;</div></pre></td></tr></table></figure>然后在高版本的浏览器中可以用window.scrollX和window.scrollY来分别代替window.pageXOffset和window.pageYOffset。但是**IE浏览器不支持**。</code></pre><p>  <code>document.compatMode</code>表示用户是否在怪异模式吧或者标准模式下。怪异模式下则显示<code>BackCompat</code>,非怪异模式则返回<code>CSS1Compat</code>。<br>  之前在IE的时候调试兼容性的时候面板里面就会有怪异模式,当用户没有设定那个<code>&lt;!DOCTYPE html&gt;</code>头的时候就会<br>  在怪异模式下,返回值是<code>BackCompat</code>。</p><p>  摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/window/scrollY" target="_blank" rel="external">Mozilla中关于window.pageYOffset的表述</a></p><h2 id="clientWidth-clientHeight"><a href="#clientWidth-clientHeight" class="headerlink" title="clientWidth, clientHeight"></a>clientWidth, clientHeight</h2><p> <img src="/images/dimensions-client.png" alt=""><br> 获取元素的内宽度包括内边距(padding)离但不包括垂直滚动条,边框或者外边距(margin)。<strong>这里的元素必须是非内联的元素</strong>，除非设置内联元素默认显示属性即可设置其样式<code>display: inline-block</code>或者其它。<code>clientHeight</code>和<code>clientWidth</code>类似。</p><h2 id="window-innerWidth-window-innerHeight，window-outerWidth-window-outerHeight"><a href="#window-innerWidth-window-innerHeight，window-outerWidth-window-outerHeight" class="headerlink" title="window.innerWidth,window.innerHeight，window.outerWidth, window.outerHeight"></a>window.innerWidth,window.innerHeight，window.outerWidth, window.outerHeight</h2><p><img src="/images/innerheightvsouterheight.png" alt=""></p><p><code>window.innerWidth</code>指的是窗口视窗的宽度包括垂直滚动条的宽度。<code>window.innerHeight</code>窗口视窗的高度包括水平滚动条的高度。<code>window.outerHeight</code>指的是包括整个浏览器的容器的高度。<code>window.outerHeight</code>类似。</p><p><strong>以上这几个属性在IE9以下都不支持</strong>。</p><h2 id="offsetWidth-offsetHeight-offsetLeft-offsetTop-offsetParent"><a href="#offsetWidth-offsetHeight-offsetLeft-offsetTop-offsetParent" class="headerlink" title="offsetWidth, offsetHeight, offsetLeft, offsetTop, offsetParent"></a>offsetWidth, offsetHeight, offsetLeft, offsetTop, offsetParent</h2><p><img src="/images/dimensions-offset.png" alt=""></p><p><code>offsetWidth</code>元素的宽度包括元素的边框，元素水平内边距和垂直滚动条的宽度。<code>offsetHeight</code>与之类似，<br>这里获得的数值是四舍五入到整数，如果想要获取精益的数值可以用<code>element.getBoundingClientRect()</code>来获取。</p><p><code>offsetLeft</code>是获取元素相对于最近的定位的元素的左边距离,<code>offsetTop</code>类似。</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Wudiemperor/zpmb5c8b/1/embedded/js,html,css,result/light" frameborder="0" allowfullscreen></iframe><p>但是这里有个问题当是内联元素的时候这个显示会有些奇怪，因为那个内联元素是用的<code>Element.getClientRects</code>来获得宽度和高度从而导致这些内联元素不是个规则的有边框的盒模型。上面的示例就可以看到。</p><p><code>offsetParent</code>是获取元素最近定位的父元素。</p><p><strong>这里需要注意的是<code>getBoundingClientRect</code>获取top与<code>offsetTop</code>的区别</strong></p><p>看下示例就明白了:</p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/Wudiemperor/bzewb0za/embedded/js,html,css,result/light" frameborder="0" allowfullscreen></iframe><p>这里的<code>getBoundingClientRect</code>是以视图上的位置为基准的即相对于<strong>viewport</strong>的上，右，下，左的距离，而<code>offsetTop</code>是以最近的<strong>定位的元素</strong>，这里的定位元素,如果目标元素是<code>fixed</code>或者目标元素的最近的父元素是<code>static</code>定位的话的话两者是相等的,否则一般是不相等(排队了元素未在视图顶部的情况)。一个是相对于视图，一个是相对于最近的有定位的父元素。</p><h2 id="clientLeft-clientTop-window-screenX-window-screenY"><a href="#clientLeft-clientTop-window-screenX-window-screenY" class="headerlink" title="clientLeft, clientTop, window.screenX, window.screenY"></a>clientLeft, clientTop, window.screenX, window.screenY</h2><p><code>clientLeft</code>一个元素左边边框的宽度包含垂直滚动条的宽度但并不包含左外边距和左内边距。<code>clientTop</code>类似。</p><p><code>window.screenX</code> 用户的浏览器左边框和用户的屏幕左边之间的距离</p><p><code>window.screenY</code> 用户的浏览器上边框和用户的屏幕顶端之间的距离</p><h2 id="scrollTop-scrollLeft-scrollWidth-scrollHeight"><a href="#scrollTop-scrollLeft-scrollWidth-scrollHeight" class="headerlink" title="scrollTop, scrollLeft, scrollWidth, scrollHeight"></a>scrollTop, scrollLeft, scrollWidth, scrollHeight</h2><p><img src="/images/scrollTop.png" alt=""></p><p><code>scrollTop</code>获取或者设置一个元素垂直方向滚动的距离，表示的意思是元素方框的顶部和元素的最顶部的可见内容之间的距离。当一个元素内容没有产生垂直滚动条，那么这个值为0。</p><p>需要注意的有以下三点：</p><ul><li>当一个元素不可以滚动值为0</li><li>不接受负值相反会会设置回0</li><li>如果设置的最大滚动距离大于元素最大可滚动距离则只会应用元素最大可滚动距离</li></ul><p><code>scrollLeft</code>类似。</p><h2 id="event-clientX-event-clientY"><a href="#event-clientX-event-clientY" class="headerlink" title="event.clientX, event.clientY"></a>event.clientX, event.clientY</h2><p><code>event.clientX</code>触摸事件中的触摸点相对于视图的左位移不包括滚动的位移。<code>event.clientY</code>类似。<br>这两个可以应用在下拉刷新的插件(当是touch事件的时候), 拖拽的插件(当是鼠标事件的时候）。</p><p>大部分的属性都可以在<a href="https://www.quirksmode.org/mobile/tableViewport_desktop.html" target="_blank" rel="external">这里</a>找到。</p><p>接下来假设要写一个那种类似<a href="https://getbootstrap.com/docs/3.3/javascript/#scrollspy" target="_blank" rel="external">scrollspy</a>的插件需要用到的属性有：</p><p>那么这里需要应用到元素的一个属性<code>getBoundingClientRect</code>可以查看<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">这里</a>的详细介绍,大意是这个是返回元素在视图，相对于视图左上角的位移。事实上不管滚动的容器是否是<code>body</code>最终都可以归纳到这个属性上面。<br>大概意思即：当前一个元素完全离开<code>viewport</code>视口的时候，会给激活下一个导航。滚动的距离要大于元素在当前滚动容器的位移。不知道有没有表述清楚呃!-.-。</p><p>这里有一个小snippet用来获取元素的滚动的距离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function getScrollDis () &#123;</div><div class="line">  let supportPageOffset = window.pageXOffset !== undefined</div><div class="line">  let isCSS1Compat = ((document.compatMode || &quot;&quot;) === &quot;CSS1Compat&quot;)</div><div class="line"></div><div class="line">  let x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft;</div><div class="line">  let y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;</div><div class="line"></div><div class="line">  return &#123;</div><div class="line">    top: y,</div><div class="line">    left: x</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="当滚动的容器是body的时候"><a href="#当滚动的容器是body的时候" class="headerlink" title="当滚动的容器是body的时候"></a>当滚动的容器是<strong>body</strong>的时候</h3><p>当滚动的容器是<code>body</code>的时候直接获取滚动的距离，和元素本页面的位移和滚动的距离作对比。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let rect = elem.getBoundingClientRect()</div><div class="line">let scrollTop = getScrollDis().top</div><div class="line">let offset = &#123;&#125;</div><div class="line">offset.top = rect.top + win.pageYOffset - docElem.clientTop</div></pre></td></tr></table></figure><h3 id="当滚动的容器不是body的时候"><a href="#当滚动的容器不是body的时候" class="headerlink" title="当滚动的容器不是body的时候"></a>当滚动的容器<strong>不是body</strong>的时候</h3><p>与上面的是类似的只是这里需要计算的是元素相对的滚动容器不一样，可以参考下jQuery的<code>elem.postion()</code>来取得元素的位置。</p><h2 id="总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和Bootstrap类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。"><a href="#总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和Bootstrap类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。" class="headerlink" title="总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和Bootstrap类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。"></a>总结这里的进行判断有两种方法，可以实时进行计算滚动距离进行比较也可以采取和<strong>Bootstrap</strong>类似的方法初始化就位移区间的计算。只是这里在某些情况下你需要手动去重新计算一下位移区间。</h2><p><strong>以上的图片均来自于<a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/</a></strong></p><p>TodoList:</p><ul><li style="list-style: none"><input type="checkbox"> <code>getBoundingClientRect</code>与<code>getClientRects</code>的区别</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当你在编写某些插件的时候，你对于JavaScript的基础知识的掌握情况将会极大地影响到你写的东西。下面介绍这些基础属性及实战如下：&lt;/p&gt;
&lt;h2 id=&quot;window-pageYOffset-window-pageXOffset&quot;&gt;&lt;a href=&quot;#window-pa
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="scrollSpy" scheme="http://yoursite.com/tags/scrollSpy/"/>
    
      <category term="pageYOffset" scheme="http://yoursite.com/tags/pageYOffset/"/>
    
  </entry>
  
  <entry>
    <title>去远方</title>
    <link href="http://yoursite.com/2017/10/02/%E5%8E%BB%E8%BF%9C%E6%96%B9/"/>
    <id>http://yoursite.com/2017/10/02/去远方/</id>
    <published>2017-10-01T16:41:37.000Z</published>
    <updated>2017-10-01T16:41:37.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nodejs插件express-session详解</title>
    <link href="http://yoursite.com/2017/09/13/Nodejs%E6%8F%92%E4%BB%B6express-session%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/09/13/Nodejs插件express-session详解/</id>
    <published>2017-09-13T14:54:40.000Z</published>
    <updated>2017-09-17T08:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用<code>express-session</code>是在nodejs服务器中常用的会话插件。下面简单介绍其基本用法，及一些参数的说明.</p><p>简单介绍一下会话服务，如何识别来访用户是一件重要的事情。那么具体的实现方法有以下三种:</p><ul><li>cookie,把sessionid存储在一个叫set-cookie的响应头中，由服务端传给客户端。</li><li>url重写技术,url上面有类似sessid之类的名称比如网易邮箱就可以在url上面看到类似的字样</li><li>表单隐藏域技术 服务器在表单中写入那个sessionid</li></ul><p>这是只介绍第一种即会话cookie,会话跟踪的实现依赖于<code>cookie</code>。</p><ul><li><p><em>saveUninitialized</em> 默认值为<code>true</code>。</p><blockquote><p>官方文档上说所谓的未初始化会话即会话对象不曾被修改过即为<code>uninitialized session</code>.</p></blockquote><p>怎么理解呢？我查了相关的资料查到<a href="https://stackoverflow.com/questions/40381401/when-use-saveuninitialized-and-resave-in-express-session" target="_blank" rel="external">stackoverflow上关于这个参数</a>的解释，再看官方文档进行了相关的试验。</p><h3 id="总结如下"><a href="#总结如下" class="headerlink" title="总结如下:"></a>总结如下:</h3><p>如果设置saveUninitialized为false那么在请求期间这个session对象没有修改过，即没有进行诸如<code>req.session.变量 = 3</code>这样的赋值则不会保存到session所在的存储的媒介中如：内存，数据库。这样就可以节约大量的资源。</p><p>但是如果你想要识别用户就得启用它。如果为false的话，会话cookie即<code>set-cookie</code>不会被发送到浏览器中除非session对象有修改。<strong>所以一般为true</strong>.</p><p>假设是不以cookie为凭据则可以为false。那么这里如果不以<code>cookie</code>来验证用户的话比如采取<code>token based</code>来进行验证就可以考虑设置<code>saveUninitialized: false</code>。</p><p>这里还需要注意的是<strong>只要<code>session</code>这个对象没有被修改过且<code>saveUninitialized</code>为false则不会返回<code>set-cookie</code>的响应头于是浏览器中</strong>。</p></li></ul><ul><li><p><em>resave</em> 默认值是为<code>true</code>。</p><blockquote><p>官方文档说明强迫会话存储回会话存储容器中，即使在请求过程中会话对象没有被修改过。主要是要查看自己的存储容器是否实现了<code>touch</code>方法。如果有则可以设置<code>resave: false</code>。但是，如果存储容器没有实现并且设置了会话过期时间就必须设置<code>resave: true</code>。</p></blockquote></li><li><p><em>rolling</em> 默认值是<code>false</code>。强制会话过期时间在每个请求进行重置，过期时间会重置到最初的过期时间<strong>maxAge</strong>。当这个选项为<code>true</code>而<code>saveUninitialized: false</code>则会话cookie不会返回到浏览器中。其实这和前面介绍的说的是一个意思<code>saveUninitialized</code>是一个意思。<br><strong>不过这里令人费解的是我测试了不管怎么设置这个过期时间都会重置,大写的尴尬。!-.-.</strong>我一直以为这个如果设置<code>rolling:false</code>的话会这个打印出来的<code>req.session.cookie.maxAge</code>在刷新页面的时候不会重置那个时间即重置回初始化设定的过期时间比如<em>60s</em>,结果是这个值当你刷新页面的时候是会重置的,后面看了源码感觉是自己理解有误了。我设置了一个诸如<code>req.session.isLogged</code>的值然后再去测试当<code>rolling</code>的值为<code>true</code>或<code>false</code>的时候的值，符合预期，结果证实自己的理解有误!!-.-。</p></li><li><p><em>cookie.httpOnly</em> 是否允许客户端访问<code>cookie</code>,默认值为<code>true</code>。</p></li><li><p><em>store持久化session存储的容器</em> 这里默认是<code>MemoryStore</code>实例，如果是想要持久化存储<code>session</code>即在服务器宕机后再识别出该用户的话你需要引入一个存储容器比如<a href="https://www.npmjs.com/package/connect-redis" target="_blank" rel="external">connect-redis</a>或者<a href="https://github.com/mongodb-js/connect-mongodb-session" target="_blank" rel="external">connect-mongodb-session</a>。</p></li><li><p>cookie.secure 如果设置为<code>true</code>全站必须是<strong>https</strong>,如果<code>nodejs</code>是用<code>nginx</code>代理的，则在<code>express</code>中必须设置<code>trust proxy</code>如<code>app.set(&#39;trust proxy&#39;, 1)</code>。</p></li></ul><p>一般情况如下就够用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app.use(session(&#123;</div><div class="line">  name: &apos;sessid&apos;, // session标识符的名字</div><div class="line">  secret: &apos;abcde&apos;, // sessionID的签名密钥</div><div class="line">  resave: true,</div><div class="line">  saveUninitialized: true,</div><div class="line">  rolling: true,</div><div class="line">  cookie: &#123;</div><div class="line">    maxAge: 60000</div><div class="line">  &#125;,</div><div class="line">  store: new RedisStore(&#123;</div><div class="line">    host: &apos;127.0.0.1&apos;,</div><div class="line">    port: redis端口,</div><div class="line">    pass: &apos;redis密码&apos;</div><div class="line">  &#125;)</div><div class="line">&#125;))</div></pre></td></tr></table></figure><p>可根据具体情况再做灵活调整。</p><p>TodoList:</p><ul><li style="list-style: none"><input type="checkbox"> <code>resave</code>参数中如何知道自己的存储容器是否实现了<code>touch</code>方法呢？</li><li style="list-style: none"><input type="checkbox"> <code>rolling</code>为什么默认值要设置为<code>false</code>, <code>true</code>不会好点吗？</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用&lt;code&gt;express-session&lt;/code&gt;是在nodejs服务器中常用的会话插件。下面简单介绍其基本用法，及一些参数的说明.&lt;/p&gt;
&lt;p&gt;简单介绍一下会话服务，如何识别来访用户是一件重要的事情。那么具体的实现方法有以下三种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="backend" scheme="http://yoursite.com/categories/backend/"/>
    
    
      <category term="nodejs" scheme="http://yoursite.com/tags/nodejs/"/>
    
      <category term="express" scheme="http://yoursite.com/tags/express/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap affix 源码解读</title>
    <link href="http://yoursite.com/2017/08/20/Bootstrap-affix-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/20/Bootstrap-affix-源码解读/</id>
    <published>2017-08-20T09:48:07.000Z</published>
    <updated>2017-08-27T04:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>许多情况下我们都需要去处理那种导航在页面滑动了一定的距离然后固定导航的需求，然后有可能会要求在滚动到距询问多少距离的时候又不固定导航。Bootstrap affix就是为此设计的。</p><p>功能需求：</p><ul><li>当页面滚动到一定距离即固定住元素</li><li>当页面滚动到距离底部一定距离的时候不再固定元素而是绝对定位元素</li></ul><p>思路分三个阶段：</p><ul><li>当用户没有滚动到阀值的时候是一个类affix-top</li><li>当用户滚动到阀值的时候类改为affix，然后样式化这个类比如写position:fixed</li><li>当用户到达底部阀值的时候元素类改为affix-bottom,然后样式化这个类比如position:absolute</li></ul><p><strong> 当发现固定部分在滚动有抖动现象需要给<code>body</code>设置</strong>position:relative**。</p><blockquote><p>名词解释:</p><p>视窗高度：所看到的高度不包括可滚动的距离<br>内容高度：所看到的高度加上可滚动的距离</p></blockquote><p>首先知道CSS定位<code>position</code>属性:</p><blockquote><h2 id="引用自MDN-css-position"><a href="#引用自MDN-css-position" class="headerlink" title="引用自MDN css position"></a>引用自<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="external">MDN css position</a></h2><p>所谓的<code>positioned element</code>即定位为<strong>relative</strong>,<strong>absolute</strong>,<strong>fixed</strong>或者<strong>sticky</strong>。</p><ul><li>fixed: 元素相对于<strong>视窗</strong>的定位。不随滚动条滚动。</li><li>absolue: 元素相对于<strong>最近有定位父级元素</strong>的定位，如果元素有外边距则会增加进<code>offset</code>位移属性里面,会随滚动条滚动。</li><li>relative: 相对于元素本身本来的位置的定位。</li></ul></blockquote><p>然后需要知道的是关于<code>jQuery</code>的<code>offset</code>函数，<code>$(elem).offset()</code>获得元素在文档中的位移值默认输出<code>{top: top值, left: left值}</code>。<br>元素的position属性所导致的值的不同:</p><ul><li>当元素为<code>relative</code>或者不设置的时候, 当页面滚动的时候, <code>$(elem).offset()</code>值保持不变。</li><li>当元素为<code>absolute</code>的时候, 当页面滚动的时候, <code>$(elem).offset()</code>值保持不变,因为他是随着最近的有定位的父级元素滚动的。</li><li>当元素为<code>fixed</code>的时候，当页面滚动的时候, <code>$(elem).offset()</code>值为元素的<code>top</code>值加上滚动容器滚动的距离。</li></ul><p>Bootstrap affix源码解读如下:</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var Affix = function (element, options) &#123;</div><div class="line">  this.options = $.extend(&#123;&#125;, Affix.DEFAULTS, options)</div><div class="line"></div><div class="line">  this.$target = $(this.options.target)</div><div class="line">    .on(&apos;scroll.bs.affix.data-api&apos;, $.proxy(this.checkPosition, this))</div><div class="line">    .on(&apos;click.bs.affix.data-api&apos;$.proxy(this.checkPositionWithEventLoop,this))</div><div class="line"></div><div class="line">  this.$element     = $(element)</div><div class="line">  this.affixed      = null</div><div class="line">  this.unpin        = null</div><div class="line">  this.pinnedOffset = null</div><div class="line"></div><div class="line">  this.checkPosition()</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先是获得滚动容器<code>this.$target</code>,还有作用的元素<code>this.$element</code>,<code>this.affixed</code>为目标元素的定位的状态值为<strong>top, bottom, false, null</strong>,<code>this.unpin</code>指的是当滚动到底部阀值的时候的位移值为<strong>null或者元素的位移值减去滚动容器（默认为window）滚动的距离</strong>。<code>this.pinnedOffset</code>同<code>this.unpin</code>。<br>事件代理目标滚动容器（<em>默认为window</em>）的滚动事件和点击事件。</p><h3 id="检查元素状态"><a href="#检查元素状态" class="headerlink" title="检查元素状态"></a>检查元素状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) &#123;</div><div class="line">  var scrollTop    = this.$target.scrollTop()</div><div class="line">  var position     = this.$element.offset()</div><div class="line">  var targetHeight = this.$target.height()</div><div class="line"></div><div class="line">  if (offsetTop != null &amp;&amp; this.affixed == &apos;top&apos;) return scrollTop &lt; offsetTop ? &apos;top&apos; : false</div><div class="line"></div><div class="line">  if (this.affixed == &apos;bottom&apos;) &#123;</div><div class="line">    if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : &apos;bottom&apos;</div><div class="line">    return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : &apos;bottom&apos;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var initializing   = this.affixed == null</div><div class="line">  var colliderTop    = initializing ? scrollTop : position.top</div><div class="line">  var colliderHeight = initializing ? targetHeight : height</div><div class="line"></div><div class="line">  if (offsetTop != null &amp;&amp; scrollTop &lt;= offsetTop) return &apos;top&apos;</div><div class="line">  if (offsetBottom != null &amp;&amp; (colliderTop + colliderHeight &gt;= scrollHeight - offsetBottom)) return &apos;bottom&apos;</div><div class="line"></div><div class="line">  return false</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当<code>offsetTop&#39;有值并且固定的状态为</code>top<code>则判断</code>scrollTop &lt; offsetTop<code>滚动距离是否小于顶部阀值，是则返回</code>top<code>否则返回</code>false`。</p><p>如果固定状态为<code>bottom</code>并且<code>offsetTop</code>有值则判断<code>scrollTop</code>滚动的距离加上相对位移值<code>this.unpin</code>和元素的绝对位移值<code>position.top</code>,若小于或等于则返回<code>false</code>否则返回<code>bottom</code>。</p><p>若<code>offsetTop</code>为空则计算滚动距离加上滚动窗口的视窗高度和容器的总高度<code>scrollHeight</code>(即包括可滚动距离和视窗的高度)的值减去<code>offsetBottom</code>底部阀值作对比若小则返回<code>false</code>否则返回<code>bottom</code>。</p><p>接下来判断是否是初始化，设置<code>colliderTop</code>和<code>colliderHeight</code>,当是第一次渲染的时候，分别为滚动的距离和目标滚动容器的视窗高度,否则分别为目标元素的绝对位移和目标元素的高度值。</p><p>如果传进来的顶部绝对位移值不为空并且滚动距离小于传进来的顶部阀值则返回<code>top</code>。</p><p>如果传进来的底部阀值不为空并且<code>colliderTop</code>和<code>colliderHeight</code>的和大于或等于目标容器的总高度减去传进来的底部阀值则返回<code>bottom</code>。<br>即当元素一直滚动到大于滚动的阀值的时候返回<code>bottom</code>, 默认返回<code>false</code>即处于<code>affix</code>状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (this.affixed == &apos;bottom&apos;) &#123;</div><div class="line">  if (offsetTop != null) return (scrollTop + this.unpin &lt;= position.top) ? false : &apos;bottom&apos;</div><div class="line">  return (scrollTop + targetHeight &lt;= scrollHeight - offsetBottom) ? false : &apos;bottom&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>当为<code>affix-bottom</code>状态</em>这个是难点</p><p>当为bottom的时候posiiton.top为scrollHeight - height - offsetBottom,this.unpin是<code>position.top - scrollTop</code>，当<code>offsetTop</code>不为空则判断是向下滚动还是向上滚动若向上滚动则有可能会进入<code>affix</code>状态，若向下滚动则是<code>affix-bottom</code>状态。</p><p>当<code>offsetTop</code>设置为空的时候，比较目标窗口滚动的距离+目标窗口的视窗高度和目标容器的内容高度(包括滚动距离)减去底部阀值若小于则是在<code>affix</code>状态否则进入底部状态并设置类<code>affix-bottom</code>。</p><h3 id="获得锁定状态的位移值"><a href="#获得锁定状态的位移值" class="headerlink" title="获得锁定状态的位移值"></a>获得锁定状态的位移值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.getPinnedOffset = function () &#123;</div><div class="line">  if (this.pinnedOffset) return this.pinnedOffset</div><div class="line">  this.$element.removeClass(Affix.RESET).addClass(&apos;affix&apos;)</div><div class="line">  var scrollTop = this.$target.scrollTop()</div><div class="line">  var position  = this.$element.offset()</div><div class="line">  return (this.pinnedOffset = position.top - scrollTop)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>获取锁定状态的值，当即将进入<code>offsetBottom</code>阀值的时候触发。这个会获取在<code>affix</code>状态进入<code>affix-bottom</code>的时候的定值，即元素仍然为<code>affix</code>状态的时候的阀值。若目标元素在<code>affix</code>状态定位为<code>fixed</code>则此值为CSS类<code>affix-fixed</code>设定的<code>fixed</code>状态的<code>top</code>值。</p><h3 id="检测位置"><a href="#检测位置" class="headerlink" title="检测位置"></a>检测位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.checkPosition = function() &#123;</div><div class="line">  if (!this.$element.is(&apos;:visible&apos;)) return</div><div class="line"></div><div class="line">  var height = this.$element.height()</div><div class="line">  var offset = this.options.offset</div><div class="line">  var offsetTop = offset.top</div><div class="line">  var offsetBottom = offset.bottom</div><div class="line">  var scrollHeight = Math.max($(document).height(), $(document.body).height())</div><div class="line"></div><div class="line">  if (typeof offset != &apos;object&apos;) offsetBottom = offsetTop = offset</div><div class="line">  if (typeof offsetTop == &apos;function&apos;) offsetTop = offset.top(this.$element)</div><div class="line">  if (typeof offsetBottom == &apos;function&apos;) offsetBottom = offset.bottom(this.$element)</div><div class="line"></div><div class="line">  var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)</div><div class="line"></div><div class="line">  if (this.affixed != affix) &#123;</div><div class="line">    if (this.unpin != null) this.$element.css(&apos;top&apos;, &apos;&apos;)</div><div class="line"></div><div class="line">    var affixType = &apos;affix&apos; + (affix ? &apos;-&apos; + affix : &apos;&apos;)</div><div class="line">    var e = $.Event(affixType + &apos;.bs.affix&apos;)</div><div class="line"></div><div class="line">    this.$element.trigger(e)</div><div class="line"></div><div class="line">    if (e.isDefaultPrevented()) return</div><div class="line">    this.affixed = affix</div><div class="line">    this.unpin = affix == &apos;bottom&apos; ? this.getPinnedOffset() : null</div><div class="line"></div><div class="line">    this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace(&apos;affix&apos;, &apos;affixed&apos;) + &apos;.bs.affix&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (affix == &apos;bottom&apos;) &#123;</div><div class="line">    this.$element.offset(&#123;</div><div class="line">      top: scrollHeight - height - offsetBottom</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>若元素不可见则返回,这里的目标容器的高度是取的<code>document</code>和<code>document.body</code>之间的最大值。<br>获取选项中的<code>offset</code>变量，若为非对象则<code>offsetBottom</code>,<code>offsetTop</code>和<code>offset</code>相同。<br>若<code>offset</code>中的<code>offsetTop</code>和<code>offsetBottom</code>为函数则执行函数，这里是相当的有用的地方。<br><strong>这里若设置的<code>offset</code>为对象如<code>offset: { bottom: 30 }</code>则一开始就处在<code>affix</code>的状态。</strong><br>获得<code>affix</code>值,<code>this.getState(scrollHeight, height, offsetTop, offsetBottom)</code>。</p><p>当<code>this.affixed</code>不等于<code>affix</code>值的时候，如果<code>this.unpin</code>不为空则去除<code>top</code>值。重置的意思。<br><code>affixType</code>即为元素所处状态的类型若是在顶部阀值内则是<code>affix-top</code>类，若触发则是<code>affix</code>,若<br>这是自己合成了事件比如<code>affix-top.bs.affix</code>这样的事件，也就是说你可以自定义这个事件，在里面进行一些操作当滚动的时候，如果在自定义的函数里面<code>return false</code>即<code>e.isDefaultPrevented</code>为true, <code>if (e.isDefaultPrevented()) return</code>将不会继续执行下去。<br>例如可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(&apos;#J_nav&apos;).on(&apos;affix.bs.affix&apos;, function (e) &#123;</div><div class="line">  alert(&apos;haha&apos;);</div><div class="line">&#125;).affix(&#123;</div><div class="line">  offset: &#123;</div><div class="line">    bottom: 30</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p><code>this.affixed</code>赋值为重新获取的状态值, 若是到达底部阀值则赋值<code>this.unpin</code>即为获取即将进入<code>affix-bottom</code>状态的位移值。<br>然后为目标元素增加对应的目标元素粘滞状态的类并触发诸如<code>affix.bs.affix</code>的事件。</p><p>如果是到达底部的阀值即<code>affix</code>为<code>bottom</code>则设置目标元素的css<code>top</code>值为目标容器的内容高度(包含滚动距离)减去目标元素的高度减去底部阀值并设置元素为相对定位<code>relative</code>。</p><p><code>if (this.unpin != null) this.$element.css(&#39;top&#39;, &#39;&#39;)</code>若元素是从<code>affix-bottom</code>状态进入<code>affix</code>则去除元素的<code>top</code>值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Affix.prototype.checkPositionWithEventLoop = function () &#123;</div><div class="line">  setTimeout($.proxy(this.checkPosition, this), 1)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当点击滚动条的时候触发。</p><p>这里从代码可以发现一个问题，当滚动到底部阀值的时候:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (affix == &apos;bottom&apos;) &#123;</div><div class="line">  this.$element.offset(&#123;</div><div class="line">    top: scrollHeight - height - offsetBottom</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>会给目标元素增加<code>position: relative</code>这样的定位属性，但是当回到<code>affix</code>状态的时候，还会带着<code>position: relative</code>这个属性，显然是不对的搜索了下<a href="https://github.com/twbs/bootstrap/pull/19934/commits/855109da359ac31fad80eb5168a5ebfed5c74853" target="_blank" rel="external">bootstrap issues</a>。但是这个有问题，如果代码改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (this.unpin != null) &#123;</div><div class="line">  this.$element.css(&apos;position&apos;, &apos;&apos;)</div><div class="line">  this.$element.css(&apos;top&apos;, &apos;&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在状态切换的时候会出现页面抖动的现象！！</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> 当滚动到底部阀值的时候，元素会被设置成<code>position: relative</code>,当回到<code>affix</code>状态的时候，这个<code>affix</code>状态的样式类比如写成<code>position: fixed</code>就便无法起作用。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;许多情况下我们都需要去处理那种导航在页面滑动了一定的距离然后固定导航的需求，然后有可能会要求在滚动到距询问多少距离的时候又不固定导航。Bootstrap affix就是为此设计的。&lt;/p&gt;
&lt;p&gt;功能需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当页面滚动到一定距离即固定住元素&lt;/li
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="affix" scheme="http://yoursite.com/tags/affix/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-hoisting</title>
    <link href="http://yoursite.com/2017/08/13/JavaScript-hoisting/"/>
    <id>http://yoursite.com/2017/08/13/JavaScript-hoisting/</id>
    <published>2017-08-13T09:24:51.000Z</published>
    <updated>2017-08-13T09:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>变量声明是任何一门语言最基础的一个方面.然而，JavaScript也一点诡异，也就是被称为<em>声明提升</em>,这会导致一个看起来无害的变量声明变成一个微妙的bug.本文将阐述什么是提升声明并且教你如何避免被其困扰。</p><p>JavaScript是一门极其灵活的语言，所以可以让你随心所欲地在任何一个地方声明变量。比如，以下的自执行函数声明了三个变量并且之后用警告框来显示它们。需要注意的是，你不应该使用<code>alert</code>警告框,但是我们在这里是试着来验证<code>hoisted</code>而已。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  var bar = 2;</div><div class="line">  var baz = 3;</div><div class="line"></div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>这看起来是平常的JavaScript代码。正如期望的那样，它显示字符串<code>&quot;1 2 3&quot;</code>.现在，假设我们移动<code>alert</code>代码的位置，就像下面这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  var bar = 2;</div><div class="line">  var baz = 3;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>如果有人确实写过这样的代码，有可能是不小心写错的。明显地，弹框会在变量<code>bar</code>和<code>baz</code>声明之前就执行。然而这是完全可用而且不会产生异常的JavaScript代码。然而<code>alert</code>会显示<code>1 undefined undefined</code>。</p><p>基于我们之前的试验，JavaScript可以引用未声明的变量。现在，让我们执行相同的自执行函数(IIFE),但是完全移除了<code>baz</code>变量的声明，如下所示。突然间，因为<code>baz</code>变量未定义我们收到一个<code>ReferenceError</code>错误.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  var bar = 2;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><p>这是一个有趣的行为。为了理解这里发生了什么，你得理解提升声明。<code>Hoisting</code>是JavaScript解析器把所有的变量和函数声明移到目前脚本作用范围的顶部的操作(这里的脚本作用范围如果是在函数内部则是函数作用范围,否则是全局范围)然而，只有实际声明的变量才会<code>hoisted</code>.任何赋值都会留在原来的位置。因而，我们的第二段自执行的函数可以转化为以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo;</div><div class="line">  var bar;</div><div class="line">  var baz;</div><div class="line"></div><div class="line">  foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar + &quot; &quot; + baz);</div><div class="line">  bar = 2;</div><div class="line">  baz = 3;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure><p>现在你明白了为什么第二个例子不会产生异常。在经过提升声明后，变量<code>bar</code>和<code>baz</code>实际上会在alert语句之前声明，即使是undefined值。在第三个例子中，变量<code>baz</code>被完全移除。这样就没有变量可以用来提升声明,因此alert语句会抛出异常。</p><p>另外，需要注意的是如下的代码也是会同样抛出<code>ReferenceError</code>错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">  var foo = 1;</div><div class="line">  alert(foo + &quot; &quot; + bar);</div><div class="line">  bar = 2;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><h1 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h1><p>如前所述，函数声明也可以hoisted.然而,<strong>函数表达式不会提升声明</strong>。例如,得益于函数声明提升以下代码会如期正常运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">  alert(&quot;Hello!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然而，如下示例将肯定会失败。<code>foo</code>变量声明会提升在调用函数之前。然而，因为<code>foo</code>的赋值并没有提升,将会抛出一个由于试图调用一个非函数变量的异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line"></div><div class="line">var foo = function() &#123;</div><div class="line">  alert(&quot;Hello!&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p><em>提升声明</em>会影响变量生命周期，它包含了三个步骤:</p><ul><li>变量声明 - 创建变量。比如<code>var myvar</code></li><li>变量初始化 - 给变量赋值。比如<code>myvar = 150</code></li><li>访问变量 - 访问并且使用变量的值。比如<code>alert(myvar)</code></li></ul><p><em>提升声明</em>影响的范围:</p><ul><li>变量声明: 使用<code>var</code>, <code>let</code>或者<code>const</code>关键字</li><li>函数声明: 使用<code>function &lt;name&gt;(){...}</code>语法</li><li>类声明: 使用<code>class</code>关键字</li></ul><h1 id="函数作用域变量"><a href="#函数作用域变量" class="headerlink" title="函数作用域变量"></a>函数作用域变量</h1><p>声明的变量默认值是<code>undefined</code>.代码如下:<br><a href="http://jsbin.com/xizusi/edit?js,console" target="_blank" rel="external">打开Jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Declare num variable</div><div class="line">var num;  </div><div class="line">console.log(num); // =&gt; undefined  </div><div class="line">// Declare and initialize str variable</div><div class="line">var str = &apos;Hello World!&apos;;  </div><div class="line">console.log(str); // =&gt; &apos;Hello World!&apos;</div></pre></td></tr></table></figure><h1 id="块作用范围-let"><a href="#块作用范围-let" class="headerlink" title="块作用范围:let"></a>块作用范围:let</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">let声明</a>在块作用范围内声明并且初始化变量:<code>let myvar,myvar2 = &#39;Init&#39;</code>。默认情况下一个声明没初始化的变量拥有<code>undefined</code>值.</p><p><em>let</em>是由es6的一个极大的补充，它允许让代码模块化并且封装在块语句范围内.<br><a href="http://jsbin.com/jeyono/edit?js,console" target="_blank" rel="external">打开Jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;  </div><div class="line">  // Declare name block variable</div><div class="line">  let month;  </div><div class="line">  console.log(month); // =&gt; undefined  </div><div class="line">  // Declare and initialize year block variable</div><div class="line">  let year = 1994;  </div><div class="line">  console.log(year); // =&gt; 1994</div><div class="line">&#125;</div><div class="line">// name and year or not accessible here, outside the block</div><div class="line">console.log(year); // ReferenceError: year is not defined</div></pre></td></tr></table></figure><h1 id="Hoisting和let"><a href="#Hoisting和let" class="headerlink" title="Hoisting和let"></a>Hoisting和let</h1><p>摘自这篇<a href="https://github.com/getify/You-Dont-Know-JS/issues/767#issuecomment-227946671" target="_blank" rel="external">文章</a>:</p><blockquote><p>From the code author’s perspective, “declaring” is the var x part and “initializing” is the x = 2 part. But from the perspective of the spec/engine, these shift. “Declaring” is like registering a variable to a scope, “initializing” is reserving space/memory/binding for that variable so it can be used (and giving it its initial undefined value), and “assigning” is giving it a value explicitly in code.</p><p>Declaring always happens at time of compilation, and its effect can be seen whenever a scope is first entered. Initializing for var happens at the beginning of the scope, whereas it happens at the site of the declarator for let and const. Initialization is what gives a value its initial undefined value. Assignment then is when you actually use = to assign something to it.</p></blockquote><p>大概意思是说:在代码的作者看来,<code>声明</code>就是var x部分而<code>初始化</code>是指的x=2.但是从es6文档来看,<br><code>声明</code>是指在作用范围内注册这个变量，<code>初始化</code>是指为变量保留空间/内存/绑定以便它可以被引用(并且赋值它初始值<code>undefined</code>),而<code>赋值</code>是指显式地在代码中赋值。</p><p>声明永远发生在编译时，当进入作用域就只可以引用它。var变量的初始化发生在作用范围顶部，而let和const是在声明它们的地方。初始化就是赋值一个未定义的初始值。然后赋值是当你确实用<code>=</code>来赋值。</p><p>换句话也就是说，当声明<code>let</code>和<code>const</code>的时候，在它们之前只是进行了变量的注册，而未初始化，所以在<code>let</code>和<code>const</code>之前引用变量会出现<strong>变量引用错误</strong>.</p><p><code>let</code>会在块作用范围的顶部注册，但是当变量在声明前被访问会抛出错误：<code>ReferenceError: &lt;variable&gt; is not defined</code>.从变量声明语句到块作用范围的顶部，变量是在一个临时的死区(Temporal Dead Zone, 简称TDZ)并且不能够被访问.请看以下代码:<br><a href="http://jsbin.com/jodegoy/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function isTruthy(value) &#123;  </div><div class="line">  var myVariable = &apos;Value 1&apos;;</div><div class="line">  if (value) &#123;</div><div class="line">    /**</div><div class="line">     * temporal dead zone for myVariable</div><div class="line">     */</div><div class="line"></div><div class="line">    console.log(myVariable);// Throws ReferenceError: myVariable is not defined</div><div class="line">    let myVariable = &apos;Value 2&apos;;</div><div class="line">    // end of temporary dead zone for myVariable</div><div class="line">    console.log(myVariable); // =&gt; &apos;Value 2&apos;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  return false;</div><div class="line">&#125;</div><div class="line">var m = isTruthy(1); // =&gt; true</div><div class="line">console.log(m)</div></pre></td></tr></table></figure><p>在<code>myVariable</code>在从<code>let myVariable</code>到块语句<code>if (value) {...}</code>都是临时死区。如果在这个区间访问变量就会抛出一个引用的错误<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-native-error-types-used-in-this-standard-referenceerror" target="_blank" rel="external">ReferenceError</a></p><p>但是这里有一个疑问就是说:是否<code>myVariable</code>真的提升变量声明至在块声明语句中的顶,或者只是在临时死区未定义而已？</p><p>一个准确的解释是：当引擎遇到一个包含了<code>let</code>语句的块语句之中的时候，这个变量首先会在块语句顶部声明，在声明状态它仍然不能够被访问，但是它覆盖了作用范围外的同名的变量。之后当<code>let myvAR</code>被传值后，变量在初始化状态就可以被使用了。可以查看这个<a href="https://github.com/getify/You-Dont-Know-JS/issues/767#issuecomment-227946671" target="_blank" rel="external">解释</a></p><h1 id="常量-const"><a href="#常量-const" class="headerlink" title="常量:const"></a>常量:const</h1><p>常量<code>const</code>会在块语句顶部被注册。由于<em>临时死区</em>常量不能够在声明之前被访问.<br><code>const</code>提升声明和<code>let</code>语句一致的行为<br>比如以下代码:<br><a href="http://jsbin.com/desugig/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function double(number) &#123;  </div><div class="line">   // temporal dead zone for TWO constant</div><div class="line">   console.log(TWO); // ReferenceError: TWO is not defined</div><div class="line">   const TWO = 2;</div><div class="line">   // end of temporal dead zone</div><div class="line">   return number * TWO;</div><div class="line">&#125;</div><div class="line">double(5); // =&gt; 10</div></pre></td></tr></table></figure><h1 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_declarations" target="_blank" rel="external">类声明</a>定义了一个包含了名字的构造函数和方法。类声明是ES6的一个很好的补充。类是建立在JavaScript原型继承之上的并且拥有一些其它的优点比如<code>super</code>(用来访问父类），<code>static</code>（用来定义静态方法）,<code>extends</code>(定义子类)还有其它。<br>一个类声明如下:<br><a href="http://jsbin.com/doqelut/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Point &#123;  </div><div class="line">   constructor(x, y) &#123;</div><div class="line">     this.x = x;</div><div class="line">     this.y = y;     </div><div class="line">   &#125;</div><div class="line">   move(dX, dY) &#123;</div><div class="line">     this.x += dX;</div><div class="line">     this.y += dY;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">// Create an instance</div><div class="line">var origin = new Point(0, 0);  </div><div class="line">// Call a method</div><div class="line">origin.move(50, 100);</div></pre></td></tr></table></figure><p>如果在类声明之前访问类就会引发错误，JavaScript会抛出<code>ReferenceError: &lt;name&gt; is not defined</code>的错误。<br>如下代码:<br><a href="http://jsbin.com/budopew/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// Use the Company class</div><div class="line">// Throws ReferenceError: Company is not defined</div><div class="line">var apple = new Company(&apos;Apple&apos;);  </div><div class="line">// Class declaration</div><div class="line">class Company &#123;  </div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name;    </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// Use correctly the Company class after declaration</div><div class="line">var microsoft = new Company(&apos;Microsoft&apos;);</div></pre></td></tr></table></figure><p>也可以用类表达式的方式来创建类。<br>代码如下:<br><a href="http://jsbin.com/vumomeq/edit?js,console" target="_blank" rel="external">打开jsbin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// Use the Sqaure class</div><div class="line">console.log(typeof Square);   // =&gt; &apos;undefined&apos;  </div><div class="line">//Throws TypeError: Square is not a constructor</div><div class="line">var mySquare = new Square(10);  </div><div class="line">// Class declaration using variable statement</div><div class="line">var Square = class &#123;  </div><div class="line">  constructor(sideLength) &#123;</div><div class="line">    this.sideLength = sideLength;    </div><div class="line">  &#125;</div><div class="line">  getArea() &#123;</div><div class="line">    return Math.pow(this.sideLength, 2);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">// Use correctly the Square class after declaration</div><div class="line">var otherSquare = new Square(5);</div></pre></td></tr></table></figure><p>因为<code>Square</code>类声明提升到作用域的顶端，在类声明行之前都是<code>undefined</code>的值，所以当在类声明之前用<code>var mySquare = new Square(10)</code>会导致JavaScript抛出错误<code>TypeError: Square is not a constructor</code>.</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p><code>Hoisting</code>很容易理解，但是是经常忽视了JavaScript语言的细微差别。没有清晰地理解提升声明，你的程序将会容易受微妙bug的影响.为了帮助解决这个问题，很多开发者（和linting语法校验工具）主张在每个脚本作用范围的顶端单独写变量声明的语句。因为本质上这是JavaScript解析器如何解析你的代码，这条规则是有效的-即使我会因为打破这条规则而内疚。<br>有一个地方就是关于函数的提升声明，如果当程序员想要在源文件的顶部知道函数是如何调用的而不用滚动到函数声明的地方去查看函数的详细实现细节，例如<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#bindable-members-up-top" target="_blank" rel="external">看这里</a>来查看这种技术是如何增加了<em>Angular</em>控制器的可读成性的.</p><p>以上文字译自<a href="https://www.sitepoint.com/back-to-basics-javascript-hoisting/" target="_blank" rel="external">Back to Basics: JavaScript Hoisting</a>和<a href="https://rainsoft.io/javascript-hoisting-in-details/" target="_blank" rel="external">javascript-hoisting-in-details</a>,文字方面有进行过相关的缩略。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;变量声明是任何一门语言最基础的一个方面.然而，JavaScript也一点诡异，也就是被称为&lt;em&gt;声明提升&lt;/em&gt;,这会导致一个看起来无害的变量声明变成一个微妙的bug.本文将阐述什么是提升声明并且教你如何避免被其困扰。&lt;/p&gt;
&lt;p&gt;JavaScript是一门极其灵活的
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="Hoisting" scheme="http://yoursite.com/tags/Hoisting/"/>
    
  </entry>
  
  <entry>
    <title>NodeClub源码解析</title>
    <link href="http://yoursite.com/2017/08/10/NodeClub%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2017/08/10/NodeClub源码解析/</id>
    <published>2017-08-10T13:42:20.000Z</published>
    <updated>2017-08-10T13:42:20.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS组件库</title>
    <link href="http://yoursite.com/2017/08/10/CSS%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/10/CSS组件库/</id>
    <published>2017-08-10T13:38:17.000Z</published>
    <updated>2017-08-10T13:38:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Token-based-auth</title>
    <link href="http://yoursite.com/2017/08/10/Token-based-auth/"/>
    <id>http://yoursite.com/2017/08/10/Token-based-auth/</id>
    <published>2017-08-10T13:37:13.000Z</published>
    <updated>2017-08-13T09:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在前后端分离如火如荼，传统的基于<strong>cookie的认证</strong>也有诸多不便。就目前自己所知有如下限制：</p><ul><li><p>首先，按照传统的基于cookie的认证，基于cookie的认证即服务器通过保存于客户端中的<strong>sessionid</strong>标识符来识别用户, 服务器必须得维持一份认证的状态。那么为了持久化session即在当服务器宕机或者转移的情况下，可以保证当服务器恢复之后，客户端访问不需要再次登录。这样会增加服务器开销而如今的<em>API DESIGN</em>是围绕着api来进行设计的,<strong>restful设计</strong>,请允许我咬文嚼字一下，restful即无状态服务吧^-^.</p></li><li><p>第二，有的应用场景下并未支持cookie,这个时候的解决方案有:采用url重写，表单隐藏域。我没弄过url重写，表单隐藏域也没弄过，真抱歉。对了，在微信端的时候关于用户的识别，由于微信是没支持cookie的所以需要自己实现一下session,可以利用openid来作为唯一标识，因为openid是唯一的具体可以参见<a href="https://github.com/node-webot/wechat/blob/master/lib/session.js" target="_blank" rel="external">node-webot</a>的session实现。</p></li><li><p>第三, api服务器往往会部署在另一台服务器上面，这样会造成浏览器的跨域，所以这个时候的解决办法是服务器端需要进行跨域的设置。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With, accept, content-type, xxxx&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</div><div class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://127.0.0.1:8010&quot;);//这里必须指定地址而不能写成星号否则浏览器会提示不能为星号</div></pre></td></tr></table></figure><p>然后前端的ajax请求库中必须设置<code>withCredentials</code>为<code>true</code>。<s>然而基于token的认证并无跨域问题</s>。</p><p>那么基于token的认证用到的主要有以下插件:</p><ul><li><a href="https://www.npmjs.com/package/bcrypt" target="_blank" rel="external">bcrypt</a> 加盐哈希密码用，有效抵御彩虹攻击。</li><li><a href="https://www.npmjs.com/package/jsonwebtoken" target="_blank" rel="external">jsonwebtoken</a> 用来生成符合<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="external">JSON WEB Tokens</a>标准的令牌</li><li><a href="https://www.npmjs.com/package/express-jwt" target="_blank" rel="external">express-jwt</a> 用来验证JsonWebTokens的中间件</li><li><a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">crypto-js</a> 前后端密码加密</li></ul><p>关于JsonWebToken可以参考这个<a href="https://jwt.io/" target="_blank" rel="external">网站</a>。</p><p>项目是采用express-generator构建的。<code>npm i -g express-generator</code>即可。</p><p><em>express-jwt默认是检查请求头中的<code>authorization</code>字段来进行token的验证的但是也可以进行自定义获取token的方法</em>。然后会把相关的用户信息存储在<code>req.user</code>中。<br>比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">app.use(jwt(&#123;</div><div class="line">  secret: &apos;hello world !&apos;,</div><div class="line">  credentialsRequired: false, // 未注册的用户也可访问</div><div class="line">  getToken: function fromHeaderOrQuerystring (req) &#123;</div><div class="line">    // 从头部信息获取或者在url上类似?token=adadfs这样获取</div><div class="line">    if (req.headers.authorization &amp;&amp; req.headers.authorization.split(&apos; &apos;)[0] === &apos;Bearer&apos;) &#123;</div><div class="line">        return req.headers.authorization.split(&apos; &apos;)[1]</div><div class="line">    &#125; else if (req.query &amp;&amp; req.query.token) &#123;</div><div class="line">      return req.query.token</div><div class="line">    &#125;</div><div class="line">    return null</div><div class="line">  &#125;</div><div class="line">&#125;))</div></pre></td></tr></table></figure><p>下面贴出主要的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/login&apos;, function(req, res) &#123;</div><div class="line">  let userName = req.body.username</div><div class="line">  let password = entities.encode(req.body.password)</div><div class="line">  // find user</div><div class="line">  conn.query(&apos;SELECT * FROM user WHERE user_name = ?&apos;, [</div><div class="line">    userName</div><div class="line">  ], function (err, results, fields) &#123;</div><div class="line">    if (!err) &#123;</div><div class="line">      let user = results[0]</div><div class="line">      // validate password</div><div class="line">      bcrypt.compare(password, user.password, function (err, result) &#123;</div><div class="line">        console.log(user)</div><div class="line">        if (result) &#123;</div><div class="line">        // Dispatch token expired after 2mins for client</div><div class="line">          let token = jwt.sign(&#123; user_name: user.user_name &#125;, secret, &#123; expiresIn: 60 * 2 &#125;)</div><div class="line">          res.json(&#123;</div><div class="line">            code: &apos;0&apos;,</div><div class="line">            token: token</div><div class="line">          &#125;)</div><div class="line">        &#125; else &#123;</div><div class="line">          res.json(&#123;</div><div class="line">            code: &apos;1&apos;,</div><div class="line">            error: &apos;用户不存在&apos;</div><div class="line">          &#125;)</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125; else &#123;</div><div class="line">      res.json(&#123;</div><div class="line">        code: &apos;2&apos;,</div><div class="line">        error: &apos;用户不存在&apos;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>当用户登录的时候检测用户输入的用户名密码是否正确。如果正确则派发出token并在2分钟之后让其过期。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// protected api</div><div class="line">app.all(&apos;/api/*&apos;, jwtVerify(&#123;secret: secret&#125;), function(err, req, res, next) &#123;</div><div class="line">  // 当令牌过期则返回401否则通过</div><div class="line">  if (err.name === &apos;UnauthorizedError&apos;) &#123;</div><div class="line">    res.status(401).send(&apos;Invalid token...&apos;)</div><div class="line">  &#125;</div><div class="line">  next()</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>然后再在所需要验证的api下使用中间件进行验证，当令牌过期则返回401。</p><p>以上就是主要的代码了，那么这里的话可以看到，完全是无状态的即真正的restful(休息ful哈哈，就是无状态嘛），服务端无需专门维护登录的用户状态信息，也省去维护的开销。</p><p>代码可见<a href="https://github.com/Troland/token-based-auth" target="_blank" rel="external">这里</a>。</p><p>可是这样做，会不会有什么问题呢？</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> 登录次数限制</li><li style="list-style: none"><input type="checkbox"> 安全检测</li><li style="list-style: none"><input type="checkbox" checked> 权限控制</li><li style="list-style: none"><input type="checkbox"> 用户注册进行严格的密码字符的控制</li></ul><hr><p>2017.8.13</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>现在由于有好些都是前后端分离的项目所以会出现跨域的问题，关于跨域的问题网上已有很多，这里不再赘述。这里只提供些方法:</p><ul><li>现在前后端分离，往往是后端作为API Server,然后关于前端的静态资源会走其它服务器。比如nginx配置成当请求数据服务器的时候导向后端的tomcats。</li></ul><p>举例如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">http</div><div class="line">&#123;</div><div class="line">  upstream tomcats</div><div class="line">  &#123;</div><div class="line">    server 127.0.0.1:9001;</div><div class="line">    server 127.0.0.1:9002;</div><div class="line">  &#125;</div><div class="line">  server &#123;</div><div class="line">      listen       8000;</div><div class="line">      server_name  localhost;</div><div class="line"></div><div class="line">      # 如果请求路径跟文件路径按照如下方式匹配找到了，直接返回</div><div class="line">      try_files $uri $uri/index.html;</div><div class="line">      location ^/(js|css|image|font)/ &#123;</div><div class="line">        # 静态资源都在 static 文件夹下</div><div class="line">        root /abc/static/;</div><div class="line">      &#125;</div><div class="line">      #charset koi8-r;</div><div class="line"></div><div class="line">      #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">      location / &#123;</div><div class="line">          root   /pathtoroot;</div><div class="line">          index  index.html index.htm;</div><div class="line">      &#125;</div><div class="line">      error_page  404              /404.html;</div><div class="line"></div><div class="line">      location /api &#123;</div><div class="line">          proxy_set_header X-Real-IP $remote_addr;</div><div class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</div><div class="line">          proxy_set_header Host $http_host;</div><div class="line">          proxy_set_header X-NginX-Proxy true;</div><div class="line">          proxy_pass http://tomcats;</div><div class="line">          proxy_redirect off;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当请求的是静态资源的时候就会指向nginx指定的目录，当是请求的api的时候会指向tomcat集群</p><ul><li>服务器配置允许跨域</li></ul><p>如果是<code>node</code>的话可以去加载<a href="https://www.npmjs.com/package/cors" target="_blank" rel="external">cors</a>包。示例代码码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 当跨域配置用cors插件</div><div class="line">const cors = require(&apos;cors&apos;)</div><div class="line">// 设置白免单可以指定允许多个ip源访问</div><div class="line">const whitelist = [</div><div class="line">  &apos;http://192.168.1.139:3003&apos;,</div><div class="line">  &apos;http://192.168.1.139:3100&apos;</div><div class="line">]</div><div class="line">const corsOptions = &#123;</div><div class="line">  origin: (origin, callback) =&gt; &#123;</div><div class="line">    if (whitelist.indexOf(origin) !== -1) &#123;</div><div class="line">      callback(null, true)</div><div class="line">    &#125; else &#123;</div><div class="line">      callback(new Error(&apos;Not allowed by CORS&apos;))</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  credentials: true, //这里必须写这样才能够接收到header里面的cookie,若不需要获得cookie可不设置</div><div class="line">  optionsSuccessStatus: 200, // some legacy browsers (IE11, various SmartTVs) choke on 204</div><div class="line">  methods: &apos;GET,HEAD,PUT,PATCH,POST,DELETE&apos;</div><div class="line">&#125;</div><div class="line">const app = express()</div><div class="line"></div><div class="line">app.use(cors(corsOptions))</div><div class="line"></div><div class="line">app.post(&apos;/api/num&apos;, function (req, res) &#123;</div><div class="line">  // 假设头是request.setRequestHeader(&apos;Authorization&apos;, &apos;Bearer &apos; + token);</div><div class="line">  req.get(&apos;authorization&apos;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h2><p>引用<a href="https://www.npmjs.com/package/express-jwt-permissions" target="_blank" rel="external">express-jwt-permissions</a>。<br>你可以全局使用这个权限的检查也可以只为某些受保护的资源进行权限控制，例如：</p><p>全局使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const guard = require(&apos;express-jwt-permissions&apos;)()</div><div class="line">guard.check(&apos;admin&apos;)</div></pre></td></tr></table></figure><p>为受保护资源进行权限控制:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.post(&apos;/api/user&apos;, guard.check(&apos;status1&apos;), function (req, res) &#123;</div><div class="line">  console.log(&apos;Permissions:&apos;, req.user)</div><div class="line">  res.json(&#123;</div><div class="line">    code: 200,</div><div class="line">    username: &apos;tristan&apos;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>那么这里的<code>permission</code>是从哪来的呢？<br>首先用户注册，会获得默认的权限值, 或者由超级管理员进行注册生成用户。然后，超级管理员为用户设置权限。生成用户对应的<code>permission</code>值。</p><p>代码可见<a href="https://github.com/Troland/permission" target="_blank" rel="external">这里</a>。</p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> <strong>那么当项目是否是前后端分离的时候，这个权限应该如何控制会是最优解呢？</strong></li></ul><p>且听下回分解^.^。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在前后端分离如火如荼，传统的基于&lt;strong&gt;cookie的认证&lt;/strong&gt;也有诸多不便。就目前自己所知有如下限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先，按照传统的基于cookie的认证，基于cookie的认证即服务器通过保存于客户端中的&lt;strong&gt;sess
      
    
    </summary>
    
      <category term="Backend" scheme="http://yoursite.com/categories/Backend/"/>
    
    
      <category term="token" scheme="http://yoursite.com/tags/token/"/>
    
      <category term="jwt" scheme="http://yoursite.com/tags/jwt/"/>
    
      <category term="jsonwebtoken" scheme="http://yoursite.com/tags/jsonwebtoken/"/>
    
  </entry>
  
  <entry>
    <title>CSS常用库</title>
    <link href="http://yoursite.com/2017/08/10/CSS%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/10/CSS常用库/</id>
    <published>2017-08-10T13:35:14.000Z</published>
    <updated>2017-09-10T09:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>input的line-height样式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.input &#123;</div><div class="line">  width: 100px;</div><div class="line">  line-height: 1.8;</div><div class="line">  font-size: 18px;</div><div class="line">  box-sizing: border-box;</div><div class="line">  padding: 5px;</div><div class="line">  border: 1px solid #f00;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.input &#123;</div><div class="line">  height: 30px;</div><div class="line">  line-height: 30px;</div><div class="line">  padding: 0 10px;</div><div class="line">  border: 1px solid #f00;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">input &#123;</div><div class="line">  -webkit-appearance: none;</div><div class="line">  -moz-appearance: none;</div><div class="line">  appearance: none;</div><div class="line">  background-color: #fff;</div><div class="line">  background-image: none;</div><div class="line">  border-radius: 4px;</div><div class="line">  border: 1px solid #bfcbd9;</div><div class="line">  box-sizing: border-box;</div><div class="line">  color: #1f2d3d;</div><div class="line">  display: inline-block;</div><div class="line">  font-size: inherit;</div><div class="line">  height: 36px;</div><div class="line">  line-height: 1;</div><div class="line">  outline: none;</div><div class="line">  padding: 3px 10px;</div><div class="line">  transition: border-color .2s cubic-bezier(.645,.045,.355,1);</div><div class="line">  width: 100%;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong><code>vertical-align: middle;</code>是当元素和其它内联元素比如button等在一个div的时候可以垂直居中对齐</strong><br>这样输入文字居中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;input的line-height样式:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Bootstrap scrollspy 源码解读</title>
    <link href="http://yoursite.com/2017/08/06/Bootstrap-scrollspy-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/08/06/Bootstrap-scrollspy-源码解读/</id>
    <published>2017-08-06T07:35:13.000Z</published>
    <updated>2017-10-08T13:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：</p><p>功能需求:</p><ul><li>当点击导航栏的时候会显示对应的内容块到顶部。</li><li>当页面滚动的时候，当到达对应导航的内容块，则会激活导航。</li></ul><p><strong>需要注意的是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动，从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets，这个时候就需要调用refresh方法进行重新计算offsets和targets。</strong></p><p>Bootstrap scrollspy源码解读：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">this.$scrollElement: 滚动的容器</div><div class="line">this.selector: 导航选择器</div><div class="line">this.targets: 导航的元素</div><div class="line">this.activeTarget: 激活状态的导航元素</div><div class="line">this.offsets: 内容块元素的在页面中的位移</div><div class="line">*/</div><div class="line">function ScrollSpy(element, options) &#123;</div><div class="line">    this.$body          = $(document.body)</div><div class="line">    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)</div><div class="line">    this.options        = $.extend(&#123;&#125;, ScrollSpy.DEFAULTS, options)</div><div class="line">    this.selector       = (this.options.target || &apos;&apos;) + &apos; .nav li &gt; a&apos;</div><div class="line">    this.offsets        = []</div><div class="line">    this.targets        = []</div><div class="line">    this.activeTarget   = null</div><div class="line">    this.scrollHeight   = 0</div><div class="line"></div><div class="line">    this.$scrollElement.on(&apos;scroll.bs.scrollspy&apos;, $.proxy(this.process, this))</div><div class="line">    this.refresh()</div><div class="line">    this.process()</div><div class="line">  &#125;</div></pre></td></tr></table></figure><p>首先在<code>ScrollSpy</code>构造函数中,先获得滚动容器，导航选择器等，然后调用<code>refresh</code>和<code>process</code>函数来初始化实例。<br>获得容器的内容高度<code>scrollHeight</code>,<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">scrollHeight</a>。<br>并绑定滚动容器的滚动事件为<code>this.process</code>。</p><p>再来看<code>refresh</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.refresh = function () &#123;</div><div class="line">    var that          = this</div><div class="line">    var offsetMethod  = &apos;offset&apos;</div><div class="line">    var offsetBase    = 0</div><div class="line"></div><div class="line">    this.offsets      = []</div><div class="line">    this.targets      = []</div><div class="line">    this.scrollHeight = this.getScrollHeight()</div><div class="line"></div><div class="line">    /*判断滚动窗口是否为body*/</div><div class="line">    if (!$.isWindow(this.$scrollElement[0])) &#123;</div><div class="line">      offsetMethod = &apos;position&apos;</div><div class="line">      offsetBase   = this.$scrollElement.scrollTop()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.$body</div><div class="line">      .find(this.selector)</div><div class="line">      .map(function () &#123;</div><div class="line">        var $el   = $(this)</div><div class="line">        var href  = $el.data(&apos;target&apos;) || $el.attr(&apos;href&apos;)</div><div class="line">        var $href = /^#./.test(href) &amp;&amp; $(href)</div><div class="line"></div><div class="line">        return ($href</div><div class="line">          &amp;&amp; $href.length</div><div class="line">          &amp;&amp; $href.is(&apos;:visible&apos;)</div><div class="line">          &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null</div><div class="line">      &#125;)</div><div class="line">      .sort(function (a, b) &#123; return a[0] - b[0] &#125;)</div><div class="line">      .each(function () &#123;</div><div class="line">        that.offsets.push(this[0])</div><div class="line">        that.targets.push(this[1])</div><div class="line">      &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这里的意思是设置实例的内容块的offsets和导航栏的targets,并按升序排列。这里有一个问题就是为什么当滚动的容器不是window的话<code>offsetBase</code>为滚动容器的滚动距离？因为当一个元素在一个滚动容器里面的时候元素在滚动容器中的绝对位移值是元素的<code>position().top</code>的值加上滚动容器的滚动距离，所以这里需要写上滚动容器的滚动距离。</p><p>接下来是<code>process</code>函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scrollTop: 元素已经滚动的距离加上距离顶部的距离</div><div class="line">maxScroll: 滚动容器可滚动距离</div><div class="line">activeTarget: 当前激活的导航元素</div><div class="line"></div><div class="line">*/</div><div class="line">ScrollSpy.prototype.process = function () &#123;</div><div class="line">    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset</div><div class="line">    var scrollHeight = this.getScrollHeight()</div><div class="line">    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()</div><div class="line">    var offsets      = this.offsets</div><div class="line">    var targets      = this.targets</div><div class="line">    var activeTarget = this.activeTarget</div><div class="line">    var i</div><div class="line"></div><div class="line">    /*</div><div class="line">    这里的意思是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动</div><div class="line">    从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets</div><div class="line">    */</div><div class="line">    if (this.scrollHeight != scrollHeight) &#123;</div><div class="line">      this.refresh()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">    当滚动距离超过最大可滚动距离，并且activeTarget和最后一个激活元素地址不一致则激活最后一级导航</div><div class="line">    */</div><div class="line">    if (scrollTop &gt;= maxScroll) &#123;</div><div class="line">      return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     当滚动距离小于offsets中的第一个并且有激活的导航的时候就不激活导航</div><div class="line">    */</div><div class="line">    if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) &#123;</div><div class="line">      this.activeTarget = null</div><div class="line">      return this.clear()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i = offsets.length; i--;) &#123;</div><div class="line">      activeTarget != targets[i]</div><div class="line">        &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">        &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">        &amp;&amp; this.activate(targets[i])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (i = offsets.length; i--;) &#123;</div><div class="line">  activeTarget != targets[i]</div><div class="line">    &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">    &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">    &amp;&amp; this.activate(targets[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当前激活的导航和targets数组一一比对如果不是当前激活导航则再比对，注意到这里的比对是<em>从位移数组的最后一个开始倒序进行比对的</em>, 然后当滚动距离大于位移数组的当前并且小于下一个，或者位移数组的最后一个不存在，即为最后一个导航的时候。则激活目标导航, <strong>那么这里你所看到的现象即: 当上一个目标内容元素完全消失于viewport(视窗)之中的时候,下一个内容块到达视窗顶部的时候即激活当前的导航所在的元素</strong>。当当然这里也有性能优化的意思，然后倒序来比较有一个好处就是，如果是升序比较就得计算那个<em>内容元素的高度来进行比较</em>，但是倒序则不用。</p><p>疑问:</p><ul><li>为什么当滚动容器是body的时候<code>offsetMethod</code>为<em>offset</em>非<code>body</code>的时候为<em>position</em>?</li></ul><p>因为当滚动容器为body的时候就得计算元素在body上面的位移，而如果非body的话就在滚动容器里面比如<br><code>&lt;div class=&quot;scroll-container&quot;&gt;&lt;/div&gt;</code>当滚动的内容在里面的时候得设置滚动容器的样式<code>position: relative</code>。<br>当设置为<code>position</code>的时候里面的内容元素即为相对于此容器的位移而不是相对于<code>body</code>。</p><p>翻看<code>jQuery源码</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">position: function() &#123;</div><div class="line">  if ( !this[ 0 ] ) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var offsetParent, offset,</div><div class="line">    elem = this[ 0 ],</div><div class="line">    parentOffset = &#123; top: 0, left: 0 &#125;;</div><div class="line"></div><div class="line">  // Fixed elements are offset from window (parentOffset = &#123;top:0, left: 0&#125;,</div><div class="line">  // because it is its only offset parent</div><div class="line">  if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) &#123;</div><div class="line"></div><div class="line">    // Assume getBoundingClientRect is there when computed position is fixed</div><div class="line">    offset = elem.getBoundingClientRect();</div><div class="line"></div><div class="line">  &#125; else &#123;</div><div class="line"></div><div class="line">    // Get *real* offsetParent</div><div class="line">    offsetParent = this.offsetParent();</div><div class="line"></div><div class="line">    // Get correct offsets</div><div class="line">    offset = this.offset();</div><div class="line">    if ( !jQuery.nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) &#123;</div><div class="line">      parentOffset = offsetParent.offset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Add offsetParent borders</div><div class="line">    parentOffset = &#123;</div><div class="line">      top: parentOffset.top + jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true ),</div><div class="line">      left: parentOffset.left + jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true )</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Subtract parent offsets and element margins</div><div class="line">  return &#123;</div><div class="line">    top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),</div><div class="line">    left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )</div><div class="line">  &#125;;</div><div class="line">&#125;,</div><div class="line">offsetParent: function() &#123;</div><div class="line">  return this.map( function() &#123;</div><div class="line">    var offsetParent = this.offsetParent;</div><div class="line"></div><div class="line">    while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) &#123;</div><div class="line">      offsetParent = offsetParent.offsetParent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return offsetParent || documentElement;</div><div class="line">  &#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的源码大概意思如果元素不是<code>fixed</code>定位则通过<code>offsetParent</code>函数找出最近的定位的元素。</p><p>接下来是激活导航的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.activate = function (target) &#123;</div><div class="line">  this.activeTarget = target</div><div class="line"></div><div class="line">  this.clear()</div><div class="line"></div><div class="line">  var selector = this.selector +</div><div class="line">    &apos;[data-target=&quot;&apos; + target + &apos;&quot;],&apos; +</div><div class="line">    this.selector + &apos;[href=&quot;&apos; + target + &apos;&quot;]&apos;</div><div class="line"></div><div class="line">  var active = $(selector)</div><div class="line">    .parents(&apos;li&apos;)</div><div class="line">    .addClass(&apos;active&apos;)</div><div class="line"></div><div class="line">  // 若激活的导航的父元素有dropdown-men类则为其</div><div class="line">  if (active.parent(&apos;.dropdown-menu&apos;).length) &#123;</div><div class="line">    active = active</div><div class="line">      .closest(&apos;li.dropdown&apos;)</div><div class="line">      .addClass(&apos;active&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  active.trigger(&apos;activate.bs.scrollspy&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>最后是那个<code>noConflict</code>方法, 因为有可能会有重名方法的插件所以需要使用这个关于这个的处理可以参见<a href="http://www.cnblogs.com/ip128/p/4609828.html" target="_blank" rel="external">这里</a>。我在这个基础上增加了自己的一个处理方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var old = $.fn.scrollspy</div><div class="line"></div><div class="line">$.fn.scrollspy             = Plugin</div><div class="line">$.fn.scrollspy.Constructor = ScrollSpy</div><div class="line"></div><div class="line"></div><div class="line">// SCROLLSPY NO CONFLICT</div><div class="line">// =====================</div><div class="line"></div><div class="line">$.fn.scrollspy.noConflict = function () &#123;</div><div class="line">  $.fn.scrollspy = old</div><div class="line">  return this</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在实际使用的过程中,根据所使用的Bootstrap插件在页面中出现的位置会有不同的处理方法,下面分情况来讲解:</p><ul><li>当Bootstrap插件在自定义的插件之后的时候, 若想调用自定义的插件则<code>$.fn.scrollspy.noConflict</code>即可。</li><li><p>若Bootstrap插件在自定义的插件之前: 则有两种解决办法:</p><ul><li><p>可以在两个插件之间写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Af = $.fn.scrollspy.noConflict()</div><div class="line">$.fn.Af = Af</div><div class="line">这样后面想要调用该方法就调用`$(el).Af()`</div></pre></td></tr></table></figure></li><li><p>或者是把后面自定义的插件写成类似这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function($)&#123;</div><div class="line">      var old = $.fn.scrollspy; //必须写在第一行</div><div class="line">      $.fn.scrollspy=function()&#123;</div><div class="line">          alert(&quot;自定义scrollspy插件&quot;);</div><div class="line">      &#125;</div><div class="line">      $.fn.scrollspy.noConflict = function () &#123;</div><div class="line">        $.fn.scrollspy = old</div><div class="line">        return this</div><div class="line">      &#125;</div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure></li></ul></li></ul><p>疑问：</p><ul><li>这里为什么要用<code>parents</code>?</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var active = $(selector)</div><div class="line">          .parents(&apos;li&apos;)</div><div class="line">          .addClass(&apos;active&apos;)</div></pre></td></tr></table></figure><p>清除激活状态导航的激活状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.clear = function () &#123;</div><div class="line">    $(this.selector)</div><div class="line">      .parentsUntil(this.options.target, &apos;.active&apos;)</div><div class="line">      .removeClass(&apos;active&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>当那些导航是异步请求加载出来的，这个时候应该如何做？</li></ul><hr><p>2017.10.8 如果导航是异步请求出来的可以在数据请求完成后再去进行实例化。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>其实，这个说到底不管滚动的容器是window还是不是，基本上都是要以元素的<code>getBoundingClientRect</code>属性为准，看过<strong>jQuery</strong>的源码即可知。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：&lt;/p&gt;
&lt;p&gt;功能需求:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当点击导航栏的时候会显示对应的内容块到顶部。&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
      <category term="scrollSpy" scheme="http://yoursite.com/tags/scrollSpy/"/>
    
      <category term="offset" scheme="http://yoursite.com/tags/offset/"/>
    
      <category term="position" scheme="http://yoursite.com/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>二维码登录</title>
    <link href="http://yoursite.com/2017/07/21/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95/"/>
    <id>http://yoursite.com/2017/07/21/二维码登录/</id>
    <published>2017-07-21T01:21:16.000Z</published>
    <updated>2017-07-21T01:21:16.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用CSS3详解</title>
    <link href="http://yoursite.com/2017/06/18/%E5%B8%B8%E7%94%A8CSS3%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/06/18/常用CSS3详解/</id>
    <published>2017-06-18T15:24:15.000Z</published>
    <updated>2017-11-15T12:50:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在整理CSS3的属性的原理，特意分享一下个人的一些理解。</p><h2 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h2><p><code>transform-origin</code>是改变一个元素的变形的原点通常是和<code>transform</code>一起使用。<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin" target="_blank" rel="external">transform-origin</a> MDN上说明:</p><blockquote><p>transform-origin CSS属性让你更改一个元素变形的原点。例如，rotate()的transform-origin 是旋转的中心点 (这个属性的应用原理是先用这个属性的负值translate该元素，进行变形，然后再用这个属性的值把元素translate回去)。</p></blockquote><p>假设有以下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.grid &#123;</div><div class="line"> transform: rotate(30deg);</div><div class="line"> transform-origin: 70% 50%;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>transform-origin</code>属性的默认值是<code>50% 50%</code>。等于是<strong>放置的中心点水平移动到70%移动了20%</strong>,为了保持旋转的角度仍旧为30deg,这个时候元素必须往上移动，否则那个旋转的角度将会变大。</p><p>如下图所示：<br><img src="/images/css-transform-origin.png" alt=""></p><p>可以玩一下<a href="http://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html" target="_blank" rel="external">w3Ctransform-origin演示地址</a></p><h2 id="webkit-box"><a href="#webkit-box" class="headerlink" title="webkit-box"></a>webkit-box</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在整理CSS3的属性的原理，特意分享一下个人的一些理解。&lt;/p&gt;
&lt;h2 id=&quot;transform-origin&quot;&gt;&lt;a href=&quot;#transform-origin&quot; class=&quot;headerlink&quot; title=&quot;transform-origin&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="css3" scheme="http://yoursite.com/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs碎碎念</title>
    <link href="http://yoursite.com/2017/06/08/Nodejs%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://yoursite.com/2017/06/08/Nodejs碎碎念/</id>
    <published>2017-06-08T14:21:01.000Z</published>
    <updated>2017-10-16T15:06:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录Nodejs使用中的问题与解决方案。</p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>exports只是module.exports的引用</p><h2 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h2><p><strong>大小固定不变</strong>。</p><p>当需要保存非<em>utf-8</em>字符串,2进制等其他格式的时候，就必须得使用。比如最近有使用过微信SDK上传图片并通过微信返回的<code>serverID即媒体id</code>来把微信上的图片下载下来。返回数据即为<code>Buffer</code>对象。</p><h2 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">  process.nextTick(() =&gt; test());</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function test() &#123;</div><div class="line">  setTimeout(() =&gt; test(), 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>关于高并发</strong> nodejs是通过事件循环来挨个抽取事件队列中的一个个<strong>Task</strong>来执行，来获得高并发。</p><h2 id="进程，子进程"><a href="#进程，子进程" class="headerlink" title="进程，子进程"></a>进程，子进程</h2><p><strong>IPC</strong>进程间通讯技术</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><p>Node.js利用多核的办法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录Nodejs使用中的问题与解决方案。&lt;/p&gt;
&lt;h2 id=&quot;模块&quot;&gt;&lt;a href=&quot;#模块&quot; class=&quot;headerlink&quot; title=&quot;模块&quot;&gt;&lt;/a&gt;模块&lt;/h2&gt;&lt;p&gt;exports只是module.exports的引用&lt;/p&gt;
&lt;h2 id=&quot;Buf
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="Nodejs" scheme="http://yoursite.com/tags/Nodejs/"/>
    
      <category term="Buffer" scheme="http://yoursite.com/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>Session与Cookie小结</title>
    <link href="http://yoursite.com/2017/05/20/Session%E4%B8%8ECookie%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/20/Session与Cookie小结/</id>
    <published>2017-05-20T03:57:05.000Z</published>
    <updated>2017-08-10T13:43:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学session与cookie相关的内容，有以下几点疑点：</p><ul><li>Session存储在哪？</li><li>记住密码功能及相关的bug</li><li>Session持久化</li><li>如果在cookie中保存那个登录信息应该保存些信息？</li></ul><p>当为检查是否已经登录是通过检查<code>req.session</code>还是通过<code>req.cookies[&#39;isLogged&#39;]</code>,这两者有区别吗？过期时间都是一致的吗？</p><p>登录流程:</p><ul><li>登录系统，填写用户名和密码，后端检测用户名和密码，成功则设置一个登录的cookie</li><li>这个sessid标识符和token应该是随机的值，且都在表中，就应该那个数据库表tokens应该是一个sessid标识符对应一个token吧，然后这个token应该是个哈希值</li><li><p>最后当未从登录页登录的用户并且有一个登录的cookie的时候:</p><ul><li>首先判断那个sessionid存在并且从表中查找到这个sessid对应的hash了的token，则判断为认证通过的用户，然后再重新分配一个sessid和token覆盖掉这条记录，并且生成一个新的登录cookie写到客户端上</li><li>如果sessid存在但token不匹配，则认为被攻击了，然后删除这个session对应的cookie全部删除</li><li>如果sessid和用户名都不存在则忽略login cookie返回到登录页面</li></ul><p>但是这是有并发的问题即:<br>当用户的两个tab同时打开的时候，这个前一个tab会更新token,然后后一个tab由于去比较token导致token不匹配，因为前面的tab已经更新过了，从而导致被认为是被伪造的攻击而退出到登录界面。</p><p>创建用户和登录的时候要加密那个密码，当登录的时候，</p></li></ul><h2 id="基于Cookie认证"><a href="#基于Cookie认证" class="headerlink" title="基于Cookie认证"></a>基于Cookie认证</h2><p>步骤如下:<br>-</p><h2 id="基于Token认证"><a href="#基于Token认证" class="headerlink" title="基于Token认证"></a>基于Token认证</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学session与cookie相关的内容，有以下几点疑点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Session存储在哪？&lt;/li&gt;
&lt;li&gt;记住密码功能及相关的bug&lt;/li&gt;
&lt;li&gt;Session持久化&lt;/li&gt;
&lt;li&gt;如果在cookie中保存那个登录信息应该保存些信息？
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>移动端开发相关</title>
    <link href="http://yoursite.com/2017/03/14/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2017/03/14/移动端开发相关/</id>
    <published>2017-03-14T14:51:15.000Z</published>
    <updated>2017-11-15T13:13:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>在做移动开发的过程中难免会遇到一些奇奇怪怪的问题，在此罗列如下:</p><h2 id="1像素问题"><a href="#1像素问题" class="headerlink" title="1像素问题"></a>1像素问题</h2><p>这是亭</p><h2 id="iOS中键盘自动大写"><a href="#iOS中键盘自动大写" class="headerlink" title="iOS中键盘自动大写"></a>iOS中键盘自动大写</h2><p>在input中写上<code>autocapitalize=&quot;off&quot;</code>即可</p><h2 id="iOS中彻底阻止用户新窗口中打开页面"><a href="#iOS中彻底阻止用户新窗口中打开页面" class="headerlink" title="iOS中彻底阻止用户新窗口中打开页面"></a>iOS中彻底阻止用户新窗口中打开页面</h2><p>在A标签中使用<code>-webkit-touch-callout:none</code>。</p><h2 id="iOS中禁止用户保存图片"><a href="#iOS中禁止用户保存图片" class="headerlink" title="iOS中禁止用户保存图片"></a>iOS中禁止用户保存图片</h2><p>img标签上写<code>-webkit-touch-callout:none</code>。</p><h2 id="iOS禁止用户选中文字"><a href="#iOS禁止用户选中文字" class="headerlink" title="iOS禁止用户选中文字"></a>iOS禁止用户选中文字</h2><p><code>-webkit-user-select:none</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在做移动开发的过程中难免会遇到一些奇奇怪怪的问题，在此罗列如下:&lt;/p&gt;
&lt;h2 id=&quot;1像素问题&quot;&gt;&lt;a href=&quot;#1像素问题&quot; class=&quot;headerlink&quot; title=&quot;1像素问题&quot;&gt;&lt;/a&gt;1像素问题&lt;/h2&gt;&lt;p&gt;这是亭&lt;/p&gt;
&lt;h2 id=&quot;iO
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="FrontEnd" scheme="http://yoursite.com/categories/Tech/FrontEnd/"/>
    
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
      <category term="1像素" scheme="http://yoursite.com/tags/1%E5%83%8F%E7%B4%A0/"/>
    
  </entry>
  
  <entry>
    <title>React源码解读</title>
    <link href="http://yoursite.com/2017/03/06/React%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2017/03/06/React源码解读/</id>
    <published>2017-03-05T16:45:02.000Z</published>
    <updated>2017-10-12T01:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>React源码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;React源码&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>lib-flexible源码解读及实战</title>
    <link href="http://yoursite.com/2016/12/30/lib-flexible%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    <id>http://yoursite.com/2016/12/30/lib-flexible源码解读/</id>
    <published>2016-12-30T00:52:07.000Z</published>
    <updated>2017-10-19T15:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">Flexible</a>方案是淘宝的移动端适配方案,相关的文章在<a href="https://github.com/amfe/article/issues/17" target="_blank" rel="external">这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">;(function(win, lib) &#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;)(window, window[&apos;lib&apos;] || (window[&apos;lib&apos;] = &#123;&#125;));</div></pre></td></tr></table></figure><p>这是一个插件的写法之一。你还可以在这里找到其它方法(IIFE)[<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/]。" target="_blank" rel="external">http://benalman.com/news/2010/11/immediately-invoked-function-expression/]。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (metaEl) &#123;</div><div class="line">    console.warn(&apos;将根据已有的meta标签来设置缩放比例&apos;);</div><div class="line">    var match = metaEl.getAttribute(&apos;content&apos;).match(/initial\-scale=([\d\.]+)/);</div><div class="line">    if (match) &#123;</div><div class="line">        scale = parseFloat(match[1]);</div><div class="line">        dpr = parseInt(1 / scale);</div><div class="line">    &#125;</div><div class="line">&#125; else if (flexibleEl) &#123;</div><div class="line">    var content = flexibleEl.getAttribute(&apos;content&apos;);</div><div class="line">    if (content) &#123;</div><div class="line">        var initialDpr = content.match(/initial\-dpr=([\d\.]+)/);</div><div class="line">        var maximumDpr = content.match(/maximum\-dpr=([\d\.]+)/);</div><div class="line">        if (initialDpr) &#123;</div><div class="line">            dpr = parseFloat(initialDpr[1]);</div><div class="line">            scale = parseFloat((1 / dpr).toFixed(2));    </div><div class="line">        &#125;</div><div class="line">        if (maximumDpr) &#123;</div><div class="line">            dpr = parseFloat(maximumDpr[1]);</div><div class="line">            scale = parseFloat((1 / dpr).toFixed(2));    </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>首先这里会判断是否写了<code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;</code>元素。如果有则从页面中取出对应的缩放系数<strong>(scale)</strong>。然后通过<strong>(scale)</strong>算出对应的设备像素比<strong>(dpr)</strong>.</p><p>如果页面上写了<code>&lt;meta name=&quot;flexible&quot; content=&quot;initial-dpr=2,maximum-dpr=3&quot; /&gt;</code>则会取<code>initial-dpr</code>和<code>maximum-dpr</code>之中最大者。</p><p>如果以上两都都没设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (!dpr &amp;&amp; !scale) &#123;</div><div class="line">    var isAndroid = win.navigator.appVersion.match(/android/gi);</div><div class="line">    var isIPhone = win.navigator.appVersion.match(/iphone/gi);</div><div class="line">    var devicePixelRatio = win.devicePixelRatio;</div><div class="line">    if (isIPhone) &#123;</div><div class="line">        // iOS下,2倍屏使用2倍方案,3的屏3倍的方案，其余的用1倍方案</div><div class="line">        if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123;                </div><div class="line">            dpr = 3;</div><div class="line">        &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2))&#123;</div><div class="line">            dpr = 2;</div><div class="line">        &#125; else &#123;</div><div class="line">            dpr = 1;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // 其他设备下，仍旧使用1倍的方案</div><div class="line">        dpr = 1;</div><div class="line">    &#125;</div><div class="line">    scale = 1 / dpr;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>这里有检测当在安卓下的时候并没有使用高清方案，具体的原因可见<a href="https://github.com/amfe/lib-flexible/issues/11" target="_blank" rel="external">issue</a><br>大概的意思就是说有些安卓设置的<code>initial-scale</code>不为1的时候会无效。</strong>。由于这个原因会产生一些问题比如1px边框线的问题,具体可见网友的文章<a href="http://www.cnblogs.com/lyzg/p/5117324.html" target="_blank" rel="external">基于淘宝弹性布局方案lib-flexible的问题研究</a></p><p>这里在实际的工作过程假设有用<code>vue</code>的话，在移动端的适配过程中假设引用了一个<code>vue-star-rating</code>组件由于组件的<code>star-size</code>是设置的是数值，然后当你在安卓下的时候会发现这个星星会变得很大解决办法是利用<code>lib.flexible.dpr</code>或者<code>lib.flexible.rem</code>来动态设置这个组件的星星的大小，这里暂且只发现这种解决方案，如果有其它的方法或者其它的评价组件，或者自己写一个？欢迎指正-^.^-。</p><p>接下来设置页面根元素的<code>data-dpr</code>属性，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">docEl.setAttribute(&apos;data-dpr&apos;, dpr);</div><div class="line">if (!metaEl) &#123;</div><div class="line">    metaEl = doc.createElement(&apos;meta&apos;);</div><div class="line">    metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</div><div class="line">    metaEl.setAttribute(&apos;content&apos;, &apos;initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;);</div><div class="line">    //判断页面上是否有head标签没有则写一个</div><div class="line">    if (docEl.firstElementChild) &#123;</div><div class="line">        docEl.firstElementChild.appendChild(metaEl);</div><div class="line">    &#125; else &#123;</div><div class="line">        var wrap = doc.createElement(&apos;div&apos;);</div><div class="line">        wrap.appendChild(metaEl);</div><div class="line">        doc.write(wrap.innerHTML);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来是刷新rem函数计算出rem的值:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function refreshRem()&#123;</div><div class="line">    var width = docEl.getBoundingClientRect().width;</div><div class="line">    if (width / dpr &gt; 540) &#123;</div><div class="line">        width = 540 * dpr;</div><div class="line">    &#125;</div><div class="line">    var rem = width / 10;</div><div class="line">    docEl.style.fontSize = rem + &apos;px&apos;;</div><div class="line">    flexible.rem = win.rem = rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>docEl.getBoundingClientRect().width</code>这里是计算出页面在视窗里面的宽度,具体可见<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">这里</a>。<br>当<code>宽度大于540*dpr</code>的时候，则最大为<code>540 * dpr</code>。rem值为width / 10，即假设是750的iphone6的时候rem值为75,设置根元素<code>html</code>的字体大小值。</p><p>接下来是监听页面事件<code>resize</code>和<code>pageshow</code>刷新页面rem大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">win.addEventListener(&apos;resize&apos;, function() &#123;</div><div class="line">    clearTimeout(tid);</div><div class="line">    tid = setTimeout(refreshRem, 300);</div><div class="line">&#125;, false);</div><div class="line">win.addEventListener(&apos;pageshow&apos;, function(e) &#123;</div><div class="line">    if (e.persisted) &#123;</div><div class="line">        clearTimeout(tid);</div><div class="line">        tid = setTimeout(refreshRem, 300);</div><div class="line">    &#125;</div><div class="line">&#125;, false);</div></pre></td></tr></table></figure><p>监听window.document的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (doc.readyState === &apos;complete&apos;) &#123;</div><div class="line">    doc.body.style.fontSize = 12 * dpr + &apos;px&apos;;</div><div class="line">&#125; else &#123;</div><div class="line">    doc.addEventListener(&apos;DOMContentLoaded&apos;, function(e) &#123;</div><div class="line">        doc.body.style.fontSize = 12 * dpr + &apos;px&apos;;</div><div class="line">    &#125;, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当文档的<code>readyState</code>为<code>complete</code>或者为<code>DOMContentLoaded</code>即页面内容载入完成，设置body的字体大小。</p><p>最后获得主动获得rem值，页面的dpr赋值到<code>lib.flexible</code>下还有一些工具函数<code>rem2px</code>和<code>px2rem</code>。这里在实际的工作过程中,<code>lib.flexible.dpr</code>相当的有用，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">refreshRem();</div><div class="line"></div><div class="line">flexible.dpr = win.dpr = dpr;</div><div class="line">flexible.refreshRem = refreshRem;</div><div class="line">flexible.rem2px = function(d) &#123;</div><div class="line">    var val = parseFloat(d) * this.rem;</div><div class="line">    if (typeof d === &apos;string&apos; &amp;&amp; d.match(/rem$/)) &#123;</div><div class="line">        val += &apos;px&apos;;</div><div class="line">    &#125;</div><div class="line">    return val;</div><div class="line">&#125;</div><div class="line">flexible.px2rem = function(d) &#123;</div><div class="line">    var val = parseFloat(d) / this.rem;</div><div class="line">    if (typeof d === &apos;string&apos; &amp;&amp; d.match(/px$/)) &#123;</div><div class="line">        val += &apos;rem&apos;;</div><div class="line">    &#125;</div><div class="line">    return val;</div><div class="line">&#125;</div></pre></td></tr></table></figure><hr><p><strong>2017.10.19后续</strong></p><p>翻看了<a href="https://github.com/ant-design/ant-design-mobile/blob/master/components/style/mixins/hairline.less" target="_blank" rel="external">ant-design</a>中关于1px线的处理再和<strong>libflexible.js</strong>结合整理出了以下的sass函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line">@mixin hairline($color: #C7C7C7, $direction: left, $radius: 0) &#123;</div><div class="line"></div><div class="line">  @if $direction != &apos;all&apos; &#123;</div><div class="line">    border-#&#123;$direction&#125;: 1PX solid $color;</div><div class="line"></div><div class="line">    [data-dpr=&quot;1&quot;] &amp; &#123;</div><div class="line">      border-#&#123;$direction&#125;: none;</div><div class="line">      @media (min-resolution: 2dppx), (min-resolution: 192dpi) &#123;</div><div class="line">        position: relative;</div><div class="line"></div><div class="line">        &amp;:before &#123;</div><div class="line">          content: &quot; &quot;;</div><div class="line">          position: absolute;</div><div class="line">          border-#&#123;$direction&#125;: 1PX solid $color;</div><div class="line">          @if $direction == &apos;top&apos; &#123;</div><div class="line">            left: 0;</div><div class="line">            top: 0;</div><div class="line">            right: 0;</div><div class="line">            height: 1PX;</div><div class="line">            transform-origin: 0 0;</div><div class="line">            transform: scaleY(0.5);</div><div class="line">          &#125; @else if $direction == &apos;right&apos; &#123;</div><div class="line">            right: 0;</div><div class="line">            top: 0;</div><div class="line">            bottom: 0;</div><div class="line">            width: 1PX;</div><div class="line">            transform-origin: 100% 0;</div><div class="line">            transform: scaleX(0.5);</div><div class="line">          &#125; @else if $direction == &apos;bottom&apos; &#123;</div><div class="line">            left: 0;</div><div class="line">            bottom: 0;</div><div class="line">            right: 0;</div><div class="line">            height: 1PX;</div><div class="line">            transform-origin: 0 100%;</div><div class="line">            transform: scaleY(0.5);</div><div class="line">          &#125; @else &#123;</div><div class="line">            left: 0;</div><div class="line">            top: 0;</div><div class="line">            bottom: 0;</div><div class="line">            width: 1PX;</div><div class="line">            transform-origin: 0 0;</div><div class="line">            transform: scaleX(0.5);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @media (min-resolution: 3dppx), (min-resolution: 288dpi) &#123;</div><div class="line">          &amp;:before &#123;</div><div class="line">            @if $direction == &apos;top&apos; &#123;</div><div class="line">              transform: scaleY(0.33);</div><div class="line">            &#125; @else if $direction == &apos;right&apos; &#123;</div><div class="line">              transform: scaleX(0.33);</div><div class="line">            &#125; @else if $direction == &apos;bottom&apos; &#123;</div><div class="line">                transform: scaleY(0.33);</div><div class="line">            &#125; @else &#123;</div><div class="line">              transform: scaleX(0.33);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; @else &#123;</div><div class="line">    border: 1PX solid $color;</div><div class="line">    border-radius: $radius;</div><div class="line"></div><div class="line">    [data-dpr=&quot;1&quot;] &amp; &#123;</div><div class="line">      @media (min-resolution: 2dppx), (min-resolution: 192dpi) &#123;</div><div class="line">        position: relative;</div><div class="line">        border: none;</div><div class="line">        transform: translateZ(0);</div><div class="line"></div><div class="line">        &amp;:before &#123;</div><div class="line">          content: &apos;&apos;;</div><div class="line">          position: absolute;</div><div class="line">          left: 0;</div><div class="line">          top: 0;</div><div class="line">          width: 200%;</div><div class="line">          height: 200%;</div><div class="line">          border: 1PX solid $color;</div><div class="line">          border-radius: $radius * 2;</div><div class="line">          transform-origin: 0 0;</div><div class="line">          transform: scale(0.5);</div><div class="line">          box-sizing: border-box;</div><div class="line">          pointer-events: none;</div><div class="line">          z-index: -1;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@mixin hairline-remove($direction: left) &#123;</div><div class="line">  border-#&#123;$direction&#125;: 0;</div><div class="line">  &amp;:before &#123;</div><div class="line">    display: none !important;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>大体的意思是当处理<strong>高清方案的时候</strong>边框线是用的那个<code>border-#{$direction}</code>或者<code>border</code>边框线，然后利用缩放功能来获得细腻的边框线，当在安卓下的时候由伪类来显示那个边框线。</p><p><em>后面的更新的2.0版本，接下来将会进行一些思考和研究。</em></p><p>Todolist:</p><ul><li style="list-style: none"><input type="checkbox"> <strong>docEl.firstElementChild 什么情况下会没有写head?</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>地图的显示问题</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>二维码显示问题</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>window.document的<code>readyState</code>和<code>DOMContentLoaded</code>的理解</strong>。</li><li style="list-style: none"><input type="checkbox"> <strong>与其它移动端适配方案的比较</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/amfe/lib-flexible&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Flexible&lt;/a&gt;方案是淘宝的移动端适配方案,相关的文章在&lt;a href=&quot;https://github.com
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
      <category term="Source" scheme="http://yoursite.com/categories/Tech/Source/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="Mobile" scheme="http://yoursite.com/tags/Mobile/"/>
    
  </entry>
  
  <entry>
    <title>Gulp work flow</title>
    <link href="http://yoursite.com/2016/12/05/Gulp-work-flow/"/>
    <id>http://yoursite.com/2016/12/05/Gulp-work-flow/</id>
    <published>2016-12-05T01:18:08.000Z</published>
    <updated>2016-12-08T07:27:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于前端自动化的文章已经有很多，最近，我一直在做这个前端的工程化，说简单一点就是把现有的插件进行整合，从而形成自己的工具集，偶也只是站在巨人的肩膀上^-^.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于前端自动化的文章已经有很多，最近，我一直在做这个前端的工程化，说简单一点就是把现有的插件进行整合，从而形成自己的工具集，偶也只是站在巨人的肩膀上^-^.&lt;/p&gt;

      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
      <category term="automate" scheme="http://yoursite.com/tags/automate/"/>
    
  </entry>
  
  <entry>
    <title>一些Javascript的习题</title>
    <link href="http://yoursite.com/2016/10/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Javascript/"/>
    <id>http://yoursite.com/2016/10/16/深入理解Javascript/</id>
    <published>2016-10-16T12:48:29.000Z</published>
    <updated>2016-10-17T05:50:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>孔子日:学而实习之，不亦乐乎。</p></blockquote><p>在学习前端的道路上有很多的细节，也就是经验是值得去研究的，这不今天就研究了一把对象.且看以下题目：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var president = &#123;name: &apos;bush&apos;&#125;;</div><div class="line">function setName(obj) &#123;</div><div class="line">obj.name = &apos;obama&apos;;</div><div class="line">obj = &#123;name: &apos;clinton&apos;&#125;;</div><div class="line">&#125;</div><div class="line">setName(president);</div></pre></td></tr></table></figure></p><p>请问以上president将为何值?一开始我会想当然地觉得应该输出<code>{name: clinton&#39;}</code>,不过其实是错的，应该是为<code>{name: &#39;obama&#39;}</code>.那么为什么会这样呢？<br>因为对象的创建其实只是创建了一个内存地址来存放里面的内容，也就是说只是创建了一个函数指针。带着这个思考的方法，我又在函数<code>setName</code>里面打印出新创建的对象:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var president = &#123;name: &apos;bush&apos;&#125;;</div><div class="line">function setName(obj) &#123;</div><div class="line">obj.name = &apos;obama&apos;;</div><div class="line">obj = &#123;name: &apos;clinton&apos;&#125;;</div><div class="line">console.log(obj);</div><div class="line">return obj;</div><div class="line">&#125;</div><div class="line">var newPresident = setName(president);</div><div class="line">console.log(president, newPresident);</div></pre></td></tr></table></figure></p><p>返回值是<code>{name: &#39;clinton&#39;}, {name: &#39;obama&#39;}, {name: &#39;clinton&#39;}</code><br>结果，输出如预期，在函数setName里面<code>obj = {name: &#39;clinton&#39;}</code>实际上是创建了一个新的指针来存放新的内容，所以你得返回obj才会看到新建立的对象.<br><strong>以上是自己的思路，欢迎童鞋指正.</strong><br>今天先到这，未完待续……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;&lt;p&gt;孔子日:学而实习之，不亦乐乎。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在学习前端的道路上有很多的细节，也就是经验是值得去研究的，这不今天就研究了一把对象.且看以下题目：&lt;br&gt;    &lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
      <category term="Tech" scheme="http://yoursite.com/categories/Tech/"/>
    
    
      <category term="FrontEnd" scheme="http://yoursite.com/tags/FrontEnd/"/>
    
  </entry>
  
  <entry>
    <title>紧凑的生活</title>
    <link href="http://yoursite.com/2016/04/13/%E7%B4%A7%E5%87%91%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
    <id>http://yoursite.com/2016/04/13/紧凑的生活/</id>
    <published>2016-04-13T14:28:15.000Z</published>
    <updated>2016-04-14T08:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我从上海辞职回老家了，在上海工作期间，最近的这家公司，我基本上早上5点半起床，上个厕所，烧开水，上完厕所喝开水，然后开始做瑜珈，吃苹果和面包，大约6点半出门，7点半左右到公司后再到小卖部喝了点稀饭。</p><p>因为是8点半上班的所以，喝完稀饭后，我会看些自己感兴趣的事情，比如我会看些养生方面的文章，IT技术类的网站比如<a href="https://cnodejs.org" target="_blank" rel="external">cnodejs</a>, <a href="http://fex.baidu.com/" target="_blank" rel="external">百度前端</a>, etc.</p><p>接下来就是开始紧张的工作了。</p><p>晚上回家，大多数时间我都会看会电影。或者看些文章，去跑跑步。</p><p>看起来，我生活得很健康，很紧凑，可是我却感觉到了前所未有的空虚，为什么呢？我问自己，我迷失了自我。没有目标的生活让自己陷于一种光鲜的消沉之路。</p><p>我的家在一座小岛上面，靠捕渔为生，在家的几天，每天母亲都会把美味的饭菜准备好来，因为我身体进行了专门的调理，我比以前要能吃了，不像以前吃了会吐。望着父母满头的白发，这么大年纪了还在努力赚钱为了给我娶媳妇。我心里很内疚。我感觉到了家的温暖，最近这几天，脑海中总是有个声音在告诫我，必须过上紧凑的生活，有目标的生活。</p><blockquote><p>生活不止眼前的苟且还有诗和远方</p></blockquote><p>我应该去探索，应该让自己更加紧凑地生活，目标是让父母不用再为我操劳了。因为我有看过中医方面的理论，所以我觉得5点起床是可以的。</p><ul><li>5点起床,烧开水，上厕所，完后喝水。</li><li>5点半开始yoga，如果假期瑜珈后就跑步</li><li>6点开始吃早餐</li><li>6:15 看新闻</li><li>6点半开始写东西</li><li>如果在假期就在下午打篮球</li><li>晚上看书做项目，如非假期就跑步</li><li>10点半入睡</li></ul><p>先坚持一段时间再说吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，我从上海辞职回老家了，在上海工作期间，最近的这家公司，我基本上早上5点半起床，上个厕所，烧开水，上完厕所喝开水，然后开始做瑜珈，吃苹果和面包，大约6点半出门，7点半左右到公司后再到小卖部喝了点稀饭。&lt;/p&gt;
&lt;p&gt;因为是8点半上班的所以，喝完稀饭后，我会看些自己感兴趣
      
    
    </summary>
    
      <category term="Essays" scheme="http://yoursite.com/categories/Essays/"/>
    
    
      <category term="愉快生活" scheme="http://yoursite.com/tags/%E6%84%89%E5%BF%AB%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
