<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Frontend, Mobile, Nodejs, Life Essays, etc."><title>Bootstrap scrollspy 源码解读 | Poeticlife</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/3.0.3/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Bootstrap scrollspy 源码解读</h1><a id="logo" href="/.">Poeticlife</a><p class="description">大知闲闲，小知间间；大言炎炎，小言詹詹</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/categories/Tech/"><i class="fa fa-wrench"> 技术</i></a><a href="/categories/Essays/"><i class="fa fa-pencil"> 随笔</i></a><a href="/categories/works/"><i class="fa fa-briefcase"> 作品</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Bootstrap scrollspy 源码解读</h1><div class="post-meta">Aug 6, 2017<span> | </span><span class="category"><a href="/categories/Tech/">Tech</a><a href="/categories/Tech/FrontEnd/">FrontEnd</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/08/06/Bootstrap-scrollspy-源码解读/" href="/2017/08/06/Bootstrap-scrollspy-源码解读/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p>最近有在做一个滚动效果即：左边导航栏，右边内容，然后滚动左边导航栏导航当对应的内容块显示会激活导航。阅读了下Bootstrap的scrollspy源码，记录如下：</p>
<p>功能需求:</p>
<ul>
<li>当点击导航栏的时候会显示对应的内容块到顶部。</li>
<li>当页面滚动的时候，当到达对应导航的内容块，则会激活导航。</li>
</ul>
<p><strong>需要注意的是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动，从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets，这个时候就需要调用refresh方法进行重新计算offsets和targets。</strong></p>
<p>Bootstrap scrollspy源码解读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">this.$scrollElement: 滚动的容器</div><div class="line">this.selector: 导航选择器</div><div class="line">this.targets: 导航的元素</div><div class="line">this.activeTarget: 激活状态的导航元素</div><div class="line">this.offsets: 内容块元素的在页面中的位移</div><div class="line">*/</div><div class="line">function ScrollSpy(element, options) &#123;</div><div class="line">    this.$body          = $(document.body)</div><div class="line">    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)</div><div class="line">    this.options        = $.extend(&#123;&#125;, ScrollSpy.DEFAULTS, options)</div><div class="line">    this.selector       = (this.options.target || &apos;&apos;) + &apos; .nav li &gt; a&apos;</div><div class="line">    this.offsets        = []</div><div class="line">    this.targets        = []</div><div class="line">    this.activeTarget   = null</div><div class="line">    this.scrollHeight   = 0</div><div class="line"></div><div class="line">    this.$scrollElement.on(&apos;scroll.bs.scrollspy&apos;, $.proxy(this.process, this))</div><div class="line">    this.refresh()</div><div class="line">    this.process()</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>首先在<code>ScrollSpy</code>构造函数中,先获得滚动容器，导航选择器等，然后调用<code>refresh</code>和<code>process</code>函数来初始化实例。<br>获得容器的内容高度<code>scrollHeight</code>,<a href="https://www.quirksmode.org/dom/w3c_cssom.html" target="_blank" rel="external">scrollHeight</a>。<br>并绑定滚动容器的滚动事件为<code>this.process</code>。</p>
<p>再来看<code>refresh</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.refresh = function () &#123;</div><div class="line">    var that          = this</div><div class="line">    var offsetMethod  = &apos;offset&apos;</div><div class="line">    var offsetBase    = 0</div><div class="line"></div><div class="line">    this.offsets      = []</div><div class="line">    this.targets      = []</div><div class="line">    this.scrollHeight = this.getScrollHeight()</div><div class="line"></div><div class="line">    /*判断滚动窗口是否为body*/</div><div class="line">    if (!$.isWindow(this.$scrollElement[0])) &#123;</div><div class="line">      offsetMethod = &apos;position&apos;</div><div class="line">      offsetBase   = this.$scrollElement.scrollTop()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    this.$body</div><div class="line">      .find(this.selector)</div><div class="line">      .map(function () &#123;</div><div class="line">        var $el   = $(this)</div><div class="line">        var href  = $el.data(&apos;target&apos;) || $el.attr(&apos;href&apos;)</div><div class="line">        var $href = /^#./.test(href) &amp;&amp; $(href)</div><div class="line"></div><div class="line">        return ($href</div><div class="line">          &amp;&amp; $href.length</div><div class="line">          &amp;&amp; $href.is(&apos;:visible&apos;)</div><div class="line">          &amp;&amp; [[$href[offsetMethod]().top + offsetBase, href]]) || null</div><div class="line">      &#125;)</div><div class="line">      .sort(function (a, b) &#123; return a[0] - b[0] &#125;)</div><div class="line">      .each(function () &#123;</div><div class="line">        that.offsets.push(this[0])</div><div class="line">        that.targets.push(this[1])</div><div class="line">      &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里的意思是设置实例的内容块的offsets和导航栏的targets,并按升序排列。这里有一个问题就是为什么当滚动的容器不是window的话<code>offsetBase</code>为滚动容器的滚动距离？因为当一个元素在一个滚动容器里面的时候元素在滚动容器中的绝对位移值是元素的<code>position().top</code>的值加上滚动容器的滚动距离，所以这里需要写上滚动容器的滚动距离。</p>
<p>接下来是<code>process</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">scrollTop: 元素已经滚动的距离加上距离顶部的距离</div><div class="line">maxScroll: 滚动容器可滚动距离</div><div class="line">activeTarget: 当前激活的导航元素</div><div class="line"></div><div class="line">*/</div><div class="line">ScrollSpy.prototype.process = function () &#123;</div><div class="line">    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset</div><div class="line">    var scrollHeight = this.getScrollHeight()</div><div class="line">    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()</div><div class="line">    var offsets      = this.offsets</div><div class="line">    var targets      = this.targets</div><div class="line">    var activeTarget = this.activeTarget</div><div class="line">    var i</div><div class="line"></div><div class="line">    /*</div><div class="line">    这里的意思是因为当容器滚动的时候页面上面的元素有可能，比如当滚动50px，容器有元素就会浮动</div><div class="line">    从而造成滚动计算的时候会出现偏差, 就需要去重新计算offsets和targets</div><div class="line">    */</div><div class="line">    if (this.scrollHeight != scrollHeight) &#123;</div><div class="line">      this.refresh()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /*</div><div class="line">    当滚动距离超过最大可滚动距离，并且activeTarget和最后一个激活元素地址不一致则激活最后一级导航</div><div class="line">    */</div><div class="line">    if (scrollTop &gt;= maxScroll) &#123;</div><div class="line">      return activeTarget != (i = targets[targets.length - 1]) &amp;&amp; this.activate(i)</div><div class="line">    &#125;</div><div class="line">    /*</div><div class="line">     当滚动距离小于offsets中的第一个并且有激活的导航的时候就不激活导航</div><div class="line">    */</div><div class="line">    if (activeTarget &amp;&amp; scrollTop &lt; offsets[0]) &#123;</div><div class="line">      this.activeTarget = null</div><div class="line">      return this.clear()</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    for (i = offsets.length; i--;) &#123;</div><div class="line">      activeTarget != targets[i]</div><div class="line">        &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">        &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">        &amp;&amp; this.activate(targets[i])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (i = offsets.length; i--;) &#123;</div><div class="line">  activeTarget != targets[i]</div><div class="line">    &amp;&amp; scrollTop &gt;= offsets[i]</div><div class="line">    &amp;&amp; (offsets[i + 1] === undefined || scrollTop &lt; offsets[i + 1])</div><div class="line">    &amp;&amp; this.activate(targets[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前激活的导航和targets数组一一比对如果不是当前激活导航则再比对，注意到这里的比对是<em>从位移数组的最后一个开始倒序进行比对的</em>, 然后当滚动距离大于位移数组的当前并且小于下一个，或者位移数组的最后一个不存在，即为最后一个导航的时候。则激活目标导航, <strong>那么这里你所看到的现象即: 当上一个目标内容元素完全消失于viewport(视窗)之中的时候,下一个内容块到达视窗顶部的时候即激活当前的导航所在的元素</strong>。当当然这里也有性能优化的意思，然后倒序来比较有一个好处就是，如果是升序比较就得计算那个<em>内容元素的高度来进行比较</em>，但是倒序则不用。</p>
<p>疑问:</p>
<ul>
<li>为什么当滚动容器是body的时候<code>offsetMethod</code>为<em>offset</em>非<code>body</code>的时候为<em>position</em>?</li>
</ul>
<p>因为当滚动容器为body的时候就得计算元素在body上面的位移，而如果非body的话就在滚动容器里面比如<br><code>&lt;div class=&quot;scroll-container&quot;&gt;&lt;/div&gt;</code>当滚动的内容在里面的时候得设置滚动容器的样式<code>position: relative</code>。<br>当设置为<code>position</code>的时候里面的内容元素即为相对于此容器的位移而不是相对于<code>body</code>。</p>
<p>翻看<code>jQuery源码</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">position: function() &#123;</div><div class="line">  if ( !this[ 0 ] ) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  var offsetParent, offset,</div><div class="line">    elem = this[ 0 ],</div><div class="line">    parentOffset = &#123; top: 0, left: 0 &#125;;</div><div class="line"></div><div class="line">  // Fixed elements are offset from window (parentOffset = &#123;top:0, left: 0&#125;,</div><div class="line">  // because it is its only offset parent</div><div class="line">  if ( jQuery.css( elem, &quot;position&quot; ) === &quot;fixed&quot; ) &#123;</div><div class="line"></div><div class="line">    // Assume getBoundingClientRect is there when computed position is fixed</div><div class="line">    offset = elem.getBoundingClientRect();</div><div class="line"></div><div class="line">  &#125; else &#123;</div><div class="line"></div><div class="line">    // Get *real* offsetParent</div><div class="line">    offsetParent = this.offsetParent();</div><div class="line"></div><div class="line">    // Get correct offsets</div><div class="line">    offset = this.offset();</div><div class="line">    if ( !jQuery.nodeName( offsetParent[ 0 ], &quot;html&quot; ) ) &#123;</div><div class="line">      parentOffset = offsetParent.offset();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Add offsetParent borders</div><div class="line">    parentOffset = &#123;</div><div class="line">      top: parentOffset.top + jQuery.css( offsetParent[ 0 ], &quot;borderTopWidth&quot;, true ),</div><div class="line">      left: parentOffset.left + jQuery.css( offsetParent[ 0 ], &quot;borderLeftWidth&quot;, true )</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // Subtract parent offsets and element margins</div><div class="line">  return &#123;</div><div class="line">    top: offset.top - parentOffset.top - jQuery.css( elem, &quot;marginTop&quot;, true ),</div><div class="line">    left: offset.left - parentOffset.left - jQuery.css( elem, &quot;marginLeft&quot;, true )</div><div class="line">  &#125;;</div><div class="line">&#125;,</div><div class="line">offsetParent: function() &#123;</div><div class="line">  return this.map( function() &#123;</div><div class="line">    var offsetParent = this.offsetParent;</div><div class="line"></div><div class="line">    while ( offsetParent &amp;&amp; jQuery.css( offsetParent, &quot;position&quot; ) === &quot;static&quot; ) &#123;</div><div class="line">      offsetParent = offsetParent.offsetParent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return offsetParent || documentElement;</div><div class="line">  &#125; );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的源码大概意思如果元素不是<code>fixed</code>定位则通过<code>offsetParent</code>函数找出最近的定位的元素。</p>
<p>接下来是激活导航的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.activate = function (target) &#123;</div><div class="line">  this.activeTarget = target</div><div class="line"></div><div class="line">  this.clear()</div><div class="line"></div><div class="line">  var selector = this.selector +</div><div class="line">    &apos;[data-target=&quot;&apos; + target + &apos;&quot;],&apos; +</div><div class="line">    this.selector + &apos;[href=&quot;&apos; + target + &apos;&quot;]&apos;</div><div class="line"></div><div class="line">  var active = $(selector)</div><div class="line">    .parents(&apos;li&apos;)</div><div class="line">    .addClass(&apos;active&apos;)</div><div class="line"></div><div class="line">  // 若激活的导航的父元素有dropdown-men类则为其</div><div class="line">  if (active.parent(&apos;.dropdown-menu&apos;).length) &#123;</div><div class="line">    active = active</div><div class="line">      .closest(&apos;li.dropdown&apos;)</div><div class="line">      .addClass(&apos;active&apos;)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  active.trigger(&apos;activate.bs.scrollspy&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后是那个<code>noConflict</code>方法, 因为有可能会有重名方法的插件所以需要使用这个关于这个的处理可以参见<a href="http://www.cnblogs.com/ip128/p/4609828.html" target="_blank" rel="external">这里</a>。我在这个基础上增加了自己的一个处理方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var old = $.fn.scrollspy</div><div class="line"></div><div class="line">$.fn.scrollspy             = Plugin</div><div class="line">$.fn.scrollspy.Constructor = ScrollSpy</div><div class="line"></div><div class="line"></div><div class="line">// SCROLLSPY NO CONFLICT</div><div class="line">// =====================</div><div class="line"></div><div class="line">$.fn.scrollspy.noConflict = function () &#123;</div><div class="line">  $.fn.scrollspy = old</div><div class="line">  return this</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在实际使用的过程中,根据所使用的Bootstrap插件在页面中出现的位置会有不同的处理方法,下面分情况来讲解:</p>
<ul>
<li>当Bootstrap插件在自定义的插件之后的时候, 若想调用自定义的插件则<code>$.fn.scrollspy.noConflict</code>即可。</li>
<li><p>若Bootstrap插件在自定义的插件之前: 则有两种解决办法:</p>
<ul>
<li><p>可以在两个插件之间写上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Af = $.fn.scrollspy.noConflict()</div><div class="line">$.fn.Af = Af</div><div class="line">这样后面想要调用该方法就调用`$(el).Af()`</div></pre></td></tr></table></figure>
</li>
<li><p>或者是把后面自定义的插件写成类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">(function($)&#123;</div><div class="line">      var old = $.fn.scrollspy; //必须写在第一行</div><div class="line">      $.fn.scrollspy=function()&#123;</div><div class="line">          alert(&quot;自定义scrollspy插件&quot;);</div><div class="line">      &#125;</div><div class="line">      $.fn.scrollspy.noConflict = function () &#123;</div><div class="line">        $.fn.scrollspy = old</div><div class="line">        return this</div><div class="line">      &#125;</div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>疑问：</p>
<ul>
<li>这里为什么要用<code>parents</code>?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var active = $(selector)</div><div class="line">          .parents(&apos;li&apos;)</div><div class="line">          .addClass(&apos;active&apos;)</div></pre></td></tr></table></figure>
<p>清除激活状态导航的激活状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ScrollSpy.prototype.clear = function () &#123;</div><div class="line">    $(this.selector)</div><div class="line">      .parentsUntil(this.options.target, &apos;.active&apos;)</div><div class="line">      .removeClass(&apos;active&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>当那些导航是异步请求加载出来的，这个时候应该如何做？</li>
</ul>
<hr>
<p>2017.10.8 如果导航是异步请求出来的可以在数据请求完成后再去进行实例化。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>其实，这个说到底不管滚动的容器是window还是不是，基本上都是要以元素的<code>getBoundingClientRect</code>属性为准，看过<strong>jQuery</strong>的源码即可知。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/08/06/Bootstrap-scrollspy-源码解读/" data-id="cjcdejyvy0008dnklfmg5fcv6" class="article-share-link">分享到</a><div class="tags"><a href="/tags/jQuery/">jQuery</a><a href="/tags/scrollSpy/">scrollSpy</a><a href="/tags/offset/">offset</a><a href="/tags/position/">position</a></div><div class="post-nav"><a href="/2017/08/10/CSS常用库/" class="pre">CSS常用库</a><a href="/2017/07/21/二维码登录/" class="next">二维码登录</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论 「请确保 disqus.com 可以正常加载」</button></div><script>var disqus_shortname = 'troland';
var disqus_identifier = '2017/08/06/Bootstrap-scrollspy-源码解读/';
var disqus_title = 'Bootstrap scrollspy 源码解读';
var disqus_url = 'http://yoursite.com/2017/08/06/Bootstrap-scrollspy-源码解读/';
$('.btn_click_load').click(function() {
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
  $('.btn_click_load').css('display','none');
});
$.ajax({
  url: 'https://disqus.com/favicon.ico',
  timeout: 3000,
  type: 'GET',
  success: (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    $('.btn_click_load').css('display','none');
  })(),
  error: function() {
    $('.btn_click_load').css('display','block');
  }
});</script><script id="dsq-count-scr" src="//troland.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Backend/">Backend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Essays/">Essays</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FrontEnd/">FrontEnd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/">Tech</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/FrontEnd/">FrontEnd</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tech/Source/">Source</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/backend/">backend</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/Essays/">Essays</a></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Buffer/" style="font-size: 15px;">Buffer</a> <a href="/tags/FrontEnd/" style="font-size: 15px;">FrontEnd</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/scrollSpy/" style="font-size: 15px;">scrollSpy</a> <a href="/tags/offset/" style="font-size: 15px;">offset</a> <a href="/tags/position/" style="font-size: 15px;">position</a> <a href="/tags/affix/" style="font-size: 15px;">affix</a> <a href="/tags/Dom/" style="font-size: 15px;">Dom</a> <a href="/tags/CurrentTarget/" style="font-size: 15px;">CurrentTarget</a> <a href="/tags/app/" style="font-size: 15px;">app</a> <a href="/tags/mui/" style="font-size: 15px;">mui</a> <a href="/tags/hybrid/" style="font-size: 15px;">hybrid</a> <a href="/tags/css/" style="font-size: 15px;">css</a> <a href="/tags/automate/" style="font-size: 15px;">automate</a> <a href="/tags/Hoisting/" style="font-size: 15px;">Hoisting</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/express/" style="font-size: 15px;">express</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/token/" style="font-size: 15px;">token</a> <a href="/tags/jwt/" style="font-size: 15px;">jwt</a> <a href="/tags/jsonwebtoken/" style="font-size: 15px;">jsonwebtoken</a> <a href="/tags/Mobile/" style="font-size: 15px;">Mobile</a> <a href="/tags/Design-Pattern/" style="font-size: 15px;">Design Pattern</a> <a href="/tags/Event-Proxy/" style="font-size: 15px;">Event Proxy</a> <a href="/tags/pageYOffset/" style="font-size: 15px;">pageYOffset</a> <a href="/tags/viewport/" style="font-size: 15px;">viewport</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/microtask/" style="font-size: 15px;">microtask</a> <a href="/tags/task/" style="font-size: 15px;">task</a> <a href="/tags/event-loop/" style="font-size: 15px;">event loop</a> <a href="/tags/animate/" style="font-size: 15px;">animate</a> <a href="/tags/生活/" style="font-size: 15px;">生活</a> <a href="/tags/人生感悟/" style="font-size: 15px;">人生感悟</a> <a href="/tags/fixed/" style="font-size: 15px;">fixed</a> <a href="/tags/1像素/" style="font-size: 15px;">1像素</a> <a href="/tags/愉快生活/" style="font-size: 15px;">愉快生活</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/01/13/Dcloud-个推总结/">DCloud 个推总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/21/任务，微任务，队列，计划/">任务，微任务，队列，计划</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/16/第五种定位属性/">第五种定位属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/常用-Git-命令及工作流/">常用 Git 命令及工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/两种视口的故事系列之二/">两种视口的故事系列之二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/03/两种视窗的故事系列之一/">两种视口的故事系列之一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/事件委托，事件代理，发布者订阅者模式/">事件委托，事件代理，发布者订阅者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/12/动画收集/">动画收集</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/28/DOM相关/">DOM相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/21/Nodejs-ES6/">Nodejs ES6</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//troland.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.w.com/" title="医方" target="_blank">医方</a><ul></ul><a href="https://github.com/Troland" title="我的Github" target="_blank">我的Github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Poeticlife.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>